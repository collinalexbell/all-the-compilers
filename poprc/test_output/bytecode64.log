___ algorithm.^ (2 -> 1) ___
[1] var :: ?i x1
[2] var :: ?i x1
[3] val 1 :: i x1
[4] jump algorithm.^:iterate 1 2 3 :: i x1
[5] return [4]

___ algorithm.^:iterate (3 -> 1) x3 rec ___
[1] changing var :: ?i x3
[2] changing var :: ?i x3
[3] changing var :: ?i x3
[4] __primitive.neq &3 5 :: y x3
[5] val 0 :: i x1
[6] __primitive.not &4 :: y x1
[7] __primitive.assert &1 6 :: i? x1
[8] return [7] -> 18
[9] __primitive.assert 17 &4 :: i? x1
[10] __primitive.shiftr &3 &11 :: i x2.
[11] val 1 :: i x3
[12] __primitive.mul &2 &2 :: i x2.
[13] __primitive.bitand 3 &11 in [0, 1] :: i x1.
[14] __primitive.eq 13 11 :: y x2.
[15] __primitive.assert 16 &14 :: i? x1
[16] __primitive.mul 1 2 :: i x1
[17] jump algorithm.^:iterate 10 12 15 :: i x1
[18] return [9] -> 23
[19] __primitive.assert 22 4 :: i? x1
[20] __primitive.not 14 :: y x1
[21] __primitive.assert 1 20 :: i? x1
[22] jump algorithm.^:iterate 10 12 21 :: i x1
[23] return [19]

___ algorithm.acc_odd_power (3 -> 1) x2 ___
[1] var :: ?i x1
[2] var :: ?i x1
[3] var :: ?i x2
[4] __primitive.bitand 1 &5 in [0, 1] :: i x1
[5] val 1 :: i x2
[6] __primitive.eq 4 5 :: y x2
[7] __primitive.assert 8 &6 :: i? x1
[8] __primitive.mul 3 2 :: i x1
[9] return [7] -> 12
[10] __primitive.not 6 :: y x1
[11] __primitive.assert 3 10 :: i? x1
[12] return [11]

___ algorithm.avgf (1 -> 1) ___
[1] var :: ?l x2
[2] algorithm.sumf:foldr:iterate 3 &1 :: d x1
[3] val 0 :: d x1
[4] list.length:iterate 1 5 :: i x1
[5] val 0 :: i x1
[6] __primitive.to_float 4 :: d x1
[7] __primitive.div_float 2 6 :: d? x1
[8] return [7]

___ algorithm.gcd (2 -> 1) ___
[1] var :: ?i x1
[2] var :: ?i x1
[3] jump algorithm.gcd:iterate 1 2 :: i x1
[4] return [3]

___ algorithm.gcd:iterate (2 -> 1) x2 rec ___
[1] changing var :: ?i x2
[2] changing var :: ?i x3
[3] __primitive.neq &2 4 :: y x2
[4] val 0 :: i x1
[5] __primitive.not &3 :: y x1
[6] __primitive.assert &1 5 :: i? x1
[7] return [6] -> 11
[8] __primitive.assert 10 3 :: i? x1
[9] __primitive.mod 1 &2 :: i? x1
[10] jump algorithm.gcd:iterate 9 2 :: i x1
[11] return [8]

___ algorithm.in_range (3 -> 1) x2 ___
[1] var :: ?i x1
[2] var :: ?i x1
[3] var :: ?i x2
[4] __primitive.lte &3 1 :: y x2
[5] __primitive.assert 6 &4 :: y? x1
[6] __primitive.gte 3 2 :: y x1
[7] return [5] -> 11
[8] __primitive.not 4 :: y x1
[9] __primitive.assert 10 8 is False :: y? x1
[10] val False :: y x1
[11] return [9]

___ algorithm.iota2 (1 -> 1) ___
[1] var :: ?l x1
[2] jump algorithm.iota2:iterate 1 :: l x1
[3] return [2]

___ algorithm.iota2:iterate (1 -> 1) x2 rec ___
[1] changing var :: ?l x2
[2] __primitive.ap &1 -> 3 :: l? x2
[3] __primitive.dep 2 :: i x3
[4] __primitive.gt &3 5 :: y x2
[5] val 0 :: i x1
[6] __primitive.not &4 :: y x1
[7] __primitive.assert 1 6 :: l? x1
[8] return [7] -> 14
[9] __primitive.assert 13 4 :: l? x1
[10] __primitive.sub &3 11 :: i x1
[11] val 1 :: i x1
[12] __primitive.pushr 2 3 10 :: l x1
[13] jump algorithm.iota2:iterate 12 :: l x1
[14] return [9]

___ algorithm.power_step (3 -> 3) x2 ___
[1] var :: ?i x2
[2] var :: ?i x3
[3] var :: ?i x2
[4] __primitive.shiftr &1 &5 :: i x2
[5] val 1 :: i x3
[6] __primitive.mul &2 &2 :: i x2
[7] __primitive.bitand 1 &5 in [0, 1] :: i x1
[8] __primitive.eq 7 5 :: y x2
[9] __primitive.assert 10 &8 :: i? x1
[10] __primitive.mul 3 2 :: i x1
[11] return [9 6 4] -> 15
[13] __primitive.not 8 :: y x1
[14] __primitive.assert 3 13 :: i? x1
[15] return [14 6 4]

___ algorithm.reduce_power (2 -> 2) ___
[1] var :: ?i x1
[2] var :: ?i x2
[3] __primitive.shiftr 1 4 :: i x1
[4] val 1 :: i x1
[5] __primitive.mul &2 2 :: i x1
[6] return [5 3]

___ algorithm.sum (1 -> 1) ___
[1] var :: ?l x1
[2] val 0 :: i x1
[3] jump algorithm.sum:foldr:iterate 2 1 :: i x1
[4] return [3]

___ algorithm.sum:foldr:iterate (2 -> 1) x2 rec ___
[1] changing var :: ?l x1
[2] changing var :: ?i x2
[3] __primitive.ap 1 -> 4 :: l? x2
[4] __primitive.dep 3 :: i x3
[5] __primitive.seq 7 &4 :: v x1
[6] __primitive.add 4 2 :: i x1
[7] jump algorithm.sum:foldr:iterate 6 3 :: v x1
[8] return [5] -> 10
[9] __primitive.unless 2 4 :: i x1
[10] return [9]

___ algorithm.sumf (1 -> 1) ___
[1] var :: ?l x1
[2] val 0 :: d x1
[3] jump algorithm.sumf:foldr:iterate 2 1 :: d x1
[4] return [3]

___ algorithm.sumf:foldr:iterate (2 -> 1) x2 rec ___
[1] changing var :: ?l x1
[2] changing var :: ?d x2
[3] __primitive.ap 1 -> 4 :: l? x2
[4] __primitive.dep 3 :: d x3
[5] __primitive.seq 7 &4 :: v x1
[6] __primitive.add_float 4 2 :: d x1
[7] jump algorithm.sumf:foldr:iterate 6 3 :: v x1
[8] return [5] -> 10
[9] __primitive.unless 2 4 :: d x1
[10] return [9]

___ control.!! (3 -> 2) ___
[1] var :: ?y x2
[2] var :: ?a x1
[3] var :: ?a x1
[4] __primitive.assert 2 &1 :: a? x1
[5] __primitive.assert 3 1 :: a? x1
[6] return [5 4]

___ control.!!! (4 -> 3) ___
[1] var :: ?y x3
[2] var :: ?a x1
[3] var :: ?a x1
[4] var :: ?a x1
[5] __primitive.assert 2 &1 :: a? x1
[6] __primitive.assert 3 &1 :: a? x1
[7] __primitive.assert 4 1 :: a? x1
[8] return [7 6 5]

___ control.$ (2 -> 1) ___
[1] var :: ?l x1
[2] var :: ?a x1
[3] __primitive.ap 2 1 -> 4 :: v? x1
[4] __primitive.dep 3 :: a x1
[5] return [4]

___ control.$$ (3 -> 1) ___
[1] var :: ?l x1
[2] var :: ?a x1
[3] var :: ?a x1
[4] __primitive.ap 3 2 1 -> 5 :: v? x1
[5] __primitive.dep 4 :: a x1
[6] return [5]

___ control.$$$ (4 -> 1) ___
[1] var :: ?l x1
[2] var :: ?a x1
[3] var :: ?a x1
[4] var :: ?a x1
[5] __primitive.ap 4 3 2 1 -> 7 :: v? x1
[7] __primitive.dep 5 :: a x1
[8] return [7]

___ control.$$$$ (5 -> 1) ___
[1] var :: ?l x1
[2] var :: ?a x1
[3] var :: ?a x1
[4] var :: ?a x1
[5] var :: ?a x1
[6] __primitive.ap 5 4 3 2 1 -> 8 :: v? x1
[8] __primitive.dep 6 :: a x1
[9] return [8]

___ control.$$$$- (5 -> 2) ___
[1] var :: ?l x1
[2] var :: ?a x1
[3] var :: ?a x1
[4] var :: ?a x1
[5] var :: ?a x1
[6] __primitive.ap 5 4 3 2 1 -> 9 8 :: v? x2
[8] __primitive.dep 6 :: a x1
[9] __primitive.dep 6 :: a x1
[10] return [9 8]

___ control.$$$$-- (5 -> 3) ___
[1] var :: ?l x1
[2] var :: ?a x1
[3] var :: ?a x1
[4] var :: ?a x1
[5] var :: ?a x1
[6] __primitive.ap 5 4 3 2 1 -> 10 9 8 :: v? x3
[8] __primitive.dep 6 :: a x1
[9] __primitive.dep 6 :: a x1
[10] __primitive.dep 6 :: a x1
[11] return [10 9 8]

___ control.$$$- (4 -> 2) ___
[1] var :: ?l x1
[2] var :: ?a x1
[3] var :: ?a x1
[4] var :: ?a x1
[5] __primitive.ap 4 3 2 1 -> 8 7 :: v? x2
[7] __primitive.dep 5 :: a x1
[8] __primitive.dep 5 :: a x1
[9] return [8 7]

___ control.$$$-- (4 -> 3) ___
[1] var :: ?l x1
[2] var :: ?a x1
[3] var :: ?a x1
[4] var :: ?a x1
[5] __primitive.ap 4 3 2 1 -> 9 8 7 :: v? x3
[7] __primitive.dep 5 :: a x1
[8] __primitive.dep 5 :: a x1
[9] __primitive.dep 5 :: a x1
[10] return [9 8 7]

___ control.$$$-keep (4 -> 3) ___
[1] var :: ?l x2
[2] var :: ?a x1
[3] var :: ?a x1
[4] var :: ?a x1
[5] __primitive.ap 4 3 2 &1 -> 8 7 :: v? x2
[7] __primitive.dep 5 :: a x1
[8] __primitive.dep 5 :: a x1
[9] return [8 7 1]

___ control.$$$keep (4 -> 2) ___
[1] var :: ?l x2
[2] var :: ?a x1
[3] var :: ?a x1
[4] var :: ?a x1
[5] __primitive.ap 4 3 2 &1 -> 7 :: v? x1
[7] __primitive.dep 5 :: a x1
[8] return [7 1]

___ control.$$- (3 -> 2) ___
[1] var :: ?l x1
[2] var :: ?a x1
[3] var :: ?a x1
[4] __primitive.ap 3 2 1 -> 7 6 :: v? x2
[6] __primitive.dep 4 :: a x1
[7] __primitive.dep 4 :: a x1
[8] return [7 6]

___ control.$$-- (3 -> 3) ___
[1] var :: ?l x1
[2] var :: ?a x1
[3] var :: ?a x1
[4] __primitive.ap 3 2 1 -> 8 7 6 :: v? x3
[6] __primitive.dep 4 :: a x1
[7] __primitive.dep 4 :: a x1
[8] __primitive.dep 4 :: a x1
[9] return [8 7 6]

___ control.$$-keep (3 -> 3) ___
[1] var :: ?l x2
[2] var :: ?a x1
[3] var :: ?a x1
[4] __primitive.ap 3 2 &1 -> 7 6 :: v? x2
[6] __primitive.dep 4 :: a x1
[7] __primitive.dep 4 :: a x1
[8] return [7 6 1]

___ control.$$keep (3 -> 2) ___
[1] var :: ?l x2
[2] var :: ?a x1
[3] var :: ?a x1
[4] __primitive.ap 3 2 &1 -> 5 :: v? x1
[5] __primitive.dep 4 :: a x1
[6] return [5 1]

___ control.$- (2 -> 2) ___
[1] var :: ?l x1
[2] var :: ?a x1
[3] __primitive.ap 2 1 -> 5 4 :: v? x2
[4] __primitive.dep 3 :: a x1
[5] __primitive.dep 3 :: a x1
[6] return [5 4]

___ control.$-- (2 -> 3) ___
[1] var :: ?l x1
[2] var :: ?a x1
[3] __primitive.ap 2 1 -> 7 6 5 :: v? x3
[5] __primitive.dep 3 :: a x1
[6] __primitive.dep 3 :: a x1
[7] __primitive.dep 3 :: a x1
[8] return [7 6 5]

___ control.$-keep (2 -> 3) ___
[1] var :: ?l x2
[2] var :: ?a x1
[3] __primitive.ap 2 &1 -> 5 4 :: v? x2
[4] __primitive.dep 3 :: a x1
[5] __primitive.dep 3 :: a x1
[6] return [5 4 1]

___ control.$-seq (2 -> 2) ___
[1] var :: ?l x1
[2] var :: ?a x3
[3] __primitive.seq 5 &2 :: a x1
[4] __primitive.ap &2 1 -> 7 5 :: v? x2
[5] __primitive.dep 4 :: a x1
[6] __primitive.seq 7 2 :: a x1
[7] __primitive.dep 4 :: a x1
[8] return [6 3]

___ control.$keep (2 -> 2) ___
[1] var :: ?l x2
[2] var :: ?a x1
[3] __primitive.ap 2 &1 -> 4 :: v? x1
[4] __primitive.dep 3 :: a x1
[5] return [4 1]

___ control.$seq (2 -> 1) ___
[1] var :: ?l x1
[2] var :: ?a x2
[3] __primitive.seq 5 &2 :: a x1
[4] __primitive.ap 2 1 -> 5 :: v? x1
[5] __primitive.dep 4 :: a x1
[6] return [3]

___ control.-> (2 -> 2) ___
[1] var :: ?l x1
[2] var :: ?a x2
[3] __primitive.ap &2 1 -> 4 :: v? x1
[4] __primitive.dep 3 :: a x1
[5] return [4 2]

___ control.->cmp (2 -> 2) ___
[1] var :: ?l x1
[2] var :: ?l x2
[3] __primitive.compose &2 1 :: l x1
[4] return [3 2]

___ control.bitree (4 -> 1) x2 rec ___
[1] var :: ?l x3
[2] var :: ?l x3
[3] var :: ?l x3
[4] changing var :: ?a x2
[5] __primitive.ap &4 &3 -> 9 6 :: v? x2
[6] __primitive.dep 5 :: a x1
[7] control.bitree 6 &3 &2 &1 :: v x1
[9] __primitive.dep 5 :: a x1
[10] control.bitree 9 3 &2 &1 :: v x1
[12] __primitive.ap 10 7 1 -> 13 :: v? x1
[13] __primitive.dep 12 :: a x2
[14] return [13] -> 18
[15] __primitive.unless 17 13 :: a x1
[16] __primitive.ap 4 2 -> 17 :: v? x1
[17] __primitive.dep 16 :: a x1
[18] return [15]

___ control.both (3 -> 2) ___
[1] var :: ?l x2
[2] var :: ?a x1
[3] var :: ?a x1
[4] __primitive.ap 2 &1 -> 5 :: v? x1
[5] __primitive.dep 4 :: a x1
[6] __primitive.ap 3 1 -> 7 :: v? x1
[7] __primitive.dep 6 :: a x1
[8] return [7 5]

___ control.diamond (4 -> 1) ___
[1] var :: ?l x1
[2] var :: ?l x2
[3] var :: ?l x1
[4] var :: ?a x1
[5] __primitive.ap 4 3 -> 9 6 :: v? x2
[6] __primitive.dep 5 :: a x1
[7] __primitive.ap 6 &2 -> 8 :: v? x1
[8] __primitive.dep 7 :: a x1
[9] __primitive.dep 5 :: a x1
[10] __primitive.ap 9 2 -> 11 :: v? x1
[11] __primitive.dep 10 :: a x1
[12] __primitive.ap 11 8 1 -> 13 :: v? x1
[13] __primitive.dep 12 :: a x1
[14] return [13]

___ control.dip11 (3 -> 2) ___
[1] var :: ?l x1
[2] var :: ?a x1
[3] var :: ?a x1
[4] __primitive.ap 3 1 -> 5 :: v? x1
[5] __primitive.dep 4 :: a x1
[6] return [5 2]

___ control.dip12 (3 -> 3) ___
[1] var :: ?l x1
[2] var :: ?a x1
[3] var :: ?a x1
[4] __primitive.ap 3 1 -> 6 5 :: v? x2
[5] __primitive.dep 4 :: a x1
[6] __primitive.dep 4 :: a x1
[7] return [6 5 2]

___ control.dip13 (3 -> 4) ___
[1] var :: ?l x1
[2] var :: ?a x1
[3] var :: ?a x1
[4] __primitive.ap 3 1 -> 8 7 6 :: v? x3
[6] __primitive.dep 4 :: a x1
[7] __primitive.dep 4 :: a x1
[8] __primitive.dep 4 :: a x1
[9] return [8 7 6 2]

___ control.dip14 (3 -> 5) ___
[1] var :: ?l x1
[2] var :: ?a x1
[3] var :: ?a x1
[4] __primitive.ap 3 1 -> 9 8 7 6 :: v? x4
[6] __primitive.dep 4 :: a x1
[7] __primitive.dep 4 :: a x1
[8] __primitive.dep 4 :: a x1
[9] __primitive.dep 4 :: a x1
[10] return [9 8 7 6 2]

___ control.dip15 (3 -> 6) ___
[1] var :: ?l x1
[2] var :: ?a x1
[3] var :: ?a x1
[4] __primitive.ap 3 1 -> 10 9 8 7 6 :: v? x5
[6] __primitive.dep 4 :: a x1
[7] __primitive.dep 4 :: a x1
[8] __primitive.dep 4 :: a x1
[9] __primitive.dep 4 :: a x1
[10] __primitive.dep 4 :: a x1
[11] return [10 9 8 7 6 2]

___ control.dip16 (3 -> 7) ___
[1] var :: ?l x1
[2] var :: ?a x1
[3] var :: ?a x1
[4] __primitive.ap 3 1 -> 11 10 9 8 7 6 :: v? x6
[6] __primitive.dep 4 :: a x1
[7] __primitive.dep 4 :: a x1
[8] __primitive.dep 4 :: a x1
[9] __primitive.dep 4 :: a x1
[10] __primitive.dep 4 :: a x1
[11] __primitive.dep 4 :: a x1
[12] return [11 10 9 8 7 6 2]

___ control.dip21 (4 -> 2) ___
[1] var :: ?l x1
[2] var :: ?a x1
[3] var :: ?a x1
[4] var :: ?a x1
[5] __primitive.ap 4 3 1 -> 6 :: v? x1
[6] __primitive.dep 5 :: a x1
[7] return [6 2]

___ control.dip22 (4 -> 3) ___
[1] var :: ?l x1
[2] var :: ?a x1
[3] var :: ?a x1
[4] var :: ?a x1
[5] __primitive.ap 4 3 1 -> 8 7 :: v? x2
[7] __primitive.dep 5 :: a x1
[8] __primitive.dep 5 :: a x1
[9] return [8 7 2]

___ control.dip23 (4 -> 4) ___
[1] var :: ?l x1
[2] var :: ?a x1
[3] var :: ?a x1
[4] var :: ?a x1
[5] __primitive.ap 4 3 1 -> 9 8 7 :: v? x3
[7] __primitive.dep 5 :: a x1
[8] __primitive.dep 5 :: a x1
[9] __primitive.dep 5 :: a x1
[10] return [9 8 7 2]

___ control.dip24 (4 -> 5) ___
[1] var :: ?l x1
[2] var :: ?a x1
[3] var :: ?a x1
[4] var :: ?a x1
[5] __primitive.ap 4 3 1 -> 10 9 8 7 :: v? x4
[7] __primitive.dep 5 :: a x1
[8] __primitive.dep 5 :: a x1
[9] __primitive.dep 5 :: a x1
[10] __primitive.dep 5 :: a x1
[11] return [10 9 8 7 2]

___ control.dip25 (4 -> 6) ___
[1] var :: ?l x1
[2] var :: ?a x1
[3] var :: ?a x1
[4] var :: ?a x1
[5] __primitive.ap 4 3 1 -> 11 10 9 8 7 :: v? x5
[7] __primitive.dep 5 :: a x1
[8] __primitive.dep 5 :: a x1
[9] __primitive.dep 5 :: a x1
[10] __primitive.dep 5 :: a x1
[11] __primitive.dep 5 :: a x1
[12] return [11 10 9 8 7 2]

___ control.dip26 (4 -> 7) ___
[1] var :: ?l x1
[2] var :: ?a x1
[3] var :: ?a x1
[4] var :: ?a x1
[5] __primitive.ap 4 3 1 -> 12 11 10 9 8 7 :: v? x6
[7] __primitive.dep 5 :: a x1
[8] __primitive.dep 5 :: a x1
[9] __primitive.dep 5 :: a x1
[10] __primitive.dep 5 :: a x1
[11] __primitive.dep 5 :: a x1
[12] __primitive.dep 5 :: a x1
[13] return [12 11 10 9 8 7 2]

___ control.dip31 (5 -> 2) ___
[1] var :: ?l x1
[2] var :: ?a x1
[3] var :: ?a x1
[4] var :: ?a x1
[5] var :: ?a x1
[6] __primitive.ap 5 4 3 1 -> 8 :: v? x1
[8] __primitive.dep 6 :: a x1
[9] return [8 2]

___ control.dip32 (5 -> 3) ___
[1] var :: ?l x1
[2] var :: ?a x1
[3] var :: ?a x1
[4] var :: ?a x1
[5] var :: ?a x1
[6] __primitive.ap 5 4 3 1 -> 9 8 :: v? x2
[8] __primitive.dep 6 :: a x1
[9] __primitive.dep 6 :: a x1
[10] return [9 8 2]

___ control.dip33 (5 -> 4) ___
[1] var :: ?l x1
[2] var :: ?a x1
[3] var :: ?a x1
[4] var :: ?a x1
[5] var :: ?a x1
[6] __primitive.ap 5 4 3 1 -> 10 9 8 :: v? x3
[8] __primitive.dep 6 :: a x1
[9] __primitive.dep 6 :: a x1
[10] __primitive.dep 6 :: a x1
[11] return [10 9 8 2]

___ control.dip34 (5 -> 5) ___
[1] var :: ?l x1
[2] var :: ?a x1
[3] var :: ?a x1
[4] var :: ?a x1
[5] var :: ?a x1
[6] __primitive.ap 5 4 3 1 -> 11 10 9 8 :: v? x4
[8] __primitive.dep 6 :: a x1
[9] __primitive.dep 6 :: a x1
[10] __primitive.dep 6 :: a x1
[11] __primitive.dep 6 :: a x1
[12] return [11 10 9 8 2]

___ control.dip35 (5 -> 6) ___
[1] var :: ?l x1
[2] var :: ?a x1
[3] var :: ?a x1
[4] var :: ?a x1
[5] var :: ?a x1
[6] __primitive.ap 5 4 3 1 -> 12 11 10 9 8 :: v? x5
[8] __primitive.dep 6 :: a x1
[9] __primitive.dep 6 :: a x1
[10] __primitive.dep 6 :: a x1
[11] __primitive.dep 6 :: a x1
[12] __primitive.dep 6 :: a x1
[13] return [12 11 10 9 8 2]

___ control.dip36 (5 -> 7) ___
[1] var :: ?l x1
[2] var :: ?a x1
[3] var :: ?a x1
[4] var :: ?a x1
[5] var :: ?a x1
[6] __primitive.ap 5 4 3 1 -> 13 12 11 10 9 8 :: v? x6
[8] __primitive.dep 6 :: a x1
[9] __primitive.dep 6 :: a x1
[10] __primitive.dep 6 :: a x1
[11] __primitive.dep 6 :: a x1
[12] __primitive.dep 6 :: a x1
[13] __primitive.dep 6 :: a x1
[14] return [13 12 11 10 9 8 2]

___ control.dip41 (6 -> 2) ___
[1] var :: ?l x1
[2] var :: ?a x1
[3] var :: ?a x1
[4] var :: ?a x1
[5] var :: ?a x1
[6] var :: ?a x1
[7] __primitive.ap 6 5 4 3 1 -> 9 :: v? x1
[9] __primitive.dep 7 :: a x1
[10] return [9 2]

___ control.dip42 (6 -> 3) ___
[1] var :: ?l x1
[2] var :: ?a x1
[3] var :: ?a x1
[4] var :: ?a x1
[5] var :: ?a x1
[6] var :: ?a x1
[7] __primitive.ap 6 5 4 3 1 -> 10 9 :: v? x2
[9] __primitive.dep 7 :: a x1
[10] __primitive.dep 7 :: a x1
[11] return [10 9 2]

___ control.dip43 (6 -> 4) ___
[1] var :: ?l x1
[2] var :: ?a x1
[3] var :: ?a x1
[4] var :: ?a x1
[5] var :: ?a x1
[6] var :: ?a x1
[7] __primitive.ap 6 5 4 3 1 -> 11 10 9 :: v? x3
[9] __primitive.dep 7 :: a x1
[10] __primitive.dep 7 :: a x1
[11] __primitive.dep 7 :: a x1
[12] return [11 10 9 2]

___ control.dip44 (6 -> 5) ___
[1] var :: ?l x1
[2] var :: ?a x1
[3] var :: ?a x1
[4] var :: ?a x1
[5] var :: ?a x1
[6] var :: ?a x1
[7] __primitive.ap 6 5 4 3 1 -> 12 11 10 9 :: v? x4
[9] __primitive.dep 7 :: a x1
[10] __primitive.dep 7 :: a x1
[11] __primitive.dep 7 :: a x1
[12] __primitive.dep 7 :: a x1
[13] return [12 11 10 9 2]

___ control.dip45 (6 -> 6) ___
[1] var :: ?l x1
[2] var :: ?a x1
[3] var :: ?a x1
[4] var :: ?a x1
[5] var :: ?a x1
[6] var :: ?a x1
[7] __primitive.ap 6 5 4 3 1 -> 13 12 11 10 9 :: v? x5
[9] __primitive.dep 7 :: a x1
[10] __primitive.dep 7 :: a x1
[11] __primitive.dep 7 :: a x1
[12] __primitive.dep 7 :: a x1
[13] __primitive.dep 7 :: a x1
[14] return [13 12 11 10 9 2]

___ control.dip46 (6 -> 7) ___
[1] var :: ?l x1
[2] var :: ?a x1
[3] var :: ?a x1
[4] var :: ?a x1
[5] var :: ?a x1
[6] var :: ?a x1
[7] __primitive.ap 6 5 4 3 1 -> 14 13 12 11 10 9 :: v? x6
[9] __primitive.dep 7 :: a x1
[10] __primitive.dep 7 :: a x1
[11] __primitive.dep 7 :: a x1
[12] __primitive.dep 7 :: a x1
[13] __primitive.dep 7 :: a x1
[14] __primitive.dep 7 :: a x1
[15] return [14 13 12 11 10 9 2]

___ control.dip51 (7 -> 2) ___
[1] var :: ?l x1
[2] var :: ?a x1
[3] var :: ?a x1
[4] var :: ?a x1
[5] var :: ?a x1
[6] var :: ?a x1
[7] var :: ?a x1
[8] __primitive.ap 7 6 5 4 3 1 -> 10 :: v? x1
[10] __primitive.dep 8 :: a x1
[11] return [10 2]

___ control.dip52 (7 -> 3) ___
[1] var :: ?l x1
[2] var :: ?a x1
[3] var :: ?a x1
[4] var :: ?a x1
[5] var :: ?a x1
[6] var :: ?a x1
[7] var :: ?a x1
[8] __primitive.ap 7 6 5 4 3 1 -> 11 10 :: v? x2
[10] __primitive.dep 8 :: a x1
[11] __primitive.dep 8 :: a x1
[12] return [11 10 2]

___ control.dip53 (7 -> 4) ___
[1] var :: ?l x1
[2] var :: ?a x1
[3] var :: ?a x1
[4] var :: ?a x1
[5] var :: ?a x1
[6] var :: ?a x1
[7] var :: ?a x1
[8] __primitive.ap 7 6 5 4 3 1 -> 12 11 10 :: v? x3
[10] __primitive.dep 8 :: a x1
[11] __primitive.dep 8 :: a x1
[12] __primitive.dep 8 :: a x1
[13] return [12 11 10 2]

___ control.dip54 (7 -> 5) ___
[1] var :: ?l x1
[2] var :: ?a x1
[3] var :: ?a x1
[4] var :: ?a x1
[5] var :: ?a x1
[6] var :: ?a x1
[7] var :: ?a x1
[8] __primitive.ap 7 6 5 4 3 1 -> 13 12 11 10 :: v? x4
[10] __primitive.dep 8 :: a x1
[11] __primitive.dep 8 :: a x1
[12] __primitive.dep 8 :: a x1
[13] __primitive.dep 8 :: a x1
[14] return [13 12 11 10 2]

___ control.dip55 (7 -> 6) ___
[1] var :: ?l x1
[2] var :: ?a x1
[3] var :: ?a x1
[4] var :: ?a x1
[5] var :: ?a x1
[6] var :: ?a x1
[7] var :: ?a x1
[8] __primitive.ap 7 6 5 4 3 1 -> 14 13 12 11 10 :: v? x5
[10] __primitive.dep 8 :: a x1
[11] __primitive.dep 8 :: a x1
[12] __primitive.dep 8 :: a x1
[13] __primitive.dep 8 :: a x1
[14] __primitive.dep 8 :: a x1
[15] return [14 13 12 11 10 2]

___ control.dip56 (7 -> 7) ___
[1] var :: ?l x1
[2] var :: ?a x1
[3] var :: ?a x1
[4] var :: ?a x1
[5] var :: ?a x1
[6] var :: ?a x1
[7] var :: ?a x1
[8] __primitive.ap 7 6 5 4 3 1 -> 15 14 13 12 11 10 :: v? x6
[10] __primitive.dep 8 :: a x1
[11] __primitive.dep 8 :: a x1
[12] __primitive.dep 8 :: a x1
[13] __primitive.dep 8 :: a x1
[14] __primitive.dep 8 :: a x1
[15] __primitive.dep 8 :: a x1
[16] return [15 14 13 12 11 10 2]

___ control.dip61 (8 -> 2) ___
[1] var :: ?l x1
[2] var :: ?a x1
[3] var :: ?a x1
[4] var :: ?a x1
[5] var :: ?a x1
[6] var :: ?a x1
[7] var :: ?a x1
[8] var :: ?a x1
[9] __primitive.ap 8 7 6 5 4 3 1 -> 11 :: v? x1
[11] __primitive.dep 9 :: a x1
[12] return [11 2]

___ control.dip62 (8 -> 3) ___
[1] var :: ?l x1
[2] var :: ?a x1
[3] var :: ?a x1
[4] var :: ?a x1
[5] var :: ?a x1
[6] var :: ?a x1
[7] var :: ?a x1
[8] var :: ?a x1
[9] __primitive.ap 8 7 6 5 4 3 1 -> 12 11 :: v? x2
[11] __primitive.dep 9 :: a x1
[12] __primitive.dep 9 :: a x1
[13] return [12 11 2]

___ control.dip63 (8 -> 4) ___
[1] var :: ?l x1
[2] var :: ?a x1
[3] var :: ?a x1
[4] var :: ?a x1
[5] var :: ?a x1
[6] var :: ?a x1
[7] var :: ?a x1
[8] var :: ?a x1
[9] __primitive.ap 8 7 6 5 4 3 1 -> 13 12 11 :: v? x3
[11] __primitive.dep 9 :: a x1
[12] __primitive.dep 9 :: a x1
[13] __primitive.dep 9 :: a x1
[14] return [13 12 11 2]

___ control.dip64 (8 -> 5) ___
[1] var :: ?l x1
[2] var :: ?a x1
[3] var :: ?a x1
[4] var :: ?a x1
[5] var :: ?a x1
[6] var :: ?a x1
[7] var :: ?a x1
[8] var :: ?a x1
[9] __primitive.ap 8 7 6 5 4 3 1 -> 14 13 12 11 :: v? x4
[11] __primitive.dep 9 :: a x1
[12] __primitive.dep 9 :: a x1
[13] __primitive.dep 9 :: a x1
[14] __primitive.dep 9 :: a x1
[15] return [14 13 12 11 2]

___ control.dip65 (8 -> 6) ___
[1] var :: ?l x1
[2] var :: ?a x1
[3] var :: ?a x1
[4] var :: ?a x1
[5] var :: ?a x1
[6] var :: ?a x1
[7] var :: ?a x1
[8] var :: ?a x1
[9] __primitive.ap 8 7 6 5 4 3 1 -> 15 14 13 12 11 :: v? x5
[11] __primitive.dep 9 :: a x1
[12] __primitive.dep 9 :: a x1
[13] __primitive.dep 9 :: a x1
[14] __primitive.dep 9 :: a x1
[15] __primitive.dep 9 :: a x1
[16] return [15 14 13 12 11 2]

___ control.dip66 (8 -> 7) ___
[1] var :: ?l x1
[2] var :: ?a x1
[3] var :: ?a x1
[4] var :: ?a x1
[5] var :: ?a x1
[6] var :: ?a x1
[7] var :: ?a x1
[8] var :: ?a x1
[9] __primitive.ap 8 7 6 5 4 3 1 -> 16 15 14 13 12 11 :: v? x6
[11] __primitive.dep 9 :: a x1
[12] __primitive.dep 9 :: a x1
[13] __primitive.dep 9 :: a x1
[14] __primitive.dep 9 :: a x1
[15] __primitive.dep 9 :: a x1
[16] __primitive.dep 9 :: a x1
[17] return [16 15 14 13 12 11 2]

___ control.either (3 -> 1) x2 ___
[1] var :: ?l x1
[2] var :: ?l x1
[3] var :: ?l x2
[4] __primitive.ap &3 -> 9 5 :: v? x2
[5] __primitive.dep 4 :: y x1
[6] __primitive.eq_s 5 7 :: y x1
[7] val Right :: y x1
[8] __primitive.assert 9 6 :: a? x1
[9] __primitive.dep 4 :: a x1
[10] __primitive.ap 8 1 -> 11 :: v? x1
[11] __primitive.dep 10 :: a x1
[12] return [11] -> 21
[13] __primitive.ap 3 -> 18 14 :: v? x2
[14] __primitive.dep 13 :: y x1
[15] __primitive.eq_s 14 16 :: y x1
[16] val Left :: y x1
[17] __primitive.assert 18 15 :: a? x1
[18] __primitive.dep 13 :: a x1
[19] __primitive.ap 17 2 -> 20 :: v? x1
[20] __primitive.dep 19 :: a x1
[21] return [20]

___ control.fork (3 -> 2) ___
[1] var :: ?l x1
[2] var :: ?l x1
[3] var :: ?a x2
[4] __primitive.ap &3 1 -> 5 :: v? x1
[5] __primitive.dep 4 :: a x1
[6] __primitive.ap 3 2 -> 7 :: v? x1
[7] __primitive.dep 6 :: a x1
[8] return [7 5]

___ control.fork3 (4 -> 3) ___
[1] var :: ?l x1
[2] var :: ?l x1
[3] var :: ?l x1
[4] var :: ?a x3
[5] __primitive.ap &4 1 -> 6 :: v? x1
[6] __primitive.dep 5 :: a x1
[7] __primitive.ap &4 2 -> 8 :: v? x1
[8] __primitive.dep 7 :: a x1
[9] __primitive.ap 4 3 -> 10 :: v? x1
[10] __primitive.dep 9 :: a x1
[11] return [10 8 6]

___ control.fork_cmp (3 -> 2) row ___
[1] var :: ?l x1
[2] var :: ?l x1
[3] var :: ?l x2
[4] __primitive.compose &3 2 :: l x1
[5] __primitive.compose 3 1 :: l x1
[6] return [4 5]

___ control.fork_cmp3 (4 -> 3) row ___
[1] var :: ?l x1
[2] var :: ?l x1
[3] var :: ?l x1
[4] var :: ?l x3
[5] __primitive.compose &4 3 :: l x1
[6] __primitive.compose &4 1 :: l x1
[7] __primitive.compose 4 2 :: l x1
[8] return [5 7 6]

___ control.gather (1 -> 2) ___
[1] var :: ?l x1
[2] list.reverse:foldr:iterate &3 1 :: l x1
[3] [] :: l x3
[4] jump control.gather_r:foldr:iterate &3 3 2 -> 6 :: l x2
[6] __primitive.dep 4 :: l x1
[7] return [4 6]

___ control.gather1 (3 -> 2) row ___
[1] var :: ?l x1
[2] var :: ?l x1
[3] var :: ?l x1
[4] __primitive.compose 2 1 -> 5 :: l? x2
[5] __primitive.dep 4 :: a x1
[6] __primitive.pushr 3 5 :: l x1
[7] return [6 4]

___ control.gather_r (1 -> 2) ___
[1] var :: ?l x1
[2] [] :: l x2
[3] jump control.gather_r:foldr:iterate &2 2 1 -> 5 :: l x2
[5] __primitive.dep 3 :: a x1
[6] return [3 5]

___ control.gather_r:foldr:iterate (3 -> 2) x2 rec ___
[1] changing var :: ?l x1
[2] changing var :: ?l x2
[3] changing var :: ?l x2
[4] __primitive.ap 1 -> 5 :: l? x2
[5] __primitive.dep 4 :: l x5
[6] __primitive.seq 12 &5 :: v x1
[7] __primitive.compose &3 &5 -> 8 :: l? x2
[8] __primitive.dep 7 :: a x1
[9] __primitive.pushr 2 8 :: l x1
[10] jump control.gather_r:foldr:iterate 7 9 4 -> 12 :: v x2
[12] __primitive.dep 10 :: v x1
[13] __primitive.seq 10 5 :: v x1
[14] return [13 6] -> 17
[15] __primitive.unless 2 &5 :: l x1
[16] __primitive.unless 3 5 :: l x1
[17] return [15 16]

___ control.if (3 -> 1) ___
[1] var :: ?l x1
[2] var :: ?l x1
[3] var :: ?a x2
[4] __primitive.ap &3 2 -> 5 :: v? x1
[5] __primitive.dep 4 :: y x1
[6] __primitive.assert 8 5 :: a? x1
[7] __primitive.ap 3 1 -> 8 :: v? x1
[8] __primitive.dep 7 :: a x1
[9] return [6]

___ control.ifdo (2 -> 1) x2 ___
[1] var :: ?l x2
[2] var :: ?a x3
[3] __primitive.ap &2 &1 -> 6 4 :: v? x2
[4] __primitive.dep 3 :: y x1
[5] __primitive.assert 6 4 :: a? x1
[6] __primitive.dep 3 :: a x1
[7] return [5] -> 14
[8] __primitive.ap &2 2 1 -> 10 X 11 :: v? x2
[10] __primitive.dep 8 :: a x1
[11] __primitive.dep 8 :: y x1
[12] __primitive.not 11 :: y x1
[13] __primitive.assert 10 12 :: a? x1
[14] return [13]

___ control.ifte (3 -> 1) x2 ___
[1] var :: ?a x1
[2] var :: ?a x1
[3] var :: ?y x2
[4] __primitive.not &3 :: y x1
[5] __primitive.assert 1 4 :: a? x1
[6] return [5] -> 8
[7] __primitive.assert 2 3 :: a? x1
[8] return [7]

___ control.in2 (2 -> 3) ___
[1] var :: ?a x2
[2] var :: ?a x2
[3] __primitive.quote &2 &1 :: l x1
[4] return [2 1 3]

___ control.in3 (3 -> 4) ___
[1] var :: ?a x2
[2] var :: ?a x2
[3] var :: ?a x2
[4] __primitive.quote &3 &2 &1 :: l x1
[5] return [3 2 1 4]

___ control.iterate (3 -> 1) x2 rec ___
[1] var :: ?l x3
[2] var :: ?l x2
[3] changing var :: ?a x4
[4] __primitive.ap &3 &1 -> 5 :: v? x1
[5] __primitive.dep 4 :: y x1
[6] __primitive.ap &3 &1 -> 7 :: v? x1
[7] __primitive.dep 6 :: y x1
[8] __primitive.not 7 :: y x1
[9] __primitive.assert &3 8 :: a? x1
[10] return [9] -> 15
[11] __primitive.assert 14 5 :: a? x1
[12] __primitive.ap 3 &2 -> 13 :: v? x1
[13] __primitive.dep 12 :: a x1
[14] jump control.iterate 13 2 1 :: a x1
[15] return [11]

___ control.maybe (3 -> 1) x2 ___
[1] var :: ?a x2
[2] var :: ?a x2
[3] var :: ?l x2
[4] __primitive.ap &1 &2 &3 -> 6 19 15 :: v? x3
[6] __primitive.dep 4 :: l x1
[7] __primitive.ap 1 2 3 -> 13 X 9 :: v? x2
[9] __primitive.dep 7 :: y x1
[10] __primitive.eq_s 9 11 :: y x1
[11] val Nothing :: y x1
[12] __primitive.assert 13 10 :: a? x1
[13] __primitive.dep 7 :: a x1
[14] return [12] -> 22
[15] __primitive.dep 4 :: y x1
[16] __primitive.eq_s 15 17 :: y x1
[17] val Just :: y x1
[18] __primitive.assert 19 16 :: a? x1
[19] __primitive.dep 4 :: a x1
[20] __primitive.ap 18 6 -> 21 :: v? x1
[21] __primitive.dep 20 :: a x1
[22] return [21]

___ control.para (4 -> 2) ___
[1] var :: ?l x1
[2] var :: ?l x1
[3] var :: ?a x1
[4] var :: ?a x1
[5] __primitive.ap 3 1 -> 6 :: v? x1
[6] __primitive.dep 5 :: a x1
[7] __primitive.ap 4 2 -> 8 :: v? x1
[8] __primitive.dep 7 :: a x1
[9] return [8 6]

___ control.peek (2 -> 2) ___
[1] var :: ?l x1
[2] var :: ?a x2
[3] __primitive.ap &2 1 -> 4 :: v? x1
[4] __primitive.dep 3 :: a x1
[5] return [2 4]

___ control.peek_cmp (2 -> 2) row ___
[1] var :: ?l x1
[2] var :: ?l x2
[3] __primitive.compose &2 1 :: l x1
[4] return [2 3]

___ control.scatter (2 -> 1) ___
[1] var :: ?l x1
[2] var :: ?l x1
[3] [] :: l x1
[4] jump control.scatter:foldr:iterate 3 1 2 :: l x1
[5] return [4]

___ control.scatter:foldr:iterate (3 -> 1) x2 rec row ___
[1] var :: ?l x2
[2] changing var :: ?l x1
[3] changing var :: ?l x2
[4] __primitive.ap 2 -> 5 :: l? x2
[5] __primitive.dep 4 :: l x3
[6] __primitive.seq 9 &5 :: v x1
[7] __primitive.compose 8 3 :: l x1
[8] __primitive.compose &1 5 :: l x1
[9] jump control.scatter:foldr:iterate 7 4 1 :: v x1
[10] return [6] -> 12
[11] __primitive.unless 3 5 :: l x1
[12] return [11]

___ control.scatter1 (3 -> 1) row ___
[1] var :: ?l x1
[2] var :: ?l x1
[3] var :: ?l x1
[4] __primitive.compose 5 2 :: l x1
[5] __primitive.compose 1 3 :: l x1
[6] return [4]

___ control.seq2 (3 -> 2) ___
[1] var :: ?a x2
[2] var :: ?a x1
[3] var :: ?a x1
[4] __primitive.seq 2 &1 :: a x1
[5] __primitive.seq 3 1 :: a x1
[6] return [5 4]

___ control.times (3 -> 1) ___
[1] var :: ?i x1
[2] var :: ?l x1
[3] var :: ?a x1
[4] jump control.times:iterate 1 2 3 :: a x1
[5] return [4]

___ control.times:iterate (3 -> 1) x2 rec ___
[1] changing var :: ?a x2
[2] var :: ?l x2
[3] changing var :: ?i x2
[4] __primitive.gt &3 5 :: y x2
[5] val 0 :: i x1
[6] __primitive.not &4 :: y x1
[7] __primitive.assert &1 6 :: a? x1
[8] return [7] -> 15
[9] __primitive.assert 14 4 :: a? x1
[10] __primitive.sub 3 11 :: i x1
[11] val 1 :: i x1
[12] __primitive.ap 1 &2 -> 13 :: v? x1
[13] __primitive.dep 12 :: a x1
[14] jump control.times:iterate 10 2 13 :: a x1
[15] return [9]

___ control.times_step (3 -> 3) ___
[1] var :: ?i x1
[2] var :: ?l x2
[3] var :: ?a x1
[4] __primitive.sub 1 5 :: i x1
[5] val 1 :: i x1
[6] __primitive.ap 3 &2 -> 7 :: v? x1
[7] __primitive.dep 6 :: a x1
[8] return [7 2 4]

___ control.while (2 -> 1) x2 rec ___
[1] var :: ?l x2
[2] changing var :: ?a x2
[3] __primitive.ap &2 &1 -> 4 :: v? x1
[4] __primitive.dep 3 :: a x3
[5] __primitive.seq 6 &4 :: v x1
[6] jump control.while 4 1 :: v x1
[7] return [5] -> 9
[8] __primitive.unless 2 4 :: a x1
[9] return [8]

___ control.with2 (3 -> 3) ___
[1] var :: ?l x1
[2] var :: ?a x1
[3] var :: ?a x1
[4] __primitive.ap 3 1 -> 6 5 :: v? x2
[5] __primitive.dep 4 :: a x1
[6] __primitive.dep 4 :: a x1
[7] return [6 2 5]

___ control.with3 (4 -> 4) ___
[1] var :: ?l x1
[2] var :: ?a x1
[3] var :: ?a x1
[4] var :: ?a x1
[5] __primitive.ap 4 1 -> 7 6 :: v? x2
[6] __primitive.dep 5 :: a x1
[7] __primitive.dep 5 :: a x1
[8] return [7 3 2 6]

___ control.with4 (5 -> 5) ___
[1] var :: ?l x1
[2] var :: ?a x1
[3] var :: ?a x1
[4] var :: ?a x1
[5] var :: ?a x1
[6] __primitive.ap 5 1 -> 8 7 :: v? x2
[7] __primitive.dep 6 :: a x1
[8] __primitive.dep 6 :: a x1
[9] return [8 4 3 2 7]

___ control.with5 (6 -> 6) ___
[1] var :: ?l x1
[2] var :: ?a x1
[3] var :: ?a x1
[4] var :: ?a x1
[5] var :: ?a x1
[6] var :: ?a x1
[7] __primitive.ap 6 1 -> 9 8 :: v? x2
[8] __primitive.dep 7 :: a x1
[9] __primitive.dep 7 :: a x1
[10] return [9 5 4 3 2 8]

___ control.with6 (7 -> 7) ___
[1] var :: ?l x1
[2] var :: ?a x1
[3] var :: ?a x1
[4] var :: ?a x1
[5] var :: ?a x1
[6] var :: ?a x1
[7] var :: ?a x1
[8] __primitive.ap 7 1 -> 10 9 :: v? x2
[9] __primitive.dep 8 :: a x1
[10] __primitive.dep 8 :: a x1
[11] return [10 6 5 4 3 2 9]

___ gen_ed.count_lines (2 -> 3) ___
[1] var is File :: ?o x1
[2] var :: ?y x1
[3] val 0 :: i x1
[4] jump gen_ed.count_lines:iterate_linear 3 1 2 -> 7 6 :: y x3
[6] __primitive.dep 4 :: a x1
[7] __primitive.dep 4 :: a x1
[8] return [4 7 6]

___ gen_ed.count_lines:iterate_linear (3 -> 3) x2 rec ___
[1] changing var :: ?y x1
[2] changing var is File :: ?o x1
[3] changing var :: ?i x2
[4] __primitive.read 1 2 -> 12 5 :: y x3
[5] __primitive.dep 4 :: s x2
[6] __primitive.eq_str &5 &7 :: y x1
[7] val "" :: s x2
[8] __primitive.not 6 :: y x4
[9] __primitive.not &8 :: y x3
[10] __primitive.assert &3 &9 :: i? x1
[11] __primitive.assert &14 &9 is File :: o? x1
[12] __primitive.dep 4 is File :: o x1.
[13] __primitive.unread 4 12 5 -> 14 :: y x3.
[14] __primitive.dep 13 is File :: o x2.
[15] __primitive.assert &13 9 :: y? x1
[16] return [15 11 10] -> 30
[18] __primitive.assert 24 &8 :: y? x1
[19] __primitive.add 3 20 :: i x1
[20] val 1 :: i x1
[21] io.getline_loop 13 14 7 -> 23 X :: y x2
[23] __primitive.dep 21 is File :: o x1
[24] jump gen_ed.count_lines:iterate_linear 19 23 21 -> 27 29 :: y x3
[26] __primitive.assert 27 &8 is File :: o? x1
[27] __primitive.dep 24 is File :: o x1
[28] __primitive.assert 29 8 :: i? x1
[29] __primitive.dep 24 :: i x1
[30] return [18 26 28]

___ gen_ed.count_lines_test (1 -> 1) ___
[1] var :: ?y x1
[2] __primitive.open 1 3 -> 4 :: y x2
[3] val "stream,in:std" :: s x1
[4] __primitive.dep 2 is File :: o x1
[5] io.getline_loop 2 4 7 -> 8 10 :: y x3
[7] val "" :: s x1
[8] __primitive.dep 5 is File :: o x1
[9] __primitive.close 5 8 :: y x1
[10] __primitive.dep 5 :: s x1
[11] __primitive.strcat 12 10 :: s x1
[12] val "in:" :: s x1
[13] __primitive.open 9 11 -> 14 :: y x2
[14] __primitive.dep 13 is File :: o x1
[15] gen_ed.count_lines:iterate_linear 17 14 13 -> 18 23 :: y x3
[17] val 0 :: i x1
[18] __primitive.dep 15 is File :: o x1
[19] __primitive.close 15 18 :: y x1
[20] __primitive.open 19 21 -> 22 :: y x2
[21] val "stream,out:std" :: s x1
[22] __primitive.dep 20 is File :: o x1
[23] __primitive.dep 15 :: i x1
[24] __primitive.to_string 23 :: s x1
[25] __primitive.write 20 22 24 -> 26 :: y x2
[26] __primitive.dep 25 is File :: o x1
[27] __primitive.close 25 26 :: y x1
[28] return [27]

___ gen_ed.dl_test (1 -> 1) ___
[1] var :: ?i x1
[2] __primitive.add 1 3 :: i x1
[3] val 3 :: i x1
[4] jump gen_ed.dl_test:iterate_linear 2 :: i x1
[5] return [4]

___ gen_ed.dl_test:iterate_linear (1 -> 1) x2 rec ___
[1] changing var :: ?i x3
[2] __primitive.lt &1 3 :: y x2
[3] val 10 :: i x1
[4] __primitive.not &2 :: y x1
[5] __primitive.assert &1 4 :: i? x1
[6] return [5] -> 11
[7] __primitive.assert 10 2 :: i? x1
[8] __primitive.add 1 9 :: i x1
[9] val 3 :: i x1
[10] jump gen_ed.dl_test:iterate_linear 8 :: i x1
[11] return [7]

___ gen_ed.dl_test2 (1 -> 1) ___
[1] var :: ?i x1
[2] __primitive.add 1 3 :: i x1
[3] val 3 :: i x1
[4] jump gen_ed.dl_test2:iterate_linear 2 :: i x1
[5] return [4]

___ gen_ed.dl_test2:iterate_linear (1 -> 1) x2 rec ___
[1] changing var :: ?i x3
[2] __primitive.lt &1 3 :: y x2
[3] val 10 :: i x1
[4] __primitive.not &2 :: y x1
[5] __primitive.assert &1 4 :: i? x1
[6] return [5] -> 11
[7] __primitive.assert 10 2 :: i? x1
[8] __primitive.add 1 9 :: i x1
[9] val 3 :: i x1
[10] jump gen_ed.dl_test2:iterate_linear 8 :: i x1
[11] return [7]

___ gen_ed.do_linear (3 -> 1) ___
[1] var :: ?l x1
[2] var :: ?l x2
[3] var :: ?a x1
[4] __primitive.ap 3 &2 -> 5 :: v? x1
[5] __primitive.dep 4 :: a x1
[6] jump gen_ed.iterate_linear 5 2 1 :: a x1
[7] return [6]

___ gen_ed.dupu (2 -> 3) ___
[1] var :: ?a x1
[2] var :: ?a x2
[3] return [&2 2 1]

___ gen_ed.il_test (1 -> 1) ___
[1] var :: ?i x1
[2] jump gen_ed.il_test:iterate_linear 1 :: i x1
[3] return [2]

___ gen_ed.il_test:iterate_linear (1 -> 1) x2 rec ___
[1] changing var :: ?i x3
[2] __primitive.lt &1 3 :: y x2
[3] val 10 :: i x1
[4] __primitive.not &2 :: y x1
[5] __primitive.assert &1 4 :: i? x1
[6] return [5] -> 11
[7] __primitive.assert 10 2 :: i? x1
[8] __primitive.add 1 9 :: i x1
[9] val 3 :: i x1
[10] jump gen_ed.il_test:iterate_linear 8 :: i x1
[11] return [7]

___ gen_ed.iterate_linear (3 -> 1) x2 rec ___
[1] var :: ?l x2
[2] var :: ?l x2
[3] changing var :: ?a x1
[4] __primitive.ap 3 &1 -> 8 5 :: v? x2
[5] __primitive.dep 4 :: y x2
[6] __primitive.not &5 :: y x1
[7] __primitive.assert &8 6 :: a? x1
[8] __primitive.dep 4 :: a x2.
[9] return [7] -> 14
[10] __primitive.assert 13 5 :: a? x1
[11] __primitive.ap 8 &2 -> 12 :: v? x1
[12] __primitive.dep 11 :: a x1
[13] jump gen_ed.iterate_linear 12 2 1 :: a x1
[14] return [10]

___ gen_ed.read_list (2 -> 3) ___
[1] var is File :: ?o x1
[2] var :: ?y x1
[3] [] :: l x1
[4] jump gen_ed.read_list:iterate_linear 3 1 2 -> 7 6 :: y x3
[6] __primitive.dep 4 :: a x1
[7] __primitive.dep 4 :: a x1
[8] return [4 7 6]

___ gen_ed.read_list:iterate_linear (3 -> 3) x2 rec ___
[1] changing var :: ?y x1
[2] changing var is File :: ?o x1
[3] changing var :: ?l x2
[4] __primitive.read 1 2 -> 12 5 :: y x3
[5] __primitive.dep 4 :: s x2
[6] __primitive.eq_str &5 &7 :: y x1
[7] val "" :: s x2
[8] __primitive.not 6 :: y x4
[9] __primitive.not &8 :: y x3
[10] __primitive.assert &3 &9 :: l? x1
[11] __primitive.assert &14 &9 is File :: o? x1
[12] __primitive.dep 4 is File :: o x1.
[13] __primitive.unread 4 12 5 -> 14 :: y x3.
[14] __primitive.dep 13 is File :: o x2.
[15] __primitive.assert &13 9 :: y? x1
[16] return [15 11 10] -> 30
[18] __primitive.assert 24 &8 :: y? x1
[19] io.getline_loop 13 14 7 -> 21 22 :: y x3
[21] __primitive.dep 19 is File :: o x1
[22] __primitive.dep 19 :: s x1
[23] __primitive.ap 22 3 :: l x1
[24] jump gen_ed.read_list:iterate_linear 23 21 19 -> 27 29 :: y x3
[26] __primitive.assert 27 &8 is File :: o? x1
[27] __primitive.dep 24 is File :: o x1
[28] __primitive.assert 29 8 :: l? x1
[29] __primitive.dep 24 :: l x1
[30] return [18 26 28]

___ gen_ed.reverse_list (3 -> 3) ___
[1] var is File :: ?o x1
[2] var is File :: ?o x1
[3] var :: ?y x1
[4] gen_ed.read_list:iterate_linear &6 2 3 -> 12 7 :: y x3
[6] [] :: l x2
[7] __primitive.dep 4 :: l x1
[8] list.reverse:foldr:iterate 6 7 :: l x1
[9] jump gen_ed.write_list:iterate_linear 8 1 4 -> 11 :: y x2
[11] __primitive.dep 9 is File :: o x1
[12] __primitive.dep 4 is File :: o x1
[13] return [9 12 11]

___ gen_ed.sum_lines (2 -> 3) ___
[1] var is File :: ?o x1
[2] var :: ?y x1
[3] val 0 :: i x1
[4] jump gen_ed.sum_lines:iterate_linear 3 1 2 -> 7 6 :: y x3
[6] __primitive.dep 4 :: a x1
[7] __primitive.dep 4 :: a x1
[8] return [4 7 6]

___ gen_ed.sum_lines:iterate_linear (3 -> 3) x2 rec ___
[1] changing var :: ?y x1
[2] changing var is File :: ?o x1
[3] changing var :: ?i x2
[4] __primitive.read 1 2 -> 12 5 :: y x3
[5] __primitive.dep 4 :: s x2
[6] __primitive.eq_str &5 &7 :: y x1
[7] val "" :: s x2
[8] __primitive.not 6 :: y x4
[9] __primitive.not &8 :: y x3
[10] __primitive.assert &3 &9 :: i? x1
[11] __primitive.assert &14 &9 is File :: o? x1
[12] __primitive.dep 4 is File :: o x1.
[13] __primitive.unread 4 12 5 -> 14 :: y x3.
[14] __primitive.dep 13 is File :: o x2.
[15] __primitive.assert &13 9 :: y? x1
[16] return [15 11 10] -> 31
[18] __primitive.assert 25 &8 :: y? x1
[19] io.getline_loop 13 14 7 -> 24 21 :: y x3
[21] __primitive.dep 19 :: s x1
[22] __primitive.from_string 21 :: i? x1
[23] __primitive.add 22 3 :: i x1
[24] __primitive.dep 19 is File :: o x1
[25] jump gen_ed.sum_lines:iterate_linear 23 24 19 -> 28 30 :: y x3
[27] __primitive.assert 28 &8 is File :: o? x1
[28] __primitive.dep 25 is File :: o x1
[29] __primitive.assert 30 8 :: i? x1
[30] __primitive.dep 25 :: i x1
[31] return [18 27 29]

___ gen_ed.sum_lines_test (1 -> 1) ___
[1] var :: ?y x1
[2] __primitive.open 1 3 -> 4 :: y x2
[3] val "stream,in:std" :: s x1
[4] __primitive.dep 2 is File :: o x1
[5] io.getline_loop 2 4 7 -> 8 10 :: y x3
[7] val "" :: s x1
[8] __primitive.dep 5 is File :: o x1
[9] __primitive.close 5 8 :: y x1
[10] __primitive.dep 5 :: s x1
[11] __primitive.strcat 12 10 :: s x1
[12] val "in:" :: s x1
[13] __primitive.open 9 11 -> 14 :: y x2
[14] __primitive.dep 13 is File :: o x1
[15] gen_ed.sum_lines:iterate_linear 17 14 13 -> 18 23 :: y x3
[17] val 0 :: i x1
[18] __primitive.dep 15 is File :: o x1
[19] __primitive.close 15 18 :: y x1
[20] __primitive.open 19 21 -> 22 :: y x2
[21] val "stream,out:std" :: s x1
[22] __primitive.dep 20 is File :: o x1
[23] __primitive.dep 15 :: i x1
[24] __primitive.to_string 23 :: s x1
[25] __primitive.write 20 22 24 -> 26 :: y x2
[26] __primitive.dep 25 is File :: o x1
[27] __primitive.close 25 26 :: y x1
[28] return [27]

___ gen_ed.write_list (3 -> 2) ___
[1] var :: ?l x1
[2] var is File :: ?o x1
[3] var :: ?y x1
[4] jump gen_ed.write_list:iterate_linear 1 2 3 -> 6 :: y x2
[6] __primitive.dep 4 :: a x1
[7] return [4 6]

___ gen_ed.write_list:iterate_linear (3 -> 2) x2 rec ___
[1] changing var :: ?y x2
[2] changing var is File :: ?o x2
[3] changing var :: ?l x1
[4] __primitive.ap 3 -> 5 :: l? x2
[5] __primitive.dep 4 :: s x5
[6] __primitive.seq 14 &5 :: v x1
[7] __primitive.write &1 &2 &5 -> 8 :: y x2
[8] __primitive.dep 7 is File :: o x1
[9] __primitive.write 7 8 10 -> 11 :: y x2
[10] val "\n" :: s x1
[11] __primitive.dep 9 is File :: o x1
[12] jump gen_ed.write_list:iterate_linear 4 11 9 -> 14 :: v x2
[14] __primitive.dep 12 :: v x1
[15] __primitive.unless 2 &5 is File :: o x1
[16] __primitive.unless 1 5 :: y x1
[17] return [16 15] -> 19
[18] __primitive.seq 12 5 :: v x1
[19] return [18 6]

___ io.getline (2 -> 3) ___
[1] var is File :: ?o x1
[2] var :: ?y x1
[3] jump io.getline_loop 2 1 5 -> 7 6 :: y x3
[5] val "" :: s x1
[6] __primitive.dep 3 :: s x1
[7] __primitive.dep 3 is File :: o x1
[8] return [3 7 6]

___ io.getline_loop (3 -> 3) x3 rec ___
[1] changing var :: ?s x3
[2] changing var is File :: ?o x1
[3] changing var :: ?y x1
[4] __primitive.read 3 2 -> 8 5 :: y x5
[5] __primitive.dep 4 :: s x3
[6] __primitive.strsplit &5 7 -> 9 :: s? x8
[7] val "\n" :: s x1
[8] __primitive.dep 4 is File :: o x3.
[9] __primitive.dep 6 :: s x1
[10] __primitive.strcat 1 9 :: s x1
[11] __primitive.unread 4 8 10 -> 12 :: y x2
[12] __primitive.dep 11 is File :: o x1
[13] return [11 12 6] -> 40
[15] __primitive.unless 19 &6 :: y x1
[16] __primitive.eq_str &5 17 :: y x6
[17] val "" :: s x1
[18] __primitive.not &16 :: y x6
[19] __primitive.assert 21 &18 :: y? x1
[20] __primitive.strcat &1 5 :: s x1
[21] jump io.getline_loop &4 &8 20 -> 28 35 :: y x3
[23] __primitive.assert 25 &18 :: y? x1
[24] __primitive.unless 23 &6 :: y x1
[25] __primitive.assert 4 &16 :: y? x1
[26] __primitive.assert 27 &16 is File :: o? x1
[27] __primitive.assert 28 &18 is File :: o? x1
[28] __primitive.dep 21 is File :: o x1
[29] __primitive.unless 26 &6 is File :: o x1
[30] __primitive.assert 31 &18 is File :: o? x1
[31] __primitive.assert 8 &16 is File :: o? x1
[32] __primitive.unless 30 &6 is File :: o x1
[33] __primitive.assert 34 &16 :: s? x1
[34] __primitive.assert 35 &18 :: s? x1
[35] __primitive.dep 21 :: s x1
[36] __primitive.unless 33 &6 :: s x1
[37] __primitive.assert 38 18 :: s? x1
[38] __primitive.assert 1 16 :: s? x1
[39] __primitive.unless 37 6 :: s x1
[40] return [15 29 36] -> 42
[42] return [24 32 39]

___ io.getline_std (1 -> 2) ___
[1] var :: ?y x1
[2] __primitive.open 1 3 -> 4 :: y x2
[3] val "stream,in:std" :: s x1
[4] __primitive.dep 2 is File :: o x1
[5] io.getline_loop 2 4 7 -> 9 8 :: y x3
[7] val "" :: s x1
[8] __primitive.dep 5 :: s x1
[9] __primitive.dep 5 is File :: o x1
[10] __primitive.close 5 9 :: y x1
[11] return [10 8]

___ io.is_eof (2 -> 3) ___
[1] var is File :: ?o x1
[2] var :: ?y x1
[3] __primitive.read 2 1 -> 7 4 :: y x3
[4] __primitive.dep 3 :: s x2
[5] __primitive.eq_str &4 6 :: y x1
[6] val "" :: s x1
[7] __primitive.dep 3 is File :: o x1
[8] __primitive.unread 3 7 4 -> 9 :: y x2
[9] __primitive.dep 8 is File :: o x1
[10] return [8 9 5]

___ io.read_std (1 -> 2) ___
[1] var :: ?y x1
[2] __primitive.open 1 3 -> 4 :: y x2
[3] val "stream,in:std" :: s x1
[4] __primitive.dep 2 is File :: o x1
[5] __primitive.read 2 4 -> 7 6 :: y x3
[6] __primitive.dep 5 :: s x1
[7] __primitive.dep 5 is File :: o x1
[8] __primitive.close 5 7 :: y x1
[9] return [8 6]

___ io.stream_modify_array (3 -> 1) ___
[1] var :: ?l x1
[2] var :: ?l x1
[3] var is Array :: ?o x1
[4] jump io.stream_modify_array:map_with 2 3 1 :: l x1
[5] return [4]

___ io.stream_modify_array:map_with (3 -> 1) rec row ___
[1] var :: ?l x2
[2] changing var is Array :: ?o x1
[3] changing var :: ?l x1
[4] __primitive.ap 3 -> 5 :: l? x2
[5] __primitive.dep 4 :: i x2
[6] __primitive.read_array 2 &5 -> 7 is Array :: o x2
[7] __primitive.dep 6 :: i x1
[8] __primitive.ap 7 &1 -> 9 :: v? x1
[9] __primitive.dep 8 :: i x1
[10] __primitive.write_array 6 5 9 is Array :: o x2
[11] __primitive.seq 14 &10 is True :: y x1
[12] jump io.stream_modify_array:map_with 4 10 1 :: l x1
[13] __primitive.pushr 12 11 :: l x1
[14] val True :: y x1
[15] return [13]

___ io.stream_modify_array1 (3 -> 1) ___
[1] var :: ?l x1
[2] var :: ?i x2
[3] var is Array :: ?o x1
[4] __primitive.read_array 3 &2 -> 5 is Array :: o x2
[5] __primitive.dep 4 :: i x1
[6] __primitive.ap 5 1 -> 7 :: v? x1
[7] __primitive.dep 6 :: i x1
[8] __primitive.write_array 4 2 7 is Array :: o x1
[9] return [8]

___ io.stream_read_array (1 -> 1) ___
[1] var :: ?l x1
[2] jump io.stream_read_array:map 1 :: l x1
[3] return [2]

___ io.stream_read_array:map (1 -> 1) rec row ___
[1] changing var :: ?l x1
[2] __primitive.ap 1 -> 3 :: l? x2
[3] __primitive.dep 2 :: i x2
[4] __primitive.seq 7 &3 :: l x1
[5] io.stream_read_array:map 2 :: l x1
[6] __primitive.pushr 5 4 :: l x1
[7] jump io.stream_read_array:map:quote 3 :: l x1
[8] return [6]

___ io.stream_read_array:map:quote (2 -> 1) ___
[1] var :: ?i x1
[2] var is Array :: ?o x1
[3] __primitive.read_array 2 1 -> 7 is Array :: o x2
[4] __primitive.ap 3 5 &6 :: l x1
[5] __primitive.quote 8 6 :: l x1
[6] [] :: l x2
[7] __primitive.dep 3 :: a x1
[8] __primitive.quote 7 :: l x1
[9] return [4]

___ io.stream_read_write_array (4 -> 2) ___
[1] var :: ?l x1
[2] var :: ?l x1
[3] var :: ?l x1
[4] var is Array :: ?o x1
[5] io.stream_read_write_array_1:map_with 3 2 1 4 4b :: l x2
[7] list.unzip_either:map &5 :: l x1
[8] jump list.unzip_either:map_1 5 :: l x1
[9] return [8 7]

___ io.stream_read_write_array_1 (4 -> 1) ___
[1] var :: ?l x1
[2] var :: ?l x1
[3] var :: ?l x1
[4] var is Array :: ?o x1
[5] jump io.stream_read_write_array_1:map_with 3 2 1 4 4b :: l x1
[7] return [5]

___ io.stream_read_write_array_1:map_with (4 -> 1) x2 rec row ___
[1] changing var is Array :: ?o x2
[2] changing var :: ?l x1
[3] changing var :: ?l x1
[4] var :: ?l x3
[5] __primitive.ap 3 -> 6 :: l? x3
[6] __primitive.dep 5 :: i x2
[7] __primitive.ap 2 -> 8 :: l? x3
[8] __primitive.dep 7 :: i x2
[9] __primitive.seq 10 &6 3b :: l x1
[10] __primitive.seq 16 &8 3b :: l x1
[11] __primitive.write_array 1 6 8 is Array :: o x2
[12] io.stream_read_write_array_1:map_with 4 5 7 &11 :: l x1
[14] __primitive.pushr 12 9 3b :: l x1
[15] __primitive.seq 18 11 is True :: y x1
[16] __primitive.quote 15 17 3b :: l x1
[17] val Right :: y x1
[18] val True :: y x1
[19] return [14] -> 30
[20] __primitive.ap &4 -> 21 :: v? x1
[21] __primitive.dep 20 :: i x2
[22] __primitive.seq 28 &21 4b :: l x1
[23] __primitive.read_array 1 21 -> 27 is Array :: o x2
[24] io.stream_read_write_array_1:map_with 4 5 7 23 :: l x1
[26] __primitive.pushr 24 22 4b :: l x1
[27] __primitive.dep 23 :: i x1
[28] __primitive.quote 27 29 4b :: l x1
[29] val Left :: y x1
[30] return [26]

___ io.stream_write_array (2 -> 1) ___
[1] var :: ?l x1
[2] var :: ?l x1
[3] jump io.stream_write_array:zip 2 1 :: l x1
[4] return [3]

___ io.stream_write_array:zip (2 -> 1) rec row ___
[1] changing var :: ?l x1
[2] changing var :: ?l x1
[3] __primitive.ap 2 -> 4 :: l? x2
[4] __primitive.dep 3 :: i x4
[5] __primitive.ap 1 -> 6 :: l? x2
[6] __primitive.dep 5 :: i x4
[7] __primitive.seq 8 &4 :: l x1
[8] __primitive.seq 13 &6 :: l x1
[9] __primitive.seq 10 &4 :: l x1
[10] __primitive.seq 11 &6 :: l x1
[11] io.stream_write_array:zip 3 5 :: l x1
[12] __primitive.pushr 9 7 :: l x1
[13] jump io.stream_write_array:zip:quote &6 &4 :: l x1
[14] __primitive.seq 12 6 :: l x1
[15] __primitive.seq 14 4 :: l x1
[16] return [15]

___ io.stream_write_array:zip:quote (3 -> 1) ___
[1] var :: ?i x1
[2] var :: ?i x1
[3] var is Array :: ?o x1
[4] __primitive.write_array 3 1 2 is Array :: o x2
[5] __primitive.ap &4 6 &10 :: l x1
[6] __primitive.quote 10 8 :: l x1
[7] __primitive.seq 9 4 is True :: y x1
[8] __primitive.quote 7 :: l x1
[9] val True :: y x1
[10] [] :: l x2
[11] return [5]

___ io.unread_std (2 -> 1) ___
[1] var :: ?s x1
[2] var :: ?y x1
[3] __primitive.open 2 4 -> 5 :: y x2
[4] val "stream,in:std" :: s x1
[5] __primitive.dep 3 is File :: o x1
[6] __primitive.unread 3 5 1 -> 7 :: y x2
[7] __primitive.dep 6 is File :: o x1
[8] __primitive.close 6 7 :: y x1
[9] return [8]

___ io.update_array (3 -> 1) ___
[1] var :: ?l x1
[2] var :: ?i x2
[3] var is Array :: ?o x1
[4] __primitive.read_array 3 &2 -> 5 is Array :: o x2
[5] __primitive.dep 4 :: i x1
[6] __primitive.ap 5 1 -> 7 :: v? x1
[7] __primitive.dep 6 :: i x1
[8] __primitive.write_array 4 2 7 is Array :: o x1
[9] return [8]

___ io.write_std (2 -> 1) ___
[1] var :: ?s x1
[2] var :: ?y x1
[3] __primitive.open 2 4 -> 5 :: y x2
[4] val "stream,out:std" :: s x1
[5] __primitive.dep 3 is File :: o x1
[6] __primitive.write 3 5 1 -> 7 :: y x2
[7] __primitive.dep 6 is File :: o x1
[8] __primitive.close 6 7 :: y x1
[9] return [8]

___ list.$top (2 -> 3) ___
[1] var :: ?l x2
[2] var :: ?l x2
[3] __primitive.compose &2 &1 -> 4 :: v? x1
[4] __primitive.dep 3 :: a x1
[5] return [2 1 4]

___ list.@ (2 -> 1) ___
[1] var :: ?i x1
[2] var :: ?l x1
[3] list.dropl:iterate 1 2 :: l x1
[4] __primitive.ap 3 -> 5 :: v? x1
[5] __primitive.dep 4 :: a x1
[6] return [5]

___ list.assoc (2 -> 1) x2 rec ___
[1] var :: ?s x2
[2] changing var :: ?l x1
[3] __primitive.ap 2 -> 4 :: l? x2
[4] __primitive.dep 3 :: l x1
[5] __primitive.ap 4 -> 9 6 :: v? x2
[6] __primitive.dep 5 :: s x1
[7] __primitive.eq_str 6 &1 :: y x2
[8] __primitive.assert 9 &7 :: a? x1
[9] __primitive.dep 5 :: a x1
[10] return [8] -> 14
[11] __primitive.not 7 :: y x1
[12] __primitive.assert 13 11 :: a? x1
[13] jump list.assoc 3 1 :: a x1
[14] return [12]

___ list.assoc_step (2 -> 3) ___
[1] var :: ?s x1
[2] var :: ?l x1
[3] __primitive.ap 2 -> 4 :: l? x2
[4] __primitive.dep 3 :: l x1
[5] __primitive.ap 4 -> 8 6 :: v? x2
[6] __primitive.dep 5 :: s x1
[7] __primitive.eq_str 6 1 :: y x1
[8] __primitive.dep 5 :: a x1
[9] return [3 8 7]

___ list.concat (1 -> 1) ___
[1] var :: ?l x1
[2] [] :: l x1
[3] jump list.concat:foldr:iterate 2 1 :: l x1
[4] return [3]

___ list.concat:foldr:iterate (2 -> 1) x2 rec row ___
[1] changing var :: ?l x1
[2] changing var :: ?l x2
[3] __primitive.ap 1 -> 4 :: l? x2
[4] __primitive.dep 3 :: l x3
[5] __primitive.seq 7 &4 :: v x1
[6] __primitive.compose 4 2 :: l x1
[7] jump list.concat:foldr:iterate 6 3 :: v x1
[8] return [5] -> 10
[9] __primitive.unless 2 4 :: l x1
[10] return [9]

___ list.dropl (2 -> 1) ___
[1] var :: ?i x1
[2] var :: ?l x1
[3] jump list.dropl:iterate 1 2 :: l x1
[4] return [3]

___ list.dropl:iterate (2 -> 1) x2 rec ___
[1] changing var :: ?l x2
[2] changing var :: ?i x2
[3] __primitive.gt &2 4 :: y x2
[4] val 0 :: i x1
[5] __primitive.not &3 :: y x1
[6] __primitive.assert &1 5 :: l? x1
[7] return [6] -> 13
[8] __primitive.assert 12 3 :: l? x1
[9] __primitive.sub 2 10 :: i x1
[10] val 1 :: i x1
[11] __primitive.ap 1 -> X :: l? x1
[12] jump list.dropl:iterate 9 11 :: l x1
[13] return [8]

___ list.either_push (4 -> 2) x2 row ___
[1] var :: ?y x2
[2] var :: ?a x2
[3] var :: ?l x2
[4] var :: ?l x2
[5] __primitive.eq_s &1 6 :: y x4
[6] val Left :: y x1
[7] __primitive.assert &3 &5 :: l? x1
[8] __primitive.assert &2 &5 :: a? x1
[9] __primitive.assert &4 &5 :: l? x1
[10] __primitive.pushr 9 8 :: l x1
[11] __primitive.assert 10 5 :: l? x1
[12] return [11 7] -> 20
[13] __primitive.eq_s 1 14 :: y x4
[14] val Right :: y x1
[15] __primitive.assert 2 &13 :: a? x1
[16] __primitive.assert 4 &13 :: l? x1
[17] __primitive.assert 3 &13 :: l? x1
[18] __primitive.pushr 17 15 :: l x1
[19] __primitive.assert 18 13 :: l? x1
[20] return [16 19]

___ list.filter (2 -> 1) rec row ___
[1] var :: ?l x2
[2] changing var :: ?l x1
[3] list.next_match 2 &1 -> 4 :: l x2
[4] __primitive.dep 3 :: a x1
[5] jump list.filter 3 1 :: l x1
[6] __primitive.pushr 5 4 :: l x1
[7] return [6]

___ list.filter2 (2 -> 1) x2 rec row ___
[1] var :: ?l x2
[2] changing var :: ?l x1
[3] __primitive.ap 2 -> 4 :: l? x2
[4] __primitive.dep 3 :: a x2
[5] __primitive.ap &4 &1 -> 6 :: v? x1
[6] __primitive.dep 5 :: y x4
[7] __primitive.assert 4 &6 :: a? x1
[8] jump list.filter2 3 1 :: l x2.
[9] __primitive.assert &8 &6 :: l? x1
[10] __primitive.pushr 9 7 :: l x1
[11] __primitive.assert 10 &6 :: l? x1
[12] return [11] -> 15
[13] __primitive.not 6 :: y x1
[14] __primitive.assert 8 13 :: l? x1
[15] return [14]

___ list.foldl (3 -> 1) ___
[1] var :: ?l x1
[2] var :: ?a x1
[3] var :: ?l x1
[4] [] :: l x1
[5] list.foldl:iterate 4 3 1 :: l x1
[6] __primitive.ap 2 5 -> 7 :: v? x1
[7] __primitive.dep 6 :: a x1
[8] return [7]

___ list.foldl:iterate (3 -> 1) x2 rec row ___
[1] var :: ?l x2
[2] changing var :: ?l x1
[3] changing var :: ?l x2
[4] __primitive.ap 2 -> 5 :: l? x2
[5] __primitive.dep 4 :: a x3
[6] __primitive.seq 9 &5 :: v x1
[7] __primitive.ap 5 &1 :: l x1
[8] __primitive.compose 7 3 :: l x1
[9] jump list.foldl:iterate 8 4 1 :: v x1
[10] return [6] -> 12
[11] __primitive.unless 3 5 :: l x1
[12] return [11]

___ list.foldl_step (3 -> 3) row ___
[1] var :: ?l x1
[2] var :: ?l x1
[3] var :: ?l x2
[4] __primitive.ap 2 -> 5 :: l? x2
[5] __primitive.dep 4 :: a x1
[6] __primitive.ap 5 &3 :: l x1
[7] __primitive.compose 6 1 :: l x1
[8] return [3 4 7]

___ list.foldr (3 -> 1) ___
[1] var :: ?l x1
[2] var :: ?a x1
[3] var :: ?l x1
[4] jump list.foldr:iterate 2 3 1 :: a x1
[5] return [4]

___ list.foldr:iterate (3 -> 1) x2 rec ___
[1] var :: ?l x2
[2] changing var :: ?l x1
[3] changing var :: ?a x2
[4] __primitive.ap 2 -> 5 :: l? x2
[5] __primitive.dep 4 :: a x3
[6] __primitive.seq 9 &5 :: v x1
[7] __primitive.ap &5 &3 &1 -> 8 :: v? x1
[8] __primitive.dep 7 :: a x1
[9] jump list.foldr:iterate 8 4 1 :: v x1
[10] return [6] -> 12
[11] __primitive.unless 3 5 :: a x1
[12] return [11]

___ list.foldr:iterate (3 -> 1) x2 rec ___
[1] var :: ?l x2
[2] changing var :: ?l x1
[3] changing var :: ?a x2
[4] __primitive.ap 2 -> 5 :: l? x2
[5] __primitive.dep 4 :: a x3
[6] __primitive.seq 9 &5 :: v x1
[7] __primitive.ap &5 &3 &1 -> 8 :: v? x1
[8] __primitive.dep 7 :: a x1
[9] jump list.foldr:iterate 8 4 1 :: v x1
[10] return [6] -> 12
[11] __primitive.unless 3 5 :: a x1
[12] return [11]

___ list.foldr_step (3 -> 3) ___
[1] var :: ?a x1
[2] var :: ?l x1
[3] var :: ?l x2
[4] __primitive.ap 2 -> 5 :: l? x2
[5] __primitive.dep 4 :: a x1
[6] __primitive.ap 5 1 &3 -> 7 :: v? x1
[7] __primitive.dep 6 :: a x1
[8] return [3 4 7]

___ list.half_rem (1 -> 2) ___
[1] var :: ?i x2
[2] __primitive.div &1 3 :: i? x2
[3] val 2 :: i x1
[4] __primitive.sub 1 &2 :: i x1
[5] return [4 2]

___ list.head (1 -> 1) ___
[1] var :: ?l x1
[2] __primitive.ap 1 -> 3 :: v? x1
[3] __primitive.dep 2 :: a x1
[4] return [3]

___ list.interleave (2 -> 1) x2 rec row ___
[1] changing var :: ?l x2
[2] changing var :: ?l x2
[3] __primitive.ap &1 -> 4 :: l? x2
[4] __primitive.dep 3 :: a x1
[5] jump list.interleave 2 3 :: l x1
[6] __primitive.pushr 5 4 :: l x1
[7] return [6] -> 12
[8] __primitive.ap 2 -> 10 :: l? x2
[9] jump list.interleave 8 1 :: l x1
[10] __primitive.dep 8 :: a x1
[11] __primitive.pushr 9 10 :: l x1
[12] return [11]

___ list.interleave_apply_left (4 -> 3) row ___
[1] var :: ?l x1
[2] var :: ?a x3
[3] var :: ?a x1
[4] var :: ?l x1
[5] __primitive.seq 7 &2 :: a x1
[6] __primitive.ap &2 1 -> 7 9 :: v? x2
[7] __primitive.dep 6 :: a x1
[8] __primitive.seq 9 2 :: a x1
[9] __primitive.dep 6 :: a x1
[10] __primitive.pushr 4 8 :: l x1
[11] return [10 3 5]

___ list.interleave_apply_right (3 -> 2) row ___
[1] var :: ?l x1
[2] var :: ?a x3
[3] var :: ?l x1
[4] __primitive.seq 6 &2 :: a x1
[5] __primitive.ap &2 1 -> 6 8 :: v? x2
[6] __primitive.dep 5 :: a x1
[7] __primitive.seq 8 2 :: a x1
[8] __primitive.dep 5 :: a x1
[9] __primitive.pushr 3 7 :: l x1
[10] return [9 4]

___ list.interleave_with (3 -> 1) x2 rec row ___
[1] changing var :: ?a x6
[2] changing var :: ?l x2
[3] changing var :: ?l x2
[4] __primitive.seq 8 &1 :: a x3
[5] __primitive.ap &2 -> 6 :: l? x2
[6] __primitive.dep 5 :: l x1
[7] __primitive.ap &1 6 -> 11 8 :: v? x2
[8] __primitive.dep 7 :: a x1
[9] __primitive.seq 12 &4 :: l x1
[10] __primitive.seq 11 1 :: a x1
[11] __primitive.dep 7 :: a x1
[12] jump list.interleave_with 3 5 10 :: l x1
[13] __primitive.pushr 9 &4 :: l x1
[14] __primitive.seq 13 4 :: l x1
[15] return [14] -> 27
[16] __primitive.seq 20 &1 :: a x1
[17] __primitive.ap 3 -> 18 :: l? x2
[18] __primitive.dep 17 :: l x1
[19] __primitive.ap &1 18 -> 20 23 :: v? x2
[20] __primitive.dep 19 :: a x1
[21] jump list.interleave_with 17 2 16 :: l x1
[22] __primitive.seq 23 1 :: a x3
[23] __primitive.dep 19 :: a x1
[24] __primitive.seq 21 &22 :: l x1
[25] __primitive.pushr 24 &22 :: l x1
[26] __primitive.seq 25 22 :: l x1
[27] return [26]

___ list.interleave_with2 (3 -> 1) ___
[1] var :: ?a x1
[2] var :: ?l x1
[3] var :: ?l x1
[4] [] :: l x1
[5] jump list.interleave_with2:foldr:iterate 4 3 2 1 :: l x1
[7] return [5]

___ list.interleave_with2:foldr:iterate (4 -> 1) x3 rec row ___
[1] changing var :: ?a x8
[2] changing var :: ?l x1
[3] var :: ?l x3
[4] changing var :: ?l x3
[5] __primitive.seq 8 &1 :: l x3
[6] __primitive.ap 2 -> 7 :: l? x3
[7] __primitive.dep 6 :: l x6
[8] __primitive.seq 12 &7 :: l x1
[9] __primitive.ap &1 &7 -> 20 11 13 :: v? x3
[11] __primitive.dep 9 :: a x6
[12] __primitive.seq 15 &11 :: l x1
[13] __primitive.dep 9 :: l x1
[14] __primitive.ap &11 13 -> 15 23 :: v? x2
[15] __primitive.dep 14 :: l x1
[16] __primitive.seq 30 &5 :: v x1
[17] __primitive.seq 20 &11 :: l x1.
[18] __primitive.seq 17 &7 :: l x1.
[19] __primitive.seq 18 &1 :: l x2.
[20] __primitive.dep 9 :: l x1.
[21] __primitive.compose 4 5 :: l x1
[22] __primitive.seq 23 &11 :: a x1
[23] __primitive.dep 14 :: a x1
[24] __primitive.seq 22 &7 :: a x1
[25] __primitive.seq 24 &1 :: a x2
[26] __primitive.pushr 19 25 :: l x1
[27] __primitive.seq 26 11 :: l x1
[28] __primitive.seq 27 7 :: l x1
[29] __primitive.seq 28 1 :: l x1
[30] jump list.interleave_with2:foldr:iterate 21 3 6 29 :: v x1
[32] return [16] -> 47
[33] __primitive.seq 36 &1 :: l x3
[34] __primitive.ap &3 -> 35 :: v? x1
[35] __primitive.dep 34 :: l x2
[36] __primitive.seq 38 &35 :: l x1
[37] __primitive.ap &1 35 -> X 38 :: v? x1
[38] __primitive.dep 37 :: l x1
[39] __primitive.seq 45 &33 :: v x1
[40] __primitive.compose 4 33 :: l x1
[41] __primitive.pushr 19 25 :: l x1
[42] __primitive.seq 41 11 :: l x1
[43] __primitive.seq 42 7 :: l x1
[44] __primitive.seq 43 1 :: l x1
[45] jump list.interleave_with2:foldr:iterate 40 3 6 44 :: v x1
[47] return [39] -> 50
[48] __primitive.unless 4 5 :: l x1
[49] __primitive.unless 48 33 :: l x1
[50] return [49]

___ list.iteratel (2 -> 1) rec row ___
[1] var :: ?l x2
[2] changing var :: ?a x2
[3] __primitive.ap &2 &1 -> 4 :: v? x1
[4] __primitive.dep 3 :: a x1
[5] jump list.iteratel 4 1 :: l x1
[6] __primitive.pushr 5 2 :: l x1
[7] return [6]

___ list.itercat (2 -> 1) row ___
[1] var :: ?l x1
[2] var :: ?a x2
[3] jump list.itercat_loop &2 1 :: l x1
[4] __primitive.pushr 3 2 :: l x1
[5] return [4]

___ list.itercat_loop (2 -> 1) rec row ___
[1] var :: ?l x2
[2] changing var :: ?a x1
[3] __primitive.ap 2 &1 :: l x2
[4] __primitive.ap &3 -> 5 :: v? x1
[5] __primitive.dep 4 :: a x1
[6] jump list.itercat_loop 5 1 :: l x1
[7] __primitive.compose 6 3 :: l x1
[8] return [7]

___ list.length (1 -> 1) ___
[1] var :: ?l x1
[2] val 0 :: i x1
[3] jump list.length:iterate 1 2 :: i x1
[4] return [3]

___ list.length:iterate (2 -> 1) x2 rec ___
[1] changing var :: ?i x2
[2] changing var :: ?l x1
[3] __primitive.ap 2 -> 4 :: l? x2
[4] __primitive.dep 3 :: a x2
[5] __primitive.seq 8 4 :: v x1
[6] __primitive.add 1 7 :: i x1
[7] val 1 :: i x1
[8] jump list.length:iterate 3 6 :: v x1
[9] return [5] -> 11
[10] __primitive.unless 1 4 :: i x1
[11] return [10]

___ list.length:iterate (2 -> 1) x2 rec ___
[1] changing var :: ?i x2
[2] changing var :: ?l x1
[3] __primitive.ap 2 -> 4 :: l? x2
[4] __primitive.dep 3 :: a x2
[5] __primitive.seq 8 4 :: v x1
[6] __primitive.add 1 7 :: i x1
[7] val 1 :: i x1
[8] jump list.length:iterate 3 6 :: v x1
[9] return [5] -> 11
[10] __primitive.unless 1 4 :: i x1
[11] return [10]

___ list.listdup (2 -> 1) ___
[1] var :: ?l x1
[2] var :: ?i x1
[3] [] :: l x1
[4] jump list.listdup:times:iterate 2 1 3 :: l x1
[5] return [4]

___ list.listdup:times:iterate (3 -> 1) x2 rec ___
[1] changing var :: ?l x2
[2] var :: ?l x2
[3] changing var :: ?i x2
[4] __primitive.gt &3 5 :: y x2
[5] val 0 :: i x1
[6] __primitive.not &4 :: y x1
[7] __primitive.assert &1 6 :: l? x1
[8] return [7] -> 14
[9] __primitive.assert 13 4 :: l? x1
[10] __primitive.sub 3 11 :: i x1
[11] val 1 :: i x1
[12] __primitive.ap &2 1 :: l x1
[13] jump list.listdup:times:iterate 10 2 12 :: l x1
[14] return [9]

___ list.map (2 -> 1) rec row ___
[1] var :: ?l x2
[2] changing var :: ?l x1
[3] __primitive.ap 2 -> 4 :: l? x2
[4] __primitive.dep 3 :: a x2
[5] __primitive.seq 7 &4 :: a x1
[6] __primitive.ap 4 &1 -> 7 :: l? x2
[7] __primitive.dep 6 :: a x1
[8] jump list.map 3 1 :: l x1
[9] __primitive.pushr 10 5 :: l x1
[10] __primitive.compose 8 6 :: l x1
[11] return [9]

___ list.map_with (3 -> 1) rec row ___
[1] var :: ?l x2
[2] changing var :: ?a x1
[3] changing var :: ?l x1
[4] __primitive.ap 3 -> 5 :: l? x2
[5] __primitive.dep 4 :: a x1
[6] __primitive.ap 2 5 &1 -> 9 8 :: v? x2
[8] __primitive.dep 6 :: a x1
[9] __primitive.dep 6 :: a x1
[10] jump list.map_with 4 9 1 :: l x1
[11] __primitive.pushr 10 8 :: l x1
[12] return [11]

___ list.merge (2 -> 1) ___
[1] var :: ?l x1
[2] var :: ?l x1
[3] jump list.merge_loop 2 1 4 :: l x1
[4] [] :: l x1
[5] return [3]

___ list.merge_loop (3 -> 1) x4 rec row ___
[1] changing var :: ?l x4
[2] changing var :: ?l x5
[3] changing var :: ?l x3
[4] __primitive.ap &3 -> 5 :: l? x2
[5] __primitive.dep 4 :: i x3
[6] __primitive.ap &2 -> 7 :: v? x1
[7] __primitive.dep 6 :: i x1
[8] __primitive.lte &5 7 :: y x4
[9] __primitive.assert 4 &8 :: l? x1
[10] __primitive.assert &2 &8 :: l? x1
[11] __primitive.assert &5 &8 :: i? x2
[12] __primitive.seq 13 &11 :: l x1
[13] __primitive.ap 11 1 :: l x1
[14] jump list.merge_loop 9 10 12 :: v x1
[15] return [14] -> 24
[16] __primitive.not 8 :: y x2
[17] __primitive.assert 19 &16 :: a? x2
[18] __primitive.ap &2 -> 19 :: l? x2
[19] __primitive.dep 18 :: a x1
[20] __primitive.seq 22 &17 :: l x1
[21] __primitive.assert &3 16 :: l? x1
[22] __primitive.ap 17 1 :: l x1
[23] jump list.merge_loop 21 18 20 :: v x1
[24] return [23] -> 27
[25] __primitive.unless 26 5 :: l x1
[26] __primitive.compose 2 1 :: l x1
[27] return [25] -> 34
[28] __primitive.ap 2 -> 29 :: v? x1
[29] __primitive.dep 28 :: a x3
[30] __primitive.unless 1 &29 :: l x1
[31] __primitive.unless 3 &29 :: l x1
[32] __primitive.compose 31 30 :: l x1
[33] __primitive.unless 32 29 :: l x1
[34] return [33]

___ list.merge_step (3 -> 3) x2 ___
[1] var :: ?l x2
[2] var :: ?l x3
[3] var :: ?l x2
[4] __primitive.ap &3 -> 5 :: l? x2
[5] __primitive.dep 4 :: i x2
[6] __primitive.ap &2 -> 7 :: v? x1
[7] __primitive.dep 6 :: i x1
[8] __primitive.lte &5 7 :: y x4
[9] __primitive.assert 5 &8 :: i? x2
[10] __primitive.seq 13 &9 :: l x1
[11] __primitive.assert &2 &8 :: l? x1
[12] __primitive.assert 4 &8 :: l? x1
[13] __primitive.ap 9 1 :: l x1
[14] return [12 11 10] -> 23
[16] __primitive.not 8 :: y x2
[17] __primitive.assert 19 &16 :: a? x2
[18] __primitive.ap 2 -> 19 :: l? x2
[19] __primitive.dep 18 :: a x1
[20] __primitive.seq 22 &17 :: l x1
[21] __primitive.assert 3 16 :: l? x1
[22] __primitive.ap 17 1 :: l x1
[23] return [21 18 20]

___ list.movr (2 -> 2) ___
[1] var :: ?l x1
[2] var :: ?l x1
[3] __primitive.ap 2 -> 4 :: l? x2
[4] __primitive.dep 3 :: a x1
[5] __primitive.ap 4 1 :: l x1
[6] return [3 5]

___ list.next_match (2 -> 2) x2 rec ___
[1] var :: ?l x2
[2] changing var :: ?l x3
[3] __primitive.compose &2 &1 -> 4 :: v? x1
[4] __primitive.dep 3 :: y x3
[5] __primitive.assert 7 &4 :: a? x1
[6] __primitive.ap &2 -> 7 :: l? x2
[7] __primitive.dep 6 :: a x1
[8] __primitive.assert 6 &4 :: l? x1
[9] return [8 5] -> 16
[10] __primitive.not 4 :: y x2
[11] __primitive.assert 14 &10 :: a? x1
[12] __primitive.ap 2 -> X :: l? x1
[13] jump list.next_match 12 1 -> 14 :: l x2
[14] __primitive.dep 13 :: a x1
[15] __primitive.assert 13 10 :: l? x1
[16] return [15 11]

___ list.pick (2 -> 3) x2 ___
[1] var :: ?l x2
[2] var :: ?l x2
[3] __primitive.ap &1 -> 4 :: l? x2
[4] __primitive.dep 3 :: a x1
[5] return [2 3 4] -> 9
[7] __primitive.ap 2 -> 8 :: l? x2
[8] __primitive.dep 7 :: a x1
[9] return [7 1 8]

___ list.pick_either (2 -> 3) x2 ___
[1] var :: ?l x2
[2] var :: ?l x2
[3] __primitive.ap &1 -> 4 :: l? x2
[4] __primitive.dep 3 :: a x1
[5] __primitive.quote 4 6 3b :: l x1
[6] val Right :: y x1
[7] return [2 3 5] -> 13
[9] __primitive.ap 2 -> 10 :: l? x2
[10] __primitive.dep 9 :: a x1
[11] __primitive.quote 10 12 4b :: l x1
[12] val Left :: y x1
[13] return [9 1 11]

___ list.pop_min (2 -> 3) x2 ___
[1] var :: ?l x3
[2] var :: ?l x2
[3] __primitive.ap &2 -> 4 :: l? x2
[4] __primitive.dep 3 :: i x2
[5] __primitive.ap &1 -> 6 :: v? x1
[6] __primitive.dep 5 :: i x1
[7] __primitive.lte &4 6 :: y x4
[8] __primitive.assert 4 &7 :: i? x1
[9] __primitive.assert &1 &7 :: l? x1
[10] __primitive.assert 3 &7 :: l? x1
[11] return [10 9 8] -> 18
[13] __primitive.not 7 :: y x2
[14] __primitive.assert 2 &13 :: l? x1
[15] __primitive.assert 17 13 :: a? x1
[16] __primitive.ap 1 -> 17 :: l? x2
[17] __primitive.dep 16 :: a x1
[18] return [14 16 15]

___ list.pop_par (2 -> 4) ___
[1] var :: ?l x1
[2] var :: ?l x1
[3] __primitive.ap 1 -> 4 :: l? x2
[4] __primitive.dep 3 :: a x1
[5] __primitive.ap 2 -> 6 :: l? x2
[6] __primitive.dep 5 :: a x1
[7] return [5 3 6 4]

___ list.popr_para (2 -> 4) ___
[1] var :: ?l x1
[2] var :: ?l x1
[3] __primitive.ap 1 -> 4 :: l? x2
[4] __primitive.dep 3 :: a x1
[5] __primitive.ap 2 -> 6 :: l? x2
[6] __primitive.dep 5 :: a x1
[7] return [5 3 6 4]

___ list.pushif (3 -> 1) x2 ___
[1] var :: ?l x1
[2] var :: ?l x2
[3] var :: ?a x2
[4] __primitive.ap &3 1 -> 5 :: v? x1
[5] __primitive.dep 4 :: y x2
[6] __primitive.not &5 :: y x1
[7] __primitive.assert &2 6 :: l? x1
[8] return [7] -> 11
[9] __primitive.assert 10 5 :: l? x1
[10] __primitive.ap 3 2 :: l x1
[11] return [9]

___ list.pushl_seq (2 -> 1) ___
[1] var :: ?l x1
[2] var :: ?a x2
[3] __primitive.seq 4 &2 :: l x1
[4] __primitive.ap 2 1 :: l x1
[5] return [3]

___ list.pushl_seq2 (3 -> 1) ___
[1] var :: ?l x1
[2] var :: ?a x2
[3] var :: ?a x2
[4] __primitive.seq 5 &3 :: l x1
[5] __primitive.seq 6 &2 :: l x1
[6] __primitive.ap 3 2 1 :: l x1
[7] return [4]

___ list.pushq (2 -> 1) ___
[1] var :: ?l x1
[2] var :: ?a x1
[3] __primitive.ap 4 1 :: l x1
[4] __primitive.quote 2 :: l x1
[5] return [3]

___ list.pushq2 (3 -> 1) ___
[1] var :: ?l x1
[2] var :: ?a x1
[3] var :: ?a x1
[4] __primitive.ap 5 1 :: l x1
[5] __primitive.quote 3 2 :: l x1
[6] return [4]

___ list.pushq3 (4 -> 1) ___
[1] var :: ?l x1
[2] var :: ?a x1
[3] var :: ?a x1
[4] var :: ?a x1
[5] __primitive.ap 6 1 :: l x1
[6] __primitive.quote 4 3 2 :: l x1
[7] return [5]

___ list.pushq4 (5 -> 1) ___
[1] var :: ?l x1
[2] var :: ?a x1
[3] var :: ?a x1
[4] var :: ?a x1
[5] var :: ?a x1
[6] __primitive.ap 7 1 :: l x1
[7] __primitive.quote 5 4 3 2 :: l x1
[8] return [6]

___ list.pushq5 (6 -> 1) ___
[1] var :: ?l x1
[2] var :: ?a x1
[3] var :: ?a x1
[4] var :: ?a x1
[5] var :: ?a x1
[6] var :: ?a x1
[7] __primitive.ap 8 1 :: l x1
[8] __primitive.quote 6 5 4 3 2 :: l x1
[10] return [7]

___ list.pushq6 (7 -> 1) ___
[1] var :: ?l x1
[2] var :: ?a x1
[3] var :: ?a x1
[4] var :: ?a x1
[5] var :: ?a x1
[6] var :: ?a x1
[7] var :: ?a x1
[8] __primitive.ap 9 1 :: l x1
[9] __primitive.quote 7 6 5 4 3 2 :: l x1
[11] return [8]

___ list.pushq7 (8 -> 1) ___
[1] var :: ?l x1
[2] var :: ?a x1
[3] var :: ?a x1
[4] var :: ?a x1
[5] var :: ?a x1
[6] var :: ?a x1
[7] var :: ?a x1
[8] var :: ?a x1
[9] __primitive.ap 10 1 :: l x1
[10] __primitive.quote 8 7 6 5 4 3 2 :: l x1
[12] return [9]

___ list.repeat (1 -> 1) rec row ___
[1] var :: ?a x2
[2] jump list.repeat &1 :: l x1
[3] __primitive.pushr 2 1 :: l x1
[4] return [3]

___ list.reverse (1 -> 1) ___
[1] var :: ?l x1
[2] [] :: l x1
[3] jump list.reverse:foldr:iterate 2 1 :: l x1
[4] return [3]

___ list.reverse:foldr:iterate (2 -> 1) x2 rec ___
[1] changing var :: ?l x1
[2] changing var :: ?l x2
[3] __primitive.ap 1 -> 4 :: l? x2
[4] __primitive.dep 3 :: a x3
[5] __primitive.seq 7 &4 :: v x1
[6] __primitive.pushr 2 4 :: l x1
[7] jump list.reverse:foldr:iterate 6 3 :: v x1
[8] return [5] -> 10
[9] __primitive.unless 2 4 :: l x1
[10] return [9]

___ list.reverse:foldr:iterate (2 -> 1) x2 rec ___
[1] changing var :: ?l x1
[2] changing var :: ?l x2
[3] __primitive.ap 1 -> 4 :: l? x2
[4] __primitive.dep 3 :: a x3
[5] __primitive.seq 7 &4 :: v x1
[6] __primitive.pushr 2 4 :: l x1
[7] jump list.reverse:foldr:iterate 6 3 :: v x1
[8] return [5] -> 10
[9] __primitive.unless 2 4 :: l x1
[10] return [9]

___ list.seq_list (1 -> 1) ___
[1] var :: ?l x2
[2] val True :: y x1
[3] jump list.seq_list:foldr:iterate 2 &1 :: y x1
[4] __primitive.seq 1 3 :: l x1
[5] return [4]

___ list.seq_list:foldr:iterate (2 -> 1) x2 rec ___
[1] changing var :: ?l x1
[2] changing var :: ?y x2
[3] __primitive.ap 1 -> 4 :: l? x2
[4] __primitive.dep 3 :: y x3
[5] __primitive.seq 7 &4 :: v x1
[6] __primitive.seq 4 2 :: y x1
[7] jump list.seq_list:foldr:iterate 6 3 :: v x1
[8] return [5] -> 10
[9] __primitive.unless 2 4 :: y x1
[10] return [9]

___ list.sort (1 -> 1) ___
[1] var :: ?l x1
[2] [] :: l x1
[3] jump list.sort:bitree 1 2 :: a x1
[4] return [3]

___ list.sort:bitree (2 -> 1) x2 rec ___
[1] var :: ?l x3
[2] changing var :: ?l x3
[3] list.length:iterate &2 4 :: i x2
[4] val 0 :: i x1
[5] __primitive.div &3 6 :: i? x1
[6] val 2 :: i x1
[7] __primitive.gt 3 8 :: y x2
[8] val 1 :: i x1
[9] __primitive.assert 10 &7 :: l? x1
[10] list.split_at:iterate 5 &12 &2 -> 15 :: l x2
[12] [] :: l x2
[13] list.sort:bitree 9 &1 :: l x1
[14] __primitive.assert 15 7 :: l? x1
[15] __primitive.dep 10 :: l x1
[16] list.sort:bitree 14 1 :: l x1
[17] list.merge_loop 13 16 12 :: l x2
[18] jump list.seq_list:foldr:iterate 19 &17 :: y x1
[19] val True :: y x1
[20] __primitive.seq 17 18 :: l x2
[21] return [20] -> 25
[22] __primitive.unless 24 20 :: a x1
[23] __primitive.ap 2 1 -> 24 :: v? x1
[24] __primitive.dep 23 :: a x1
[25] return [22]

___ list.split_at (2 -> 2) ___
[1] var :: ?i x1
[2] var :: ?l x1
[3] [] :: l x1
[4] jump list.split_at:iterate 1 3 2 -> 6 :: l x2
[6] __primitive.dep 4 :: a x1
[7] return [4 6]

___ list.split_at:iterate (3 -> 2) x2 rec ___
[1] changing var :: ?l x2
[2] changing var :: ?l x2
[3] changing var :: ?i x2
[4] __primitive.gt &3 5 :: y x3
[5] val 0 :: i x1
[6] __primitive.not &4 :: y x2
[7] __primitive.assert &2 &6 :: l? x1
[8] __primitive.assert &1 6 :: l? x1
[9] return [8 7] -> 20
[10] __primitive.assert 16 &4 :: l? x1
[11] __primitive.sub 3 12 :: i x1
[12] val 1 :: i x1
[13] __primitive.ap 1 -> 14 :: l? x2
[14] __primitive.dep 13 :: a x1
[15] __primitive.ap 14 2 :: l x1
[16] jump list.split_at:iterate 11 15 13 -> 19 :: l x2
[18] __primitive.assert 19 4 :: l? x1
[19] __primitive.dep 16 :: l x1
[20] return [10 18]

___ list.split_list (1 -> 3) ___
[1] var :: ?l x2
[2] list.length:iterate &1 3 :: i x2
[3] val 0 :: i x1
[4] __primitive.div &2 5 :: i? x1
[5] val 2 :: i x1
[6] jump list.split_at:iterate 4 8 1 -> 9 :: l x2
[8] [] :: l x1
[9] __primitive.dep 6 :: l x1
[10] return [6 9 2]

___ list.top (1 -> 2) ___
[1] var :: ?l x2
[2] __primitive.ap &1 -> 3 :: v? x1
[3] __primitive.dep 2 :: a x1
[4] return [1 3]

___ list.top_par (2 -> 4) ___
[1] var :: ?l x2
[2] var :: ?l x2
[3] __primitive.ap &1 -> 4 :: v? x1
[4] __primitive.dep 3 :: a x1
[5] __primitive.ap &2 -> 6 :: v? x1
[6] __primitive.dep 5 :: a x1
[7] return [2 1 6 4]

___ list.unzip (1 -> 2) ___
[1] var :: ?l x2
[2] list.unzip:map &1 :: l x1
[3] jump list.unzip:map_1 1 :: l x1
[4] return [3 2]

___ list.unzip:map (1 -> 1) rec row ___
[1] changing var :: ?l x1
[2] __primitive.ap 1 -> 3 :: l? x2
[3] __primitive.dep 2 :: l x2
[4] __primitive.seq 6 &3 :: a x1
[5] __primitive.ap 3 -> 6 :: v? x1
[6] __primitive.dep 5 :: a x1
[7] jump list.unzip:map 2 :: l x1
[8] __primitive.pushr 7 4 :: l x1
[9] return [8]

___ list.unzip:map_1 (1 -> 1) rec row ___
[1] changing var :: ?l x1
[2] __primitive.ap 1 -> 3 :: l? x2
[3] __primitive.dep 2 :: l x2
[4] __primitive.seq 6 &3 :: a x1
[5] __primitive.ap 3 -> 6 X :: v? x1
[6] __primitive.dep 5 :: a x1
[7] jump list.unzip:map_1 2 :: l x1
[8] __primitive.pushr 7 4 :: l x1
[9] return [8]

___ list.unzip_either (1 -> 2) ___
[1] var :: ?l x2
[2] list.unzip_either:map &1 :: l x1
[3] jump list.unzip_either:map_1 1 :: l x1
[4] return [3 2]

___ list.unzip_either:map (1 -> 1) rec row ___
[1] changing var :: ?l x1
[2] list.unzip_either:map:next_match 1 -> 3 :: l x2
[3] __primitive.dep 2 :: l x2
[4] __primitive.seq 6 &3 :: a x1
[5] __primitive.ap 3 -> 6 X :: v? x1
[6] __primitive.dep 5 :: a x1
[7] jump list.unzip_either:map 2 :: l x1
[8] __primitive.pushr 7 4 :: l x1
[9] return [8]

___ list.unzip_either:map:next_match (1 -> 2) x2 rec ___
[1] changing var :: ?l x1
[2] __primitive.ap 1 -> 3 :: l? x3
[3] __primitive.dep 2 :: l x2
[4] __primitive.ap &3 -> 5 :: v? x1
[5] __primitive.dep 4 :: y x1
[6] __primitive.eq_s 5 7 :: y x3
[7] val Right :: y x1
[8] __primitive.assert 3 &6 :: l? x1
[9] __primitive.assert &2 &6 :: l? x1
[10] return [9 8] -> 16
[11] __primitive.not 6 :: y x2
[12] __primitive.assert 14 &11 :: l? x1
[13] jump list.unzip_either:map:next_match 2 -> 14 :: l x2
[14] __primitive.dep 13 :: l x1
[15] __primitive.assert 13 11 :: l? x1
[16] return [15 12]

___ list.unzip_either:map_1 (1 -> 1) rec row ___
[1] changing var :: ?l x1
[2] list.unzip_either:map_1:next_match 1 -> 3 :: l x2
[3] __primitive.dep 2 :: l x2
[4] __primitive.seq 6 &3 :: a x1
[5] __primitive.ap 3 -> 6 X :: v? x1
[6] __primitive.dep 5 :: a x1
[7] jump list.unzip_either:map_1 2 :: l x1
[8] __primitive.pushr 7 4 :: l x1
[9] return [8]

___ list.unzip_either:map_1:next_match (1 -> 2) x2 rec ___
[1] changing var :: ?l x1
[2] __primitive.ap 1 -> 3 :: l? x3
[3] __primitive.dep 2 :: l x2
[4] __primitive.ap &3 -> 5 :: v? x1
[5] __primitive.dep 4 :: y x1
[6] __primitive.eq_s 5 7 :: y x3
[7] val Left :: y x1
[8] __primitive.assert 3 &6 :: l? x1
[9] __primitive.assert &2 &6 :: l? x1
[10] return [9 8] -> 16
[11] __primitive.not 6 :: y x2
[12] __primitive.assert 14 &11 :: l? x1
[13] jump list.unzip_either:map_1:next_match 2 -> 14 :: l x2
[14] __primitive.dep 13 :: l x1
[15] __primitive.assert 13 11 :: l? x1
[16] return [15 12]

___ list.unzip_either:map (1 -> 1) rec row ___
[1] changing var :: ?l x1
[2] list.unzip_either:map:next_match 1 -> 3 :: l x2
[3] __primitive.dep 2 :: l x2
[4] __primitive.seq 6 &3 :: a x1
[5] __primitive.ap 3 -> 6 X :: v? x1
[6] __primitive.dep 5 :: a x1
[7] jump list.unzip_either:map 2 :: l x1
[8] __primitive.pushr 7 4 :: l x1
[9] return [8]

___ list.unzip_either:map:next_match (1 -> 2) x2 rec ___
[1] changing var :: ?l x1
[2] __primitive.ap 1 -> 3 :: l? x3
[3] __primitive.dep 2 :: l x2
[4] __primitive.ap &3 -> 5 :: v? x1
[5] __primitive.dep 4 :: y x1
[6] __primitive.eq_s 5 7 :: y x3
[7] val Right :: y x1
[8] __primitive.assert 3 &6 :: l? x1
[9] __primitive.assert &2 &6 :: l? x1
[10] return [9 8] -> 16
[11] __primitive.not 6 :: y x2
[12] __primitive.assert 14 &11 :: l? x1
[13] jump list.unzip_either:map:next_match 2 -> 14 :: l x2
[14] __primitive.dep 13 :: l x1
[15] __primitive.assert 13 11 :: l? x1
[16] return [15 12]

___ list.unzip_either:map:next_match (1 -> 2) x2 rec ___
[1] changing var :: ?l x1
[2] __primitive.ap 1 -> 3 :: l? x3
[3] __primitive.dep 2 :: l x2
[4] __primitive.ap &3 -> 5 :: v? x1
[5] __primitive.dep 4 :: y x1
[6] __primitive.eq_s 5 7 :: y x3
[7] val Right :: y x1
[8] __primitive.assert 3 &6 :: l? x1
[9] __primitive.assert &2 &6 :: l? x1
[10] return [9 8] -> 16
[11] __primitive.not 6 :: y x2
[12] __primitive.assert 14 &11 :: l? x1
[13] jump list.unzip_either:map:next_match 2 -> 14 :: l x2
[14] __primitive.dep 13 :: l x1
[15] __primitive.assert 13 11 :: l? x1
[16] return [15 12]

___ list.unzip_either:map_1 (1 -> 1) rec row ___
[1] changing var :: ?l x1
[2] list.unzip_either:map_1:next_match 1 -> 3 :: l x2
[3] __primitive.dep 2 :: l x2
[4] __primitive.seq 6 &3 :: a x1
[5] __primitive.ap 3 -> 6 X :: v? x1
[6] __primitive.dep 5 :: a x1
[7] jump list.unzip_either:map_1 2 :: l x1
[8] __primitive.pushr 7 4 :: l x1
[9] return [8]

___ list.unzip_either:map_1:next_match (1 -> 2) x2 rec ___
[1] changing var :: ?l x1
[2] __primitive.ap 1 -> 3 :: l? x3
[3] __primitive.dep 2 :: l x2
[4] __primitive.ap &3 -> 5 :: v? x1
[5] __primitive.dep 4 :: y x1
[6] __primitive.eq_s 5 7 :: y x3
[7] val Left :: y x1
[8] __primitive.assert 3 &6 :: l? x1
[9] __primitive.assert &2 &6 :: l? x1
[10] return [9 8] -> 16
[11] __primitive.not 6 :: y x2
[12] __primitive.assert 14 &11 :: l? x1
[13] jump list.unzip_either:map_1:next_match 2 -> 14 :: l x2
[14] __primitive.dep 13 :: l x1
[15] __primitive.assert 13 11 :: l? x1
[16] return [15 12]

___ list.unzip_either:map_1:next_match (1 -> 2) x2 rec ___
[1] changing var :: ?l x1
[2] __primitive.ap 1 -> 3 :: l? x3
[3] __primitive.dep 2 :: l x2
[4] __primitive.ap &3 -> 5 :: v? x1
[5] __primitive.dep 4 :: y x1
[6] __primitive.eq_s 5 7 :: y x3
[7] val Left :: y x1
[8] __primitive.assert 3 &6 :: l? x1
[9] __primitive.assert &2 &6 :: l? x1
[10] return [9 8] -> 16
[11] __primitive.not 6 :: y x2
[12] __primitive.assert 14 &11 :: l? x1
[13] jump list.unzip_either:map_1:next_match 2 -> 14 :: l x2
[14] __primitive.dep 13 :: l x1
[15] __primitive.assert 13 11 :: l? x1
[16] return [15 12]

___ list.zip (3 -> 1) rec row ___
[1] var :: ?l x2
[2] changing var :: ?l x1
[3] changing var :: ?l x1
[4] __primitive.ap 3 -> 5 :: l? x2
[5] __primitive.dep 4 :: a x4
[6] __primitive.seq 9 &5 :: l x1
[7] __primitive.ap 2 -> 8 :: l? x2
[8] __primitive.dep 7 :: a x4
[9] __primitive.seq 10 &8 :: l x1
[10] __primitive.ap &5 &8 &1 :: l x1
[11] jump list.zip 4 7 1 :: l x1
[12] __primitive.seq 11 &8 :: l x1
[13] __primitive.seq 12 &5 :: l x1
[14] __primitive.compose 13 6 :: l x1
[15] __primitive.seq 14 8 :: l x1
[16] __primitive.seq 15 5 :: l x1
[17] return [16]

___ list.zip1 (3 -> 4) ___
[1] var :: ?l x2
[2] var :: ?l x1
[3] var :: ?l x1
[4] __primitive.ap 3 -> 5 :: l? x2
[5] __primitive.dep 4 :: a x2
[6] __primitive.seq 9 &5 :: l x1
[7] __primitive.ap 2 -> 8 :: l? x2
[8] __primitive.dep 7 :: a x2
[9] __primitive.seq 10 &8 :: l x1
[10] __primitive.ap 5 8 &1 :: l x1
[11] return [4 7 1 6]

___ list.zip1_with (4 -> 5) ___
[1] var :: ?l x2
[2] var :: ?a x1
[3] var :: ?l x1
[4] var :: ?l x1
[5] __primitive.ap 3 -> 6 :: l? x2
[6] __primitive.dep 5 :: a x1
[7] __primitive.ap 4 -> 8 :: l? x2
[8] __primitive.dep 7 :: a x1
[9] __primitive.ap 8 6 2 &1 -> 11 :: l? x2
[11] __primitive.dep 9 :: a x1
[12] return [7 5 11 1 9]

___ list.zip_with (4 -> 1) rec row ___
[1] var :: ?l x2
[2] changing var :: ?a x1
[3] changing var :: ?l x1
[4] changing var :: ?l x1
[5] __primitive.ap 3 -> 6 :: l? x2
[6] __primitive.dep 5 :: a x1
[7] __primitive.ap 4 -> 8 :: l? x2
[8] __primitive.dep 7 :: a x1
[9] __primitive.ap 8 6 2 &1 -> 11 :: l? x2
[11] __primitive.dep 9 :: a x1
[12] jump list.zip_with 7 5 11 1 :: l x1
[14] __primitive.compose 12 9 :: l x1
[15] return [14]

___ logic.and (2 -> 1) x2 ___
[1] var :: ?y x2
[2] var :: ?y x1
[3] __primitive.assert 2 &1 :: y? x1
[4] return [3] -> 8
[5] __primitive.not 1 :: y x1
[6] __primitive.assert 7 5 is False :: y? x1
[7] val False :: y x1
[8] return [6]

___ logic.default (2 -> 1) x2 ___
[1] var :: ?a x1
[2] var :: ?a x2
[3] return [2] -> 5
[4] __primitive.unless 1 2 :: a x1
[5] return [4]

___ logic.implies (2 -> 1) x2 ___
[1] var :: ?a x1
[2] var :: ?y x1
[3] __primitive.not 2 :: y x2
[4] __primitive.not &3 :: y x1
[5] __primitive.assert 1 4 :: a? x1
[6] return [5] -> 9
[7] __primitive.assert 8 3 is True :: y? x1
[8] val True :: y x1
[9] return [7]

___ logic.or (2 -> 1) x2 ___
[1] var :: ?y x2
[2] var :: ?y x1
[3] __primitive.not &1 :: y x1
[4] __primitive.assert 2 3 :: y? x1
[5] return [4] -> 8
[6] __primitive.assert 7 1 is True :: y? x1
[7] val True :: y x1
[8] return [6]

___ logic.other (3 -> 1) x2 ___
[1] var :: ?y x2
[2] var :: ?y x2
[3] var :: ?y x2
[4] __primitive.eq_s &3 &2 :: y x1
[5] __primitive.assert &1 4 :: y? x1
[6] return [5] -> 9
[7] __primitive.eq_s 3 1 :: y x1
[8] __primitive.assert 2 7 :: y? x1
[9] return [8]

___ logic.otherwise2 (4 -> 2) ___
[1] var :: ?a x1
[2] var :: ?a x1
[3] var :: ?a x2
[4] var :: ?a x2
[5] __primitive.unless 6 &4 :: a x1
[6] __primitive.unless 1 &3 :: a x1
[7] __primitive.unless 2 3 :: a x1
[8] __primitive.unless 7 4 :: a x1
[9] return [8 5]

___ logic.valid (1 -> 1) x2 ___
[1] var :: ?a x2
[2] __primitive.seq 3 1 is True :: y x1
[3] val True :: y x1
[4] return [2] -> 7
[5] __primitive.unless 6 1 is False :: y x1
[6] val False :: y x1
[7] return [5]

___ logic.vifte (3 -> 1) x2 ___
[1] var :: ?a x1
[2] var :: ?a x1
[3] var :: ?a x2
[4] __primitive.seq 2 3 :: a x1
[5] return [4] -> 7
[6] __primitive.unless 1 3 :: a x1
[7] return [6]

___ num.bound (3 -> 1) ___
[1] var :: ?i x1
[2] var :: ?i x1
[3] var :: ?i x2
[4] __primitive.gte &3 2 :: y x1
[5] __primitive.assert 3 4 :: i? x2
[6] __primitive.lte &5 1 :: y x1
[7] __primitive.assert 5 6 :: i? x1
[8] return [7]

___ num.even (1 -> 1) ___
[1] var :: ?i x1
[2] __primitive.bitand 1 3 in [0, 1] :: i x1
[3] val 1 :: i x1
[4] __primitive.eq 2 5 :: y x1
[5] val 0 :: i x1
[6] return [4]

___ num.max (2 -> 1) x2 ___
[1] var :: ?i x3
[2] var :: ?i x3
[3] __primitive.lte &2 &1 :: y x1
[4] __primitive.assert &1 3 :: i? x1
[5] return [4] -> 8
[6] __primitive.lte 1 &2 :: y x1
[7] __primitive.assert 2 6 :: i? x1
[8] return [7]

___ num.min (2 -> 1) x2 ___
[1] var :: ?i x3
[2] var :: ?i x3
[3] __primitive.gt &2 &1 :: y x1
[4] __primitive.assert &1 3 :: i? x1
[5] return [4] -> 8
[6] __primitive.gt 1 &2 :: y x1
[7] __primitive.assert 2 6 :: i? x1
[8] return [7]

___ num.odd (1 -> 1) ___
[1] var :: ?i x1
[2] __primitive.bitand 1 &3 in [0, 1] :: i x1
[3] val 1 :: i x2
[4] __primitive.eq 2 3 :: y x1
[5] return [4]

___ num.up_to (2 -> 1) ___
[1] var :: ?i x1
[2] var >= 0 :: ?i x2
[3] __primitive.gte &2 4 :: y x1
[4] val 0 :: i x1
[5] __primitive.assert 2 3 >= 0 :: i? x2
[6] __primitive.lte &5 1 :: y x1
[7] __primitive.assert 5 6 >= 0 :: i? x1
[8] return [7]

___ stack.-swap2 (3 -> 3) ___
[1] var :: ?a x1
[2] var :: ?a x1
[3] var :: ?a x1
[4] return [1 3 2]

___ stack.-swap3 (4 -> 4) ___
[1] var :: ?a x1
[2] var :: ?a x1
[3] var :: ?a x1
[4] var :: ?a x1
[5] return [1 4 3 2]

___ stack.-swap4 (5 -> 5) ___
[1] var :: ?a x1
[2] var :: ?a x1
[3] var :: ?a x1
[4] var :: ?a x1
[5] var :: ?a x1
[6] return [1 5 4 3 2]

___ stack.-swap5 (6 -> 6) ___
[1] var :: ?a x1
[2] var :: ?a x1
[3] var :: ?a x1
[4] var :: ?a x1
[5] var :: ?a x1
[6] var :: ?a x1
[7] return [1 6 5 4 3 2]

___ stack.-swap6 (7 -> 7) ___
[1] var :: ?a x1
[2] var :: ?a x1
[3] var :: ?a x1
[4] var :: ?a x1
[5] var :: ?a x1
[6] var :: ?a x1
[7] var :: ?a x1
[8] return [1 7 6 5 4 3 2]

___ stack.dup2 (2 -> 4) ___
[1] var :: ?a x2
[2] var :: ?a x2
[3] return [&2 &1 2 1]

___ stack.dup_under (2 -> 3) ___
[1] var :: ?a x1
[2] var :: ?a x2
[3] return [&2 2 1]

___ stack.exch2 (3 -> 3) ___
[1] var :: ?a x1
[2] var :: ?a x1
[3] var :: ?a x1
[4] return [1 2 3]

___ stack.exch3 (4 -> 4) ___
[1] var :: ?a x1
[2] var :: ?a x1
[3] var :: ?a x1
[4] var :: ?a x1
[5] return [1 3 2 4]

___ stack.exch4 (5 -> 5) ___
[1] var :: ?a x1
[2] var :: ?a x1
[3] var :: ?a x1
[4] var :: ?a x1
[5] var :: ?a x1
[6] return [1 4 3 2 5]

___ stack.get2 (1 -> 2) ___
[1] var :: ?l x1
[2] __primitive.ap 1 -> 4 3 :: v? x2
[3] __primitive.dep 2 :: a x1
[4] __primitive.dep 2 :: a x1
[5] return [4 3]

___ stack.get3 (1 -> 3) ___
[1] var :: ?l x1
[2] __primitive.ap 1 -> 5 4 3 :: v? x3
[3] __primitive.dep 2 :: a x1
[4] __primitive.dep 2 :: a x1
[5] __primitive.dep 2 :: a x1
[6] return [5 4 3]

___ stack.get4 (1 -> 4) ___
[1] var :: ?l x1
[2] __primitive.ap 1 -> 7 6 5 4 :: v? x4
[4] __primitive.dep 2 :: a x1
[5] __primitive.dep 2 :: a x1
[6] __primitive.dep 2 :: a x1
[7] __primitive.dep 2 :: a x1
[8] return [7 6 5 4]

___ stack.get5 (1 -> 5) ___
[1] var :: ?l x1
[2] __primitive.ap 1 -> 8 7 6 5 4 :: v? x5
[4] __primitive.dep 2 :: a x1
[5] __primitive.dep 2 :: a x1
[6] __primitive.dep 2 :: a x1
[7] __primitive.dep 2 :: a x1
[8] __primitive.dep 2 :: a x1
[9] return [8 7 6 5 4]

___ stack.get6 (1 -> 6) ___
[1] var :: ?l x1
[2] __primitive.ap 1 -> 9 8 7 6 5 4 :: v? x6
[4] __primitive.dep 2 :: a x1
[5] __primitive.dep 2 :: a x1
[6] __primitive.dep 2 :: a x1
[7] __primitive.dep 2 :: a x1
[8] __primitive.dep 2 :: a x1
[9] __primitive.dep 2 :: a x1
[10] return [9 8 7 6 5 4]

___ stack.get7 (1 -> 7) ___
[1] var :: ?l x1
[2] __primitive.ap 1 -> 10 9 8 7 6 5 4 :: v? x7
[4] __primitive.dep 2 :: a x1
[5] __primitive.dep 2 :: a x1
[6] __primitive.dep 2 :: a x1
[7] __primitive.dep 2 :: a x1
[8] __primitive.dep 2 :: a x1
[9] __primitive.dep 2 :: a x1
[10] __primitive.dep 2 :: a x1
[11] return [10 9 8 7 6 5 4]

___ stack.nip (2 -> 1) ___
[1] var :: ?a x1
[2] var :: ?v x0
[3] return [1]

___ stack.nip2 (3 -> 2) ___
[1] var :: ?a x1
[2] var :: ?a x1
[3] var :: ?v x0
[4] return [2 1]

___ stack.nip3 (4 -> 3) ___
[1] var :: ?a x1
[2] var :: ?a x1
[3] var :: ?a x1
[4] var :: ?v x0
[5] return [3 2 1]

___ stack.over (2 -> 3) ___
[1] var :: ?a x1
[2] var :: ?a x2
[3] return [&2 1 2]

___ stack.over2 (3 -> 4) ___
[1] var :: ?a x1
[2] var :: ?a x1
[3] var :: ?a x2
[4] return [&3 2 1 3]

___ stack.over3 (4 -> 5) ___
[1] var :: ?a x1
[2] var :: ?a x1
[3] var :: ?a x1
[4] var :: ?a x2
[5] return [&4 3 2 1 4]

___ stack.over4 (5 -> 6) ___
[1] var :: ?a x1
[2] var :: ?a x1
[3] var :: ?a x1
[4] var :: ?a x1
[5] var :: ?a x2
[6] return [&5 4 3 2 1 5]

___ stack.pull (1 -> 2) ___
[1] var :: ?l x1
[2] __primitive.ap 1 -> 3 :: l? x2
[3] __primitive.dep 2 :: a x1
[4] return [3 2]

___ stack.pull2 (1 -> 3) ___
[1] var :: ?l x1
[2] __primitive.ap 1 -> 3 4 :: l? x3
[3] __primitive.dep 2 :: a x1
[4] __primitive.dep 2 :: a x1
[5] return [4 3 2]

___ stack.pull3 (1 -> 4) ___
[1] var :: ?l x1
[2] __primitive.ap 1 -> 3 4 5 :: l? x4
[3] __primitive.dep 2 :: a x1
[4] __primitive.dep 2 :: a x1
[5] __primitive.dep 2 :: a x1
[6] return [5 4 3 2]

___ stack.pull4 (1 -> 5) ___
[1] var :: ?l x1
[2] __primitive.ap 1 -> 4 5 6 7 :: l? x5
[4] __primitive.dep 2 :: a x1
[5] __primitive.dep 2 :: a x1
[6] __primitive.dep 2 :: a x1
[7] __primitive.dep 2 :: a x1
[8] return [7 6 5 4 2]

___ stack.pull5 (1 -> 6) ___
[1] var :: ?l x1
[2] __primitive.ap 1 -> 4 5 6 7 8 :: l? x6
[4] __primitive.dep 2 :: a x1
[5] __primitive.dep 2 :: a x1
[6] __primitive.dep 2 :: a x1
[7] __primitive.dep 2 :: a x1
[8] __primitive.dep 2 :: a x1
[9] return [8 7 6 5 4 2]

___ stack.pull6 (1 -> 7) ___
[1] var :: ?l x1
[2] __primitive.ap 1 -> 4 5 6 7 8 9 :: l? x7
[4] __primitive.dep 2 :: a x1
[5] __primitive.dep 2 :: a x1
[6] __primitive.dep 2 :: a x1
[7] __primitive.dep 2 :: a x1
[8] __primitive.dep 2 :: a x1
[9] __primitive.dep 2 :: a x1
[10] return [9 8 7 6 5 4 2]

___ stack.pull7 (1 -> 8) ___
[1] var :: ?l x1
[2] __primitive.ap 1 -> 4 5 6 7 8 9 10 :: l? x8
[4] __primitive.dep 2 :: a x1
[5] __primitive.dep 2 :: a x1
[6] __primitive.dep 2 :: a x1
[7] __primitive.dep 2 :: a x1
[8] __primitive.dep 2 :: a x1
[9] __primitive.dep 2 :: a x1
[10] __primitive.dep 2 :: a x1
[11] return [10 9 8 7 6 5 4 2]

___ stack.pull8 (1 -> 9) ___
[1] var :: ?l x1
[2] __primitive.ap 1 -> 4 5 6 7 8 9 10 11 :: l? x9
[4] __primitive.dep 2 :: a x1
[5] __primitive.dep 2 :: a x1
[6] __primitive.dep 2 :: a x1
[7] __primitive.dep 2 :: a x1
[8] __primitive.dep 2 :: a x1
[9] __primitive.dep 2 :: a x1
[10] __primitive.dep 2 :: a x1
[11] __primitive.dep 2 :: a x1
[12] return [11 10 9 8 7 6 5 4 2]

___ stack.rev3 (3 -> 3) ___
[1] var :: ?a x1
[2] var :: ?a x1
[3] var :: ?a x1
[4] return [1 2 3]

___ stack.swap2 (3 -> 3) ___
[1] var :: ?a x1
[2] var :: ?a x1
[3] var :: ?a x1
[4] return [2 1 3]

___ stack.swap3 (4 -> 4) ___
[1] var :: ?a x1
[2] var :: ?a x1
[3] var :: ?a x1
[4] var :: ?a x1
[5] return [3 2 1 4]

___ stack.swap4 (5 -> 5) ___
[1] var :: ?a x1
[2] var :: ?a x1
[3] var :: ?a x1
[4] var :: ?a x1
[5] var :: ?a x1
[6] return [4 3 2 1 5]

___ stack.swap5 (6 -> 6) ___
[1] var :: ?a x1
[2] var :: ?a x1
[3] var :: ?a x1
[4] var :: ?a x1
[5] var :: ?a x1
[6] var :: ?a x1
[7] return [5 4 3 2 1 6]

___ stack.swap6 (7 -> 7) ___
[1] var :: ?a x1
[2] var :: ?a x1
[3] var :: ?a x1
[4] var :: ?a x1
[5] var :: ?a x1
[6] var :: ?a x1
[7] var :: ?a x1
[8] return [6 5 4 3 2 1 7]

___ stack.swap7 (8 -> 8) ___
[1] var :: ?a x1
[2] var :: ?a x1
[3] var :: ?a x1
[4] var :: ?a x1
[5] var :: ?a x1
[6] var :: ?a x1
[7] var :: ?a x1
[8] var :: ?a x1
[9] return [7 6 5 4 3 2 1 8]

___ stack.tail (1 -> 1) ___
[1] var :: ?l x1
[2] __primitive.ap 1 -> X :: l? x1
[3] return [2]

___ stack.tail2 (1 -> 1) ___
[1] var :: ?l x1
[2] __primitive.ap 1 -> X X :: l? x1
[3] return [2]

___ stack.tuck (2 -> 3) ___
[1] var :: ?a x2
[2] var :: ?a x1
[3] return [&1 2 1]

___ tests.add_array_at (3 -> 2) ___
[1] var :: ?i x1
[2] var :: ?i x3
[3] var is Array :: ?o x1
[4] __primitive.read_array 3 &2 -> 5 is Array :: o x2
[5] __primitive.dep 4 :: i x1
[6] __primitive.add 5 1 :: i x1
[7] __primitive.write_array 4 &2 6 is Array :: o x1
[8] __primitive.read_array 7 2 -> 9 is Array :: o x2
[9] __primitive.dep 8 :: i x1
[10] return [8 9]

___ tests.after0 (1 -> 1) ___
[1] var :: ?l x1
[2] jump tests.after0:iterate 1 :: a x1
[3] return [2]

___ tests.after0:iterate (1 -> 1) x2 rec ___
[1] changing var :: ?l x2
[2] __primitive.ap &1 -> 3 :: l? x2
[3] __primitive.dep 2 :: i x1
[4] __primitive.neq 3 5 :: y x2
[5] val 0 :: i x1
[6] __primitive.not &4 :: y x1
[7] __primitive.assert 9 6 :: a? x1
[8] __primitive.ap 1 -> 9 X :: v? x1
[9] __primitive.dep 8 :: a x1
[10] return [7] -> 13
[11] __primitive.assert 12 4 :: a? x1
[12] jump tests.after0:iterate 2 :: a x1
[13] return [11]

___ tests.after_sum (1 -> 1) ___
[1] var :: ?l x1
[2] val 0 :: i x1
[3] tests.after_sum:foldr:iterate 2 1 :: i x1
[4] __primitive.add 3 5 :: i x1
[5] val 42 :: i x1
[6] return [4]

___ tests.after_sum:foldr:iterate (2 -> 1) x2 rec ___
[1] changing var :: ?l x1
[2] changing var :: ?i x2
[3] __primitive.ap 1 -> 4 :: l? x2
[4] __primitive.dep 3 :: i x3
[5] __primitive.seq 7 &4 :: v x1
[6] __primitive.add 4 2 :: i x1
[7] jump tests.after_sum:foldr:iterate 6 3 :: v x1
[8] return [5] -> 10
[9] __primitive.unless 2 4 :: i x1
[10] return [9]

___ tests.alt_list (2 -> 1) x2 ___
[1] var :: ?a x2
[2] var :: ?a x2
[3] __primitive.quote &2 2 :: l x1
[4] return [3] -> 6
[5] __primitive.quote &1 1 :: l x1
[6] return [5]

___ tests.alt_seq (1 -> 1) x2 ___
[1] var :: ?y x2
[2] __primitive.assert 3 &1 is 1 :: i? x1
[3] val 1 :: i x1
[4] return [2] -> 8
[5] __primitive.not 1 :: y x1
[6] __primitive.assert 7 5 is 2 :: i? x1
[7] val 2 :: i x1
[8] return [6]

___ tests.altf_loop (2 -> 1) ___
[1] var :: ?i x1
[2] var :: ?a x1
[3] jump tests.altf_loop:iterate 1 2 :: a x1
[4] return [3]

___ tests.altf_loop:iterate (2 -> 1) x3 rec ___
[1] var :: ?a x2
[2] changing var :: ?i x2
[3] __primitive.gt &2 &4 :: y x3
[4] val 1 :: i x2
[5] __primitive.not &3 :: y x1
[6] __primitive.assert &1 5 :: a? x1
[7] return [6] -> 11
[8] __primitive.assert &10 &3 :: a? x1
[9] __primitive.sub 2 4 :: i x1.
[10] jump tests.altf_loop:iterate 9 1 :: a x2.
[11] return [8] -> 13
[12] __primitive.assert 10 3 :: a? x1
[13] return [12]

___ tests.asq (2 -> 2) row ___
[1] var :: ?y x4
[2] var :: ?l x1
[3] __primitive.assert 5 &1 :: a? x2
[4] __primitive.ap &1 2 -> 5 :: l? x2
[5] __primitive.dep 4 :: a x1
[6] __primitive.assert 4 &1 :: l? x1
[7] __primitive.pushr 6 &3 :: l x1
[8] __primitive.assert 7 1 :: l? x1
[9] return [8 3]

___ tests.asq2 (1 -> 1) ___
[1] var :: ?l x1
[2] __primitive.ap 1 -> 3 :: l? x2
[3] __primitive.dep 2 :: y x2
[4] __primitive.assert 5 &3 :: l? x1
[5] __primitive.ap 3 2 :: l x1
[6] return [4]

___ tests.assert_nready (2 -> 1) ___
[1] var :: ?y x1
[2] var :: ?i x1
[3] __primitive.assert 4 1 :: i? x1
[4] __primitive.add 2 5 :: i x1
[5] val 1 :: i x1
[6] return [3]

___ tests.assert_otherwise_quote (2 -> 1) ___
[1] var :: ?y x1
[2] var :: ?a x1
[3] __primitive.assert 4 1 :: y? x1
[4] val Something :: y x1
[5] __primitive.unless 2 3 :: a x1
[6] return [5]

___ tests.assert_seq (2 -> 1) ___
[1] var :: ?y x1
[2] var is 1 :: ?i x1
[3] __primitive.assert 2 1 is 1 :: i? x1
[4] return [3]

___ tests.assoc100 (3 -> 1) ___
[1] var in [0, 100] :: ?i x2
[2] var in [0, 100] :: ?i x2
[3] var in [0, 100] :: ?i x2
[4] __primitive.gte &3 &5 :: y x1
[5] val 0 :: i x3
[6] __primitive.assert 3 4 in [0, 100] :: i? x2
[7] __primitive.lte &6 &8 :: y x1
[8] val 100 :: i x3
[9] __primitive.assert 6 7 in [0, 100] :: i? x2
[10] __primitive.gte &2 &5 :: y x1
[11] __primitive.assert 2 10 in [0, 100] :: i? x2
[12] __primitive.lte &11 &8 :: y x1
[13] __primitive.assert 11 12 in [0, 100] :: i? x2
[14] __primitive.gte &1 5 :: y x1
[15] __primitive.assert 1 14 in [0, 100] :: i? x2
[16] __primitive.lte &15 8 :: y x1
[17] __primitive.assert 15 16 in [0, 100] :: i? x2
[18] __primitive.add &13 &17 in [0, 200] :: i x1
[19] __primitive.add &9 18 in [0, 300] :: i x1
[20] __primitive.add 9 13 in [0, 200] :: i x1
[21] __primitive.add 20 17 in [0, 300] :: i x1
[22] __primitive.eq 19 21 :: y x1
[23] __primitive.assert 24 22 is True :: y? x1
[24] val True :: y x1
[25] return [23]

___ tests.binrec (4 -> 1) ___
[1] var :: ?l x1
[2] var :: ?l x1
[3] var :: ?l x1
[4] var :: ?a x1
[5] control.iterate 4 3 2 :: a x1
[6] __primitive.ap 5 1 -> 7 :: v? x1
[7] __primitive.dep 6 :: a x1
[8] return [7]

___ tests.box (0 -> 1) rec ___
[1] tests.box :: v x1
[2] __primitive.quote 1 :: l x1
[3] return [2]

___ tests.br10 (1 -> 1) ___
[1] var :: ?i x1
[2] jump tests.br10:iterate 1 :: i x1
[3] return [2]

___ tests.br10:iterate (1 -> 1) x2 rec ___
[1] changing var :: ?i x3
[2] __primitive.lt &1 3 :: y x2
[3] val 10 :: i x1
[4] __primitive.not &2 :: y x1
[5] __primitive.assert &1 4 :: i? x1
[6] return [5] -> 11
[7] __primitive.assert 10 2 :: i? x1
[8] __primitive.add 1 9 :: i x1
[9] val 1 :: i x1
[10] jump tests.br10:iterate 8 :: i x1
[11] return [7]

___ tests.calc (1 -> 1) ___
[1] var :: ?y x1
[2] __primitive.quote 3 1b :: l x1
[3] val 0 :: i x1
[4] jump tests.calc_loop 1 2 :: y x1
[5] return [4]

___ tests.calc_loop (2 -> 1) x15 rec ___
[1] changing var :: ?l x13
[2] changing var :: ?y x1
[3] __primitive.open 2 4 -> 5 :: y x2
[4] val "stream,out:std" :: s x1
[5] __primitive.dep 3 is File :: o x1
[6] __primitive.ap &1 -> 7 :: l? x4
[7] __primitive.dep 6 :: i x4
[8] __primitive.to_string &7 :: s x1
[9] __primitive.strcat 8 10 :: s x1
[10] val "\n" :: s x1
[11] __primitive.write 3 5 9 -> 12 :: y x2
[12] __primitive.dep 11 is File :: o x1
[13] __primitive.close 11 12 :: y x1
[14] __primitive.open 13 15 -> 16 :: y x2
[15] val "stream,in:std" :: s x1
[16] __primitive.dep 14 is File :: o x1
[17] io.getline_loop 14 16 19 -> 24 20 :: y x3
[19] val "" :: s x1
[20] __primitive.dep 17 :: s x1
[21] __primitive.strtrim 20 :: s x14
[22] __primitive.from_string &21 :: i? x3
[23] __primitive.seq 27 &22 :: v x1
[24] __primitive.dep 17 is File :: o x1.
[25] __primitive.close 17 24 :: y x15.
[26] __primitive.pushr 1 22 :: l x1
[27] jump tests.calc_loop 25 26 :: v x1
[28] return [23] -> 41
[29] __primitive.eq_str &21 30 :: y x3
[30] val "+" :: s x1
[31] __primitive.assert 39 &29 :: l? x1
[32] __primitive.assert 36 &29 :: i? x3
[33] __primitive.ap &1 -> 34 35 :: l? x3
[34] __primitive.dep 33 :: i x1
[35] __primitive.dep 33 :: i x1
[36] __primitive.add 34 35 :: i x1
[37] __primitive.seq 40 &32 :: v x1
[38] __primitive.assert 33 29 :: l? x1
[39] __primitive.pushr 38 32 :: l x1
[40] jump tests.calc_loop 25 31 :: v x1
[41] return [37] -> 54
[42] __primitive.eq_str &21 43 :: y x3
[43] val "-" :: s x1
[44] __primitive.assert 52 &42 :: l? x1
[45] __primitive.assert 49 &42 :: i? x3
[46] __primitive.ap &1 -> 47 48 :: l? x3
[47] __primitive.dep 46 :: i x1
[48] __primitive.dep 46 :: i x1
[49] __primitive.sub 47 48 :: i x1
[50] __primitive.seq 53 &45 :: v x1
[51] __primitive.assert 46 42 :: l? x1
[52] __primitive.pushr 51 45 :: l x1
[53] jump tests.calc_loop 25 44 :: v x1
[54] return [50] -> 67
[55] __primitive.eq_str &21 56 :: y x3
[56] val "*" :: s x1
[57] __primitive.assert 65 &55 :: l? x1
[58] __primitive.assert 62 &55 :: i? x3
[59] __primitive.ap &1 -> 60 61 :: l? x3
[60] __primitive.dep 59 :: i x1
[61] __primitive.dep 59 :: i x1
[62] __primitive.mul 60 61 :: i x1
[63] __primitive.seq 66 &58 :: v x1
[64] __primitive.assert 59 55 :: l? x1
[65] __primitive.pushr 64 58 :: l x1
[66] jump tests.calc_loop 25 57 :: v x1
[67] return [63] -> 80
[68] __primitive.eq_str &21 69 :: y x3
[69] val "/" :: s x1
[70] __primitive.assert 78 &68 :: l? x1
[71] __primitive.assert 75 &68 :: i? x3
[72] __primitive.ap &1 -> 74 73 :: l? x3
[73] __primitive.dep 72 :: i x1
[74] __primitive.dep 72 :: i x1
[75] __primitive.div 74 73 :: i? x1
[76] __primitive.seq 79 &71 :: v x1
[77] __primitive.assert 72 68 :: l? x1
[78] __primitive.pushr 77 71 :: l x1
[79] jump tests.calc_loop 25 70 :: v x1
[80] return [76] -> 93
[81] __primitive.eq_str &21 82 :: y x3
[82] val "gcd" :: s x1
[83] __primitive.assert 91 &81 :: l? x1
[84] __primitive.assert 88 &81 :: i? x3
[85] __primitive.ap &1 -> 87 86 :: l? x3
[86] __primitive.dep 85 :: i x1
[87] __primitive.dep 85 :: i x1
[88] algorithm.gcd:iterate 86 87 :: i x1
[89] __primitive.seq 92 &84 :: v x1
[90] __primitive.assert 85 81 :: l? x1
[91] __primitive.pushr 90 84 :: l x1
[92] jump tests.calc_loop 25 83 :: v x1
[93] return [89] -> 107
[94] __primitive.eq_str &21 95 :: y x3
[95] val "^" :: s x1
[96] __primitive.assert 105 &94 :: l? x1
[97] __primitive.assert 101 &94 :: i? x3
[98] __primitive.ap &1 -> 100 99 :: l? x3
[99] __primitive.dep 98 :: i x1
[100] __primitive.dep 98 :: i x1
[101] algorithm.^:iterate 99 100 &102 :: i x1
[102] val 1 :: i x3
[103] __primitive.seq 106 &97 :: v x1
[104] __primitive.assert 98 94 :: l? x1
[105] __primitive.pushr 104 97 :: l x1
[106] jump tests.calc_loop 25 96 :: v x1
[107] return [103] -> 119
[108] __primitive.eq_str &21 109 :: y x3
[109] val "fib" :: s x1
[110] __primitive.assert 117 &108 :: l? x1
[111] __primitive.assert 113 &108 :: i? x3
[112] __primitive.sub &7 &102 :: i x1
[113] tests.fibl:times:iterate 112 102 &114 :: i x1
[114] val 0 :: i x3
[115] __primitive.seq 118 &111 :: v x1
[116] __primitive.assert &6 108 :: l? x1
[117] __primitive.pushr 116 111 :: l x1
[118] jump tests.calc_loop 25 110 :: v x1
[119] return [115] -> 129
[120] __primitive.eq_str &21 121 :: y x3
[121] val "fact" :: s x1
[122] __primitive.assert 127 &120 :: l? x1
[123] __primitive.assert 124 &120 :: i? x3
[124] tests.fact &7 :: i x1
[125] __primitive.seq 128 &123 :: v x1
[126] __primitive.assert &6 120 :: l? x1
[127] __primitive.pushr 126 123 :: l x1
[128] jump tests.calc_loop 25 122 :: v x1
[129] return [125] -> 139
[130] __primitive.eq_str &21 131 :: y x3
[131] val "len" :: s x1
[132] __primitive.assert 137 &130 :: l? x1
[133] __primitive.assert 134 &130 :: i? x3
[134] list.length:iterate &1 &114 :: i x1
[135] __primitive.seq 138 &133 :: v x1
[136] __primitive.assert &1 130 :: l? x1
[137] __primitive.pushr 136 133 :: l x1
[138] jump tests.calc_loop 25 132 :: v x1
[139] return [135] -> 148
[140] __primitive.eq_str &21 141 :: y x2
[141] val "sum" :: s x1
[142] __primitive.assert 146 &140 :: l? x1
[143] __primitive.assert 144 140 :: i? x3
[144] algorithm.sum:foldr:iterate 114 1 :: i x1
[145] __primitive.seq 147 &143 :: v x1
[146] __primitive.quote 143 :: l x1
[147] jump tests.calc_loop 25 142 :: v x1
[148] return [145] -> 161
[149] __primitive.eq_str &21 150 :: y x4
[150] val "swap" :: s x1
[151] __primitive.assert 159 &149 :: l? x1
[152] __primitive.assert 154 &149 :: a? x3
[153] __primitive.ap &1 -> 154 157 :: l? x3
[154] __primitive.dep 153 :: a x1
[155] __primitive.seq 160 &152 :: v x1
[156] __primitive.assert 157 &149 :: a? x1
[157] __primitive.dep 153 :: a x1
[158] __primitive.assert 153 149 :: l? x1
[159] __primitive.pushr 158 156 152 :: l x1
[160] jump tests.calc_loop 25 151 :: v x1
[161] return [155] -> 170
[162] __primitive.eq_str &21 163 :: y x3
[163] val "dup" :: s x1
[164] __primitive.assert 168 &162 :: l? x1
[165] __primitive.assert 7 &162 :: i? x4
[166] __primitive.seq 169 &165 :: v x1
[167] __primitive.assert 6 162 :: l? x1
[168] __primitive.pushr 167 &165 165 :: l x1
[169] jump tests.calc_loop 25 164 :: v x1
[170] return [166] -> 181
[171] __primitive.eq_str 21 172 :: y x3
[172] val "drop" :: s x1
[173] __primitive.assert 179 &171 :: l? x1
[174] __primitive.assert 176 &171 :: a? x3
[175] __primitive.ap 1 -> 176 X :: l? x2
[176] __primitive.dep 175 :: a x1
[177] __primitive.seq 180 &174 :: v x1
[178] __primitive.assert 175 171 :: l? x1
[179] __primitive.pushr 178 174 :: l x1
[180] jump tests.calc_loop 25 173 :: v x1
[181] return [177] -> 196
[182] __primitive.unless 25 22 :: y x1
[183] __primitive.unless 182 32 :: y x1
[184] __primitive.unless 183 45 :: y x1
[185] __primitive.unless 184 58 :: y x1
[186] __primitive.unless 185 71 :: y x1
[187] __primitive.unless 186 84 :: y x1
[188] __primitive.unless 187 97 :: y x1
[189] __primitive.unless 188 111 :: y x1
[190] __primitive.unless 189 123 :: y x1
[191] __primitive.unless 190 133 :: y x1
[192] __primitive.unless 191 143 :: y x1
[193] __primitive.unless 192 152 :: y x1
[194] __primitive.unless 193 165 :: y x1
[195] __primitive.unless 194 174 :: y x1
[196] return [195]

___ tests.calc_step (2 -> 1) x14 row ___
[1] var :: ?s x1
[2] var :: ?l x15
[3] __primitive.strtrim 1 :: s x14
[4] __primitive.from_string &3 :: i? x1
[5] __primitive.pushr 2 4 :: l x1
[6] return [5] -> 17
[7] __primitive.eq_str &3 8 :: y x3
[8] val "+" :: s x1
[9] __primitive.assert 13 &7 :: i? x1
[10] __primitive.ap &2 -> 11 12 :: l? x3
[11] __primitive.dep 10 :: i x1
[12] __primitive.dep 10 :: i x1
[13] __primitive.add 11 12 :: i x1
[14] __primitive.assert 10 &7 :: l? x1
[15] __primitive.pushr 14 9 :: l x1
[16] __primitive.assert 15 7 :: l? x1
[17] return [16] -> 28
[18] __primitive.eq_str &3 19 :: y x3
[19] val "-" :: s x1
[20] __primitive.assert 24 &18 :: i? x1
[21] __primitive.ap &2 -> 22 23 :: l? x3
[22] __primitive.dep 21 :: i x1
[23] __primitive.dep 21 :: i x1
[24] __primitive.sub 22 23 :: i x1
[25] __primitive.assert 21 &18 :: l? x1
[26] __primitive.pushr 25 20 :: l x1
[27] __primitive.assert 26 18 :: l? x1
[28] return [27] -> 39
[29] __primitive.eq_str &3 30 :: y x3
[30] val "*" :: s x1
[31] __primitive.assert 35 &29 :: i? x1
[32] __primitive.ap &2 -> 33 34 :: l? x3
[33] __primitive.dep 32 :: i x1
[34] __primitive.dep 32 :: i x1
[35] __primitive.mul 33 34 :: i x1
[36] __primitive.assert 32 &29 :: l? x1
[37] __primitive.pushr 36 31 :: l x1
[38] __primitive.assert 37 29 :: l? x1
[39] return [38] -> 50
[40] __primitive.eq_str &3 41 :: y x3
[41] val "/" :: s x1
[42] __primitive.assert 46 &40 :: i? x1
[43] __primitive.ap &2 -> 45 44 :: l? x3
[44] __primitive.dep 43 :: i x1
[45] __primitive.dep 43 :: i x1
[46] __primitive.div 45 44 :: i? x1
[47] __primitive.assert 43 &40 :: l? x1
[48] __primitive.pushr 47 42 :: l x1
[49] __primitive.assert 48 40 :: l? x1
[50] return [49] -> 61
[51] __primitive.eq_str &3 52 :: y x3
[52] val "gcd" :: s x1
[53] __primitive.assert 57 &51 :: i? x1
[54] __primitive.ap &2 -> 56 55 :: l? x3
[55] __primitive.dep 54 :: i x1
[56] __primitive.dep 54 :: i x1
[57] jump algorithm.gcd:iterate 55 56 :: i x1
[58] __primitive.assert 54 &51 :: l? x1
[59] __primitive.pushr 58 53 :: l x1
[60] __primitive.assert 59 51 :: l? x1
[61] return [60] -> 73
[62] __primitive.eq_str &3 63 :: y x3
[63] val "^" :: s x1
[64] __primitive.assert 68 &62 :: i? x1
[65] __primitive.ap &2 -> 67 66 :: l? x3
[66] __primitive.dep 65 :: i x1
[67] __primitive.dep 65 :: i x1
[68] jump algorithm.^:iterate 66 67 &69 :: i x1
[69] val 1 :: i x3
[70] __primitive.assert 65 &62 :: l? x1
[71] __primitive.pushr 70 64 :: l x1
[72] __primitive.assert 71 62 :: l? x1
[73] return [72] -> 85
[74] __primitive.eq_str &3 75 :: y x3
[75] val "fib" :: s x1
[76] __primitive.assert 80 &74 :: i? x1
[77] __primitive.ap &2 -> 78 :: l? x2
[78] __primitive.dep 77 :: i x1
[79] __primitive.sub 78 &69 :: i x1
[80] jump tests.fibl:times:iterate 79 69 &81 :: i x1
[81] val 0 :: i x3
[82] __primitive.assert 77 &74 :: l? x1
[83] __primitive.pushr 82 76 :: l x1
[84] __primitive.assert 83 74 :: l? x1
[85] return [84] -> 95
[86] __primitive.eq_str &3 87 :: y x3
[87] val "fact" :: s x1
[88] __primitive.assert 91 &86 :: i? x1
[89] __primitive.ap &2 -> 90 :: l? x2
[90] __primitive.dep 89 :: i x1
[91] jump tests.fact 90 :: i x1
[92] __primitive.assert 89 &86 :: l? x1
[93] __primitive.pushr 92 88 :: l x1
[94] __primitive.assert 93 86 :: l? x1
[95] return [94] -> 103
[96] __primitive.eq_str &3 97 :: y x3
[97] val "len" :: s x1
[98] __primitive.assert 99 &96 :: i? x1
[99] jump list.length:iterate &2 &81 :: i x1
[100] __primitive.assert &2 &96 :: l? x1
[101] __primitive.pushr 100 98 :: l x1
[102] __primitive.assert 101 96 :: l? x1
[103] return [102] -> 110
[104] __primitive.eq_str &3 105 :: y x2
[105] val "sum" :: s x1
[106] __primitive.assert 107 &104 :: i? x1
[107] algorithm.sum:foldr:iterate 81 &2 :: i x1
[108] __primitive.quote 106 :: l x1
[109] __primitive.assert 108 104 :: l? x1
[110] return [109] -> 121
[111] __primitive.eq_str &3 112 :: y x4
[112] val "swap" :: s x1
[113] __primitive.assert 115 &111 :: a? x1
[114] __primitive.ap &2 -> 115 116 :: l? x3
[115] __primitive.dep 114 :: a x1
[116] __primitive.dep 114 :: a x1
[117] __primitive.assert 116 &111 :: a? x1
[118] __primitive.assert 114 &111 :: l? x1
[119] __primitive.pushr 118 117 113 :: l x1
[120] __primitive.assert 119 111 :: l? x1
[121] return [120] -> 130
[122] __primitive.eq_str &3 123 :: y x3
[123] val "dup" :: s x1
[124] __primitive.assert 126 &122 :: a? x2
[125] __primitive.ap &2 -> 126 :: l? x2
[126] __primitive.dep 125 :: a x1
[127] __primitive.assert 125 &122 :: l? x1
[128] __primitive.pushr 127 &124 124 :: l x1
[129] __primitive.assert 128 122 :: l? x1
[130] return [129] -> 139
[131] __primitive.eq_str 3 132 :: y x3
[132] val "drop" :: s x1
[133] __primitive.assert 135 &131 :: a? x1
[134] __primitive.ap 2 -> 135 X :: l? x2
[135] __primitive.dep 134 :: a x1
[136] __primitive.assert 134 &131 :: l? x1
[137] __primitive.pushr 136 133 :: l x1
[138] __primitive.assert 137 131 :: l? x1
[139] return [138]

___ tests.calc_step_dummy (2 -> 1) row ___
[1] var :: ?s x1
[2] var :: ?l x1
[3] __primitive.ap 2 -> 4 :: l? x2
[4] __primitive.dep 3 :: i x1
[5] __primitive.strtrim 1 :: s x1
[6] __primitive.from_string 5 :: i? x1
[7] __primitive.add 4 6 :: i x1
[8] __primitive.pushr 3 7 :: l x1
[9] return [8]

___ tests.calc_step_push (2 -> 1) x2 row ___
[1] var :: ?s x1
[2] var :: ?l x2
[3] __primitive.strtrim 1 :: s x2
[4] __primitive.eq_str &3 5 :: y x3
[5] val "1" :: s x1
[6] __primitive.assert &2 &4 :: l? x1
[7] __primitive.pushr 6 9 :: l x1
[8] val 1 :: i x1
[9] __primitive.assert 8 &4 is 1 :: i? x1
[10] __primitive.assert 7 4 :: l? x1
[11] return [10] -> 22
[12] __primitive.eq_str 3 13 :: y x3
[13] val "+" :: s x1
[14] __primitive.assert 18 &12 :: i? x1
[15] __primitive.ap 2 -> 16 17 :: l? x3
[16] __primitive.dep 15 :: i x1
[17] __primitive.dep 15 :: i x1
[18] __primitive.add 16 17 :: i x1
[19] __primitive.assert 15 &12 :: l? x1
[20] __primitive.pushr 19 14 :: l x1
[21] __primitive.assert 20 12 :: l? x1
[22] return [21]

___ tests.calc_step_simple (2 -> 1) x2 row ___
[1] var :: ?s x1
[2] var :: ?l x2
[3] __primitive.strtrim 1 :: s x2
[4] __primitive.from_string &3 :: i? x1
[5] __primitive.pushr 2 4 :: l x1
[6] return [5] -> 17
[7] __primitive.eq_str 3 8 :: y x3
[8] val "+" :: s x1
[9] __primitive.assert 13 &7 :: i? x1
[10] __primitive.ap 2 -> 11 12 :: l? x3
[11] __primitive.dep 10 :: i x1
[12] __primitive.dep 10 :: i x1
[13] __primitive.add 11 12 :: i x1
[14] __primitive.assert 10 &7 :: l? x1
[15] __primitive.pushr 14 9 :: l x1
[16] __primitive.assert 15 7 :: l? x1
[17] return [16]

___ tests.cmap (2 -> 1) ___
[1] var :: ?l x1
[2] var :: ?l x1
[3] [] :: l x1
[4] jump tests.cmap:concat_map:concat:foldr:iterate 3 2 1 :: l x1
[5] return [4]

___ tests.cmap:concat_map:concat:foldr:iterate (3 -> 1) x2 rec ___
[1] var :: ?l x2
[2] changing var :: ?l x1
[3] changing var :: ?l x2
[4] __primitive.ap 2 -> 5 :: l? x2
[5] __primitive.dep 4 :: a x1
[6] __primitive.ap 5 &1 :: l x2
[7] __primitive.ap &6 -> 8 :: l? x2
[8] __primitive.dep 7 :: a x1
[9] __primitive.ap 7 8 3 :: l x1
[10] jump tests.cmap:concat_map:concat:foldr:iterate 9 4 1 :: v x1
[11] return [10] -> 13
[12] __primitive.unless 3 6 :: l x1
[13] return [12]

___ tests.collatz (1 -> 1) ___
[1] var :: ?i x1
[2] val 0 :: i x1
[3] jump tests.collatz:iterate 1 2 :: i x1
[4] return [3]

___ tests.collatz:iterate (2 -> 1) x3 rec ___
[1] changing var :: ?i x2
[2] changing var :: ?i x4
[3] __primitive.gt &2 &4 :: y x3
[4] val 1 :: i x5
[5] __primitive.not &3 :: y x1
[6] __primitive.assert &1 5 :: i? x1
[7] return [6] -> 17
[8] __primitive.assert 16 &3 :: i? x1
[9] __primitive.add 1 &4 :: i x2.
[10] __primitive.bitand &2 &4 in [0, 1] :: i x2.
[11] __primitive.eq &10 12 :: y x1
[12] val 0 :: i x1
[13] __primitive.assert 14 11 :: i? x1
[14] __primitive.div &2 15 :: i? x1
[15] val 2 :: i x1
[16] jump tests.collatz:iterate 13 9 :: i x1
[17] return [8] -> 25
[18] __primitive.assert 24 3 :: i? x1
[19] __primitive.eq 10 &4 :: y x1
[20] __primitive.assert 23 19 :: i? x1
[21] __primitive.mul 2 22 :: i x1
[22] val 3 :: i x1
[23] __primitive.add 21 4 :: i x1
[24] jump tests.collatz:iterate 20 9 :: i x1
[25] return [18]

___ tests.collatz_step (1 -> 1) x2 ___
[1] var :: ?i x3
[2] __primitive.bitand &1 &3 in [0, 1] :: i x2
[3] val 1 :: i x3
[4] __primitive.eq &2 5 :: y x1
[5] val 0 :: i x1
[6] __primitive.assert 7 4 :: i? x1
[7] __primitive.div &1 8 :: i? x1
[8] val 2 :: i x1
[9] return [6] -> 15
[10] __primitive.eq 2 &3 :: y x1
[11] __primitive.assert 14 10 :: i? x1
[12] __primitive.mul 1 13 :: i x1
[13] val 3 :: i x1
[14] __primitive.add 12 3 :: i x1
[15] return [11]

___ tests.compose_alt (1 -> 1) x2 ___
[1] var :: ?l x1
[2] __primitive.ap 1 -> 3 :: v? x1
[3] __primitive.dep 2 :: i x2
[4] __primitive.add 3 5 :: i x1
[5] val 1 :: i x1
[6] return [4] -> 7
[7] return [3]

___ tests.compute_fn (1 -> 1) x2 ___
[1] var in [0, 1] :: ?i x4
[2] __primitive.eq &1 &3 :: y x2
[3] val 0 :: i x3
[4] __primitive.not &2 :: y x1
[5] __primitive.bitand &1 &6 is 0 :: i x1
[6] val 2147483648 :: i x2
[7] __primitive.eq 5 &3 :: y x1
[8] __primitive.not 7 :: y x1
[9] __primitive.assert 8 4 :: y? x1
[10] __primitive.assert &1 2 in [0, 1] :: i? x1
[11] return [10] -> 16
[12] __primitive.not 9 :: y x1
[13] __primitive.assert 15 12 :: i? x1
[14] tests.collatz:iterate 1 3 :: i x1
[15] __primitive.bitor 14 6 :: i x1
[16] return [13]

___ tests.concat_map (2 -> 1) ___
[1] var :: ?l x1
[2] var :: ?l x1
[3] [] :: l x1
[4] jump tests.concat_map:concat:foldr:iterate 3 2 1 :: l x1
[5] return [4]

___ tests.concat_map:concat:foldr:iterate (3 -> 1) x2 rec row ___
[1] var :: ?l x2
[2] changing var :: ?l x1
[3] changing var :: ?l x2
[4] __primitive.ap 2 -> 5 :: l? x2
[5] __primitive.dep 4 :: a x2
[6] __primitive.seq 8 &5 :: l x3
[7] __primitive.ap 5 &1 -> 8 :: v? x1
[8] __primitive.dep 7 :: l x1
[9] __primitive.seq 11 &6 :: v x1
[10] __primitive.compose 6 3 :: l x1
[11] jump tests.concat_map:concat:foldr:iterate 10 4 1 :: v x1
[12] return [9] -> 14
[13] __primitive.unless 3 6 :: l x1
[14] return [13]

___ tests.count (1 -> 1) x2 rec ___
[1] changing var >= 0 :: ?i x3
[2] __primitive.eq &1 &3 :: y x1
[3] val 0 :: i x3
[4] __primitive.assert &3 2 is 0 :: i? x1
[5] return [4] -> 12
[6] __primitive.gt &1 3 :: y x1
[7] __primitive.sub 1 &8 >= -1 :: i x1
[8] val 1 :: i x2
[9] tests.count 7 :: i x1
[10] __primitive.add 9 8 :: i x1
[11] __primitive.assert 10 6 :: i? x1
[12] return [11]

___ tests.dec (1 -> 1) x2 rec ___
[1] changing var :: ?i x4
[2] __primitive.lte &1 &3 :: y x1
[3] val 5 :: i x2
[4] __primitive.assert &1 2 :: i? x1
[5] return [4] -> 11
[6] __primitive.gt &1 3 :: y x1
[7] __primitive.sub 1 8 :: i x1
[8] val 1 :: i x1
[9] jump tests.dec 7 :: i x1
[10] __primitive.assert 9 6 :: i? x1
[11] return [10]

___ tests.decel (1 -> 1) ___
[1] var :: ?i x1
[2] val 0 :: i x1
[3] jump tests.decel:iterate 1 2 :: i x1
[4] return [3]

___ tests.decel:iterate (2 -> 1) x3 rec ___
[1] changing var :: ?i x2
[2] changing var :: ?i x5
[3] __primitive.gt &2 &4 :: y x3
[4] val 1 :: i x3
[5] __primitive.not &3 :: y x1
[6] __primitive.assert &1 5 :: i? x1
[7] return [6] -> 15
[8] __primitive.assert 14 &3 :: i? x1
[9] __primitive.add 1 &4 :: i x2.
[10] __primitive.lte &2 &11 :: y x1
[11] val 5 :: i x3
[12] __primitive.assert 13 10 :: i? x1
[13] __primitive.sub 2 4 :: i x1
[14] jump tests.decel:iterate 12 9 :: i x1
[15] return [8] -> 21
[16] __primitive.assert 20 3 :: i? x1
[17] __primitive.gt &2 &11 :: y x1
[18] __primitive.assert 19 17 :: i? x1
[19] __primitive.sub 2 11 :: i x1
[20] jump tests.decel:iterate 18 9 :: i x1
[21] return [16]

___ tests.decel_step (1 -> 1) x2 ___
[1] var :: ?i x4
[2] __primitive.lte &1 &3 :: y x1
[3] val 5 :: i x3
[4] __primitive.assert 5 2 <= 4 :: i? x1
[5] __primitive.sub 1 6 <= 4 :: i x1
[6] val 1 :: i x1
[7] return [4] -> 11
[8] __primitive.gt &1 &3 :: y x1
[9] __primitive.assert 10 8 >= 1 :: i? x1
[10] __primitive.sub 1 3 >= 1 :: i x1
[11] return [9]

___ tests.default_max (2 -> 1) x2 ___
[1] var :: ?i x2
[2] var :: ?i x2
[3] __primitive.lt &2 &1 :: y x1
[4] __primitive.assert 1 3 :: i? x2
[5] return [4] -> 7
[6] __primitive.unless 2 4 :: i x1
[7] return [6]

___ tests.del (0 -> 1) x2 ___
[1] val 1 :: i x1
[2] return [1] -> 4
[3] val 2 :: i x1
[4] return [3]

___ tests.disj_bound (1 -> 1) x2 ___
[1] var in [1, 10] :: ?i x4
[2] __primitive.gte &1 3 :: y x1
[3] val 1 :: i x1
[4] __primitive.assert &1 2 in [1, 10] :: i? x2
[5] __primitive.lte &4 6 :: y x1
[6] val 5 :: i x1
[7] __primitive.assert 4 5 in [1, 5] :: i? x1
[8] return [7] -> 15
[9] __primitive.gte &1 10 :: y x1
[10] val 8 :: i x1
[11] __primitive.assert 1 9 in [8, 10] :: i? x2
[12] __primitive.lte &11 13 :: y x1
[13] val 10 :: i x1
[14] __primitive.assert 11 12 in [8, 10] :: i? x1
[15] return [14]

___ tests.dotswap (4 -> 1) row ___
[1] var :: ?l x1
[2] var :: ?l x1
[3] var :: ?l x1
[4] var :: ?l x1
[5] __primitive.compose 2 1 :: l x1
[6] __primitive.compose 7 4 :: l x1
[7] __primitive.compose 5 3 :: l x1
[8] return [6]

___ tests.drop_loop (2 -> 1) ___
[1] var :: ?i x1
[2] var :: ?a x1
[3] jump tests.drop_loop:iterate 1 2 :: a x1
[4] return [3]

___ tests.drop_loop:iterate (2 -> 1) x2 rec ___
[1] var :: ?a x2
[2] changing var :: ?i x2
[3] __primitive.gt &2 4 :: y x2
[4] val 0 :: i x1
[5] __primitive.not &3 :: y x1
[6] __primitive.assert &1 5 :: a? x1
[7] return [6] -> 12
[8] __primitive.assert 11 3 :: a? x1
[9] __primitive.sub 2 10 :: i x1
[10] val 1 :: i x1
[11] jump tests.drop_loop:iterate 9 1 :: a x1
[12] return [8]

___ tests.drop_loop1 (1 -> 1) ___
[1] var :: ?i x1
[2] jump tests.drop_loop1:iterate 1 :: i x1
[3] return [2]

___ tests.drop_loop1:iterate (1 -> 1) x2 rec ___
[1] changing var :: ?i x3
[2] __primitive.gt &1 3 :: y x2
[3] val 0 :: i x1
[4] __primitive.not &2 :: y x1
[5] __primitive.assert &1 4 :: i? x1
[6] return [5] -> 11
[7] __primitive.assert 10 2 :: i? x1
[8] __primitive.sub 1 9 :: i x1
[9] val 1 :: i x1
[10] jump tests.drop_loop1:iterate 8 :: i x1
[11] return [7]

___ tests.drop_loop2 (2 -> 1) ___
[1] var :: ?i x1
[2] var :: ?a x1
[3] jump tests.drop_loop2:iterate 1 2 :: l x1
[4] return [3]

___ tests.drop_loop2:iterate (2 -> 1) x2 rec ___
[1] var :: ?a x2
[2] changing var :: ?i x3
[3] __primitive.gt &2 4 :: y x2
[4] val 0 :: i x1
[5] __primitive.not &3 :: y x3
[6] __primitive.assert &2 &5 :: i? x1
[7] __primitive.assert &1 &5 :: a? x1
[8] __primitive.quote 7 6 :: l x1
[9] __primitive.assert 8 5 :: l? x1
[10] return [9] -> 15
[11] __primitive.assert 14 3 :: l? x1
[12] __primitive.sub 2 13 :: i x1
[13] val 1 :: i x1
[14] jump tests.drop_loop2:iterate 12 1 :: l x1
[15] return [11]

___ tests.drop_loop3 (3 -> 2) ___
[1] var :: ?i x1
[2] var :: ?a x1
[3] var :: ?a x1
[4] jump tests.drop_loop3:iterate 1 2 3 -> 6 :: a x2
[6] __primitive.dep 4 :: a x1
[7] return [4 6]

___ tests.drop_loop3:iterate (3 -> 2) x2 rec ___
[1] var :: ?a x2
[2] var :: ?a x2
[3] changing var :: ?i x2
[4] __primitive.gt &3 5 :: y x3
[5] val 0 :: i x1
[6] __primitive.not &4 :: y x2
[7] __primitive.assert &2 &6 :: a? x1
[8] __primitive.assert &1 6 :: a? x1
[9] return [8 7] -> 17
[10] __primitive.assert 13 &4 :: a? x1
[11] __primitive.sub 3 12 :: i x1
[12] val 1 :: i x1
[13] jump tests.drop_loop3:iterate 11 2 1 -> 16 :: a x2
[15] __primitive.assert 16 4 :: a? x1
[16] __primitive.dep 13 :: a x1
[17] return [10 15]

___ tests.drop_loop4 (4 -> 3) ___
[1] var :: ?i x1
[2] var :: ?a x1
[3] var :: ?a x1
[4] var :: ?a x1
[5] jump tests.drop_loop4:iterate 1 2 3 4 -> 7 8 :: a x3
[7] __primitive.dep 5 :: a x1
[8] __primitive.dep 5 :: a x1
[9] return [8 7 5]

___ tests.drop_loop4:iterate (4 -> 3) x2 rec ___
[1] var :: ?a x2
[2] var :: ?a x2
[3] var :: ?a x2
[4] changing var :: ?i x2
[5] __primitive.gt &4 6 :: y x4
[6] val 0 :: i x1
[7] __primitive.not &5 :: y x3
[8] __primitive.assert &3 &7 :: a? x1
[9] __primitive.assert &2 &7 :: a? x1
[10] __primitive.assert &1 7 :: a? x1
[11] return [10 9 8] -> 22
[13] __primitive.assert 16 &5 :: a? x1
[14] __primitive.sub 4 15 :: i x1
[15] val 1 :: i x1
[16] jump tests.drop_loop4:iterate 14 3 2 1 -> 19 21 :: a x3
[18] __primitive.assert 19 &5 :: a? x1
[19] __primitive.dep 16 :: a x1
[20] __primitive.assert 21 5 :: a? x1
[21] __primitive.dep 16 :: a x1
[22] return [13 18 20]

___ tests.drop_loop5 (1 -> 1) ___
[1] var :: ?i x1
[2] jump tests.drop_loop5:iterate 1 :: i x1
[3] return [2]

___ tests.drop_loop5:iterate (1 -> 1) x2 rec ___
[1] changing var :: ?i x3
[2] __primitive.gt &1 3 :: y x2
[3] val 0 :: i x1
[4] __primitive.not &2 :: y x1
[5] __primitive.assert &1 4 :: i? x1
[6] return [5] -> 11
[7] __primitive.assert 10 2 :: i? x1
[8] __primitive.sub 1 9 :: i x1
[9] val 1 :: i x1
[10] jump tests.drop_loop5:iterate 8 :: i x1
[11] return [7]

___ tests.drop_loop6 (1 -> 1) ___
[1] var :: ?i x1
[2] val 7 :: i x1
[3] jump tests.drop_loop6:iterate 2 1 :: i x1
[4] return [3]

___ tests.drop_loop6:iterate (2 -> 1) x2 rec ___
[1] var :: ?i x2
[2] changing var :: ?i x3
[3] __primitive.gt &2 4 :: y x2
[4] val 0 :: i x1
[5] __primitive.not &3 :: y x1
[6] __primitive.assert &2 5 :: i? x1
[7] return [6] -> 11
[8] __primitive.assert 10 3 :: i? x1
[9] __primitive.sub 2 &1 :: i x1
[10] jump tests.drop_loop6:iterate 9 1 :: i x1
[11] return [8]

___ tests.dup_map (1 -> 1) ___
[1] var :: ?l x1
[2] jump tests.dup_map:map 1 :: l x1
[3] return [2]

___ tests.dup_map:map (1 -> 1) rec row ___
[1] changing var :: ?l x1
[2] __primitive.ap 1 -> 3 :: l? x2
[3] __primitive.dep 2 :: i x2
[4] jump tests.dup_map:map 2 :: l x1
[5] __primitive.pushr 4 &3 3 :: l x1
[6] return [5]

___ tests.either_test (2 -> 1) ___
[1] var :: ?l x1
[2] var :: ?l x1
[3] __primitive.compose 2 1 -> 4 :: v? x1
[4] __primitive.dep 3 :: a x1
[5] return [4]

___ tests.empty_assert (3 -> 1) ___
[1] var :: ?y x1
[2] var :: ?v x0
[3] var :: ?a x1
[4] __primitive.assert 3 1 :: a? x1
[5] return [4]

___ tests.ext_cos (1 -> 1) ___
[1] var :: ?d x1
[2] __primitive.external 1 3 :: d x1
[3] val "@math.h:cos" :: s x1
[4] return [2]

___ tests.f11 (1 -> 1) ___
[1] var :: ?l x1
[2] __primitive.ap 1 -> 3 :: l? x2
[3] __primitive.dep 2 :: l x1
[4] __primitive.ap 2 3 :: l x1
[5] return [4]

___ tests.f12 (1 -> 1) x2 ___
[1] var :: ?a x2
[2] __primitive.seq 3 1 in [1, 4] :: i x1
[3] val 3 :: i x1
[4] return [2] -> 7
[5] val 4 :: i x1
[6] __primitive.seq 5 1 is 4 :: i x1
[7] return [6]

___ tests.f13 (2 -> 2) ___
[1] var :: ?a x1
[2] var :: ?l x1
[3] __primitive.seq 5 1 :: i x1
[4] __primitive.ap 2 -> 5 :: l? x2
[5] __primitive.dep 4 :: i x1
[6] __primitive.add 3 7 :: i x1
[7] val 1 :: i x1
[8] return [4 6]

___ tests.f14 (3 -> 2) ___
[1] var :: ?l x2
[2] var :: ?l x1
[3] var :: ?a x1
[4] __primitive.ap 3 &1 -> 5 :: v? x1
[5] __primitive.dep 4 :: a x1
[6] __primitive.compose 2 1 -> 7 :: v? x1
[7] __primitive.dep 6 :: a x1
[8] return [7 5]

___ tests.f15 (1 -> 1) ___
[1] var :: ?l x1
[2] jump tests.f15:quote 1 :: l x1
[3] return [2]

___ tests.f15:quote (2 -> 1) ___
[1] var :: ?l x1
[2] var :: ?i x1
[3] __primitive.add 2 4 :: i x1
[4] val 1 :: i x1
[5] __primitive.ap 3 1 :: l x1
[6] return [5]

___ tests.f16 (0 -> 1) ___
[1] jump tests.f16:quote :: l x1
[2] return [1]

___ tests.f16:quote (1 -> 1) ___
[1] var :: ?i x1
[2] __primitive.add 1 3 :: i x1
[3] val 1 :: i x1
[4] __primitive.ap 2 5 :: l x1
[5] [] :: l x1
[6] return [4]

___ tests.f17 (2 -> 1) x2 ___
[1] var :: ?a x2
[2] var :: ?a x2
[3] __primitive.seq 4 &2 :: l x1
[4] __primitive.quote 2 :: l x1
[5] return [3] -> 8
[6] __primitive.seq 7 &1 :: l x1
[7] __primitive.quote 1 :: l x1
[8] return [6]

___ tests.f18 (1 -> 1) ___
[1] var :: ?l x1
[2] jump tests.f18:map 1 :: l x1
[3] return [2]

___ tests.f18:map (1 -> 1) rec row ___
[1] changing var :: ?l x1
[2] __primitive.ap 1 -> 3 :: l? x2
[3] __primitive.dep 2 :: i x2
[4] __primitive.seq 7 &3 :: l x1
[5] tests.f18:map 2 :: l x1
[6] __primitive.pushr 5 4 :: l x1
[7] jump tests.f18:map:quote 3 :: l x1
[8] return [6]

___ tests.f18:map:quote (2 -> 1) ___
[1] var :: ?i x1
[2] var :: ?i x1
[3] __primitive.add 2 1 :: i x1
[4] __primitive.ap 3 5 :: l x1
[5] [] :: l x1
[6] return [4]

___ tests.f19 (1 -> 1) ___
[1] var :: ?l x1
[2] jump tests.f19:map 1 :: l x1
[3] return [2]

___ tests.f19:map (1 -> 1) rec row ___
[1] changing var :: ?l x1
[2] __primitive.ap 1 -> 3 :: l? x2
[3] __primitive.dep 2 :: i x1
[4] __primitive.add 5 3 :: i x1
[5] val 1 :: i x1
[6] jump tests.f19:map 2 :: l x1
[7] __primitive.pushr 6 4 :: l x1
[8] return [7]

___ tests.f19b (1 -> 1) ___
[1] var :: ?l x1
[2] jump tests.f19b:map 1 :: l x1
[3] return [2]

___ tests.f19b:map (1 -> 1) rec row ___
[1] changing var :: ?l x1
[2] __primitive.ap 1 -> 3 :: l? x2
[3] __primitive.dep 2 :: i x1
[4] __primitive.add 5 3 :: i x1
[5] val 1 :: i x1
[6] jump tests.f19b:map 2 :: l x1
[7] __primitive.pushr 6 4 :: l x1
[8] return [7]

___ tests.f2 (3 -> 1) ___
[1] var :: ?l x1
[2] var :: ?a x1
[3] var :: ?a x1
[4] __primitive.ap 3 2 1 -> 6 7 :: l? x3
[6] __primitive.dep 4 :: i x1
[7] __primitive.dep 4 :: i x1
[8] __primitive.add 7 9 :: i x1
[9] val 1 :: i x1
[10] __primitive.ap 8 4 -> 11 :: v x1
[11] __primitive.dep 10 :: i x1
[12] __primitive.add 6 11 :: i x1
[13] return [12]

___ tests.f20a (1 -> 1) x2 rec ___
[1] changing var :: ?l x2
[2] __primitive.ap &1 -> 3 :: l? x2
[3] __primitive.dep 2 :: i x1
[4] __primitive.eq 3 5 :: y x2
[5] val 0 :: i x1
[6] __primitive.not &4 :: y x1
[7] __primitive.assert 8 6 :: a? x1
[8] jump tests.f20b 1 :: a x1
[9] return [7] -> 12
[10] __primitive.assert 11 4 :: a? x1
[11] jump tests.f20a 2 :: a x1
[12] return [10]

___ tests.f20b (1 -> 1) x3 rec ___
[1] changing var :: ?l x2
[2] __primitive.ap &1 -> 3 :: l? x2
[3] __primitive.dep 2 :: i x4
[4] __primitive.eq &3 5 :: y x1
[5] val 0 :: i x1
[6] __primitive.ap 4 8 X -> 9 11 :: v? x2
[8] __primitive.ap 1 -> X :: l? x1
[9] __primitive.dep 6 :: y x1
[10] __primitive.assert 11 9 :: a? x1
[11] __primitive.dep 6 :: a x1
[12] return [10] -> 16
[13] __primitive.gt &3 &14 :: y x1
[14] val 1 :: i x2
[15] __primitive.assert &3 13 :: i? x1
[16] return [15] -> 20
[17] __primitive.eq 3 14 :: y x1
[18] __primitive.assert 19 17 :: a? x1
[19] jump tests.f20b 2 :: a x1
[20] return [18]

___ tests.f21 (2 -> 1) ___
[1] var :: ?l x1
[2] var :: ?l x1
[3] val 1 :: i x1
[4] jump tests.f21:interleave_with 2 1 3 :: l x1
[5] return [4]

___ tests.f21:interleave_with (3 -> 1) x2 rec row ___
[1] changing var :: ?i x6
[2] changing var :: ?l x2
[3] changing var :: ?l x2
[4] __primitive.seq 8 &1 :: i x3
[5] __primitive.ap &2 -> 6 :: l? x2
[6] __primitive.dep 5 :: i x1
[7] __primitive.mul &1 6 :: i x2
[8] __primitive.mul &7 9 :: i x1
[9] val 10 :: i x2
[10] __primitive.seq 14 &4 :: l x1
[11] __primitive.seq 13 &4 :: l x1
[12] __primitive.seq 7 1 :: i x1
[13] jump tests.f21:interleave_with 3 5 12 :: l x1
[14] __primitive.pushr 11 4 :: l x1
[15] return [10] -> 26
[16] __primitive.seq 20 &1 :: i x3
[17] __primitive.ap 3 -> 18 :: l? x2
[18] __primitive.dep 17 :: i x1
[19] __primitive.add &1 18 :: i x2
[20] __primitive.mul &19 9 :: i x1
[21] __primitive.seq 25 &16 :: l x1
[22] __primitive.seq 24 &16 :: l x1
[23] __primitive.seq 19 1 :: i x1
[24] jump tests.f21:interleave_with 17 2 23 :: l x1
[25] __primitive.pushr 22 16 :: l x1
[26] return [21]

___ tests.f21b (2 -> 1) ___
[1] var :: ?l x1
[2] var :: ?l x1
[3] jump tests.f21b:interleave 2 1 :: l x1
[4] return [3]

___ tests.f21b:interleave (2 -> 1) x2 rec row ___
[1] changing var :: ?l x2
[2] changing var :: ?l x2
[3] __primitive.ap &1 -> 4 :: l? x2
[4] __primitive.dep 3 :: a x1
[5] __primitive.seq 8 4 is 1 :: i x1
[6] jump tests.f21b:interleave 2 3 :: l x1
[7] __primitive.pushr 6 5 :: l x1
[8] val 1 :: i x1
[9] return [7] -> 16
[10] __primitive.ap 2 -> 11 :: l? x2
[11] __primitive.dep 10 :: a x1
[12] __primitive.seq 15 11 is 0 :: i x1
[13] jump tests.f21b:interleave 10 1 :: l x1
[14] __primitive.pushr 13 12 :: l x1
[15] val 0 :: i x1
[16] return [14]

___ tests.f21c (1 -> 1) ___
[1] var :: ?l x1
[2] val 0 :: i x1
[3] jump tests.f21c:foldr:iterate 2 1 :: i x1
[4] return [3]

___ tests.f21c:foldr:iterate (2 -> 1) x2 rec ___
[1] changing var :: ?l x1
[2] changing var :: ?i x2
[3] __primitive.ap 1 -> 4 :: l? x2
[4] __primitive.dep 3 :: i x3
[5] __primitive.seq 7 &4 :: v x1
[6] __primitive.add 2 4 :: i x1
[7] jump tests.f21c:foldr:iterate 6 3 :: v x1
[8] return [5] -> 12
[9] val Something :: y x1
[10] __primitive.seq 9 4 :: y x1
[11] __primitive.unless 2 10 :: i x1
[12] return [11]

___ tests.f22 (1 -> 1) ___
[1] var :: ?l x1
[2] jump tests.f22:map 1 :: l x1
[3] return [2]

___ tests.f22:map (1 -> 1) x2 rec row ___
[1] changing var :: ?l x1
[2] __primitive.ap 1 -> 3 :: l? x2
[3] __primitive.dep 2 :: l x3
[4] __primitive.seq 9 &3 :: l x1
[5] __primitive.ap &3 -> 6 7 :: l? x4
[6] __primitive.dep 5 :: i x4
[7] __primitive.dep 5 :: i x4
[8] __primitive.gt &6 &7 :: y x4
[9] __primitive.assert 15 &8 :: l? x1
[10] jump tests.f22:map 2 :: l x2.
[11] __primitive.pushr &10 4 :: l x1
[12] __primitive.assert &7 &8 :: i? x1
[13] __primitive.assert &6 &8 :: i? x1
[14] __primitive.assert &5 8 :: l? x1
[15] __primitive.pushr 14 13 12 :: l x1
[16] return [11] -> 25
[17] __primitive.seq 19 3 :: l x1
[18] __primitive.gt &7 &6 :: y x4
[19] __primitive.assert 24 &18 :: l? x1
[20] __primitive.pushr 10 17 :: l x1
[21] __primitive.assert 6 &18 :: i? x1
[22] __primitive.assert 7 &18 :: i? x1
[23] __primitive.assert 5 18 :: l? x1
[24] __primitive.pushr 23 22 21 :: l x1
[25] return [20]

___ tests.f22a (1 -> 1) x2 row ___
[1] var :: ?l x1
[2] __primitive.ap 1 -> 3 4 :: l? x4
[3] __primitive.dep 2 :: i x4
[4] __primitive.dep 2 :: i x4
[5] __primitive.gt &3 &4 :: y x4
[6] __primitive.assert &4 &5 :: i? x1
[7] __primitive.assert &3 &5 :: i? x1
[8] __primitive.assert &2 &5 :: l? x1
[9] __primitive.pushr 8 7 6 :: l x1
[10] __primitive.assert 9 5 :: l? x1
[11] return [10] -> 18
[12] __primitive.gt &4 &3 :: y x4
[13] __primitive.assert 3 &12 :: i? x1
[14] __primitive.assert 4 &12 :: i? x1
[15] __primitive.assert 2 &12 :: l? x1
[16] __primitive.pushr 15 14 13 :: l x1
[17] __primitive.assert 16 12 :: l? x1
[18] return [17]

___ tests.f22b (1 -> 1) ___
[1] var :: ?l x1
[2] jump tests.f22b:map 1 :: l x1
[3] return [2]

___ tests.f22b:map (1 -> 1) x2 rec row ___
[1] changing var :: ?l x1
[2] __primitive.ap 1 -> 3 :: l? x2
[3] __primitive.dep 2 :: l x4
[4] __primitive.seq 9 &3 :: l x1
[5] __primitive.ap &3 -> 6 7 :: l? x3
[6] __primitive.dep 5 :: i x2
[7] __primitive.dep 5 :: i x2
[8] __primitive.gt &6 &7 :: y x1
[9] __primitive.assert 12 8 :: l? x1
[10] jump tests.f22b:map 2 :: l x2.
[11] __primitive.pushr 10 4 :: l x1
[12] __primitive.pushr 5 6 7 :: l x1
[13] return [11] -> 22
[14] __primitive.seq 19 &3 :: l x1
[15] __primitive.ap 3 -> 17 16 :: l? x3
[16] __primitive.dep 15 :: i x2
[17] __primitive.dep 15 :: i x2
[18] __primitive.gt &16 &17 :: y x1
[19] __primitive.assert 21 18 :: l? x1
[20] __primitive.pushr 10 14 :: l x1
[21] __primitive.pushr 15 16 17 :: l x1
[22] return [20]

___ tests.f23 (2 -> 1) ___
[1] var :: ?l x1
[2] var :: ?l x1
[3] jump tests.f23:zip 2 1 :: l x1
[4] return [3]

___ tests.f23:zip (2 -> 1) x2 rec row ___
[1] changing var :: ?l x1
[2] changing var :: ?l x1
[3] __primitive.ap 2 -> 4 :: l? x2
[4] __primitive.dep 3 :: i x6
[5] __primitive.ap 1 -> 6 :: l? x2
[6] __primitive.dep 5 :: i x6
[7] __primitive.seq 8 &4 :: l x1
[8] __primitive.seq 14 &6 :: l x1
[9] __primitive.lte &4 &6 :: y x1
[10] __primitive.assert &6 9 :: i? x1
[11] __primitive.seq 12 4 :: l x2.
[12] __primitive.seq 13 6 :: l x1.
[13] jump tests.f23:zip 3 5 :: l x1.
[14] __primitive.pushr 11 10 :: l x1
[15] return [7] -> 21
[16] __primitive.lte &6 &4 :: y x1
[17] __primitive.assert &4 16 :: i? x1
[18] __primitive.pushr 11 17 :: l x1
[19] __primitive.seq 18 6 :: l x1
[20] __primitive.seq 19 4 :: l x1
[21] return [20]

___ tests.f24 (1 -> 1) ___
[1] var :: ?l x1
[2] jump tests.f24:map 1 :: l x1
[3] return [2]

___ tests.f24:map (1 -> 1) rec row ___
[1] changing var :: ?l x1
[2] __primitive.ap 1 -> 3 :: l? x2
[3] __primitive.dep 2 :: l x2
[4] __primitive.seq 12 &3 :: l x1
[5] tests.f24:map 2 :: l x1
[6] __primitive.pushr 5 4 :: l x1
[7] __primitive.ap 3 -> 8 9 :: l? x3
[8] __primitive.dep 7 :: i x1
[9] __primitive.dep 7 :: i x2
[10] __primitive.lte 8 &9 :: y x1
[11] __primitive.assert 9 10 :: i? x1
[12] __primitive.pushr 7 11 :: l x1
[13] return [6]

___ tests.f25 (1 -> 1) ___
[1] var :: ?l x1
[2] jump tests.f25:map 1 :: l x1
[3] return [2]

___ tests.f25:map (1 -> 1) rec row ___
[1] changing var :: ?l x1
[2] __primitive.ap 1 -> 3 :: l? x2
[3] __primitive.dep 2 :: l x2
[4] __primitive.seq 5 &3 :: l x1
[5] tests.f25:map:map 3 :: l x1
[6] jump tests.f25:map 2 :: l x1
[7] __primitive.pushr 6 4 :: l x1
[8] return [7]

___ tests.f25:map:map (1 -> 1) rec row ___
[1] changing var :: ?l x1
[2] __primitive.ap 1 -> 3 :: l? x2
[3] __primitive.dep 2 :: i x2
[4] __primitive.seq 5 &3 :: i x1
[5] __primitive.add 3 6 :: i x1
[6] val 1 :: i x1
[7] jump tests.f25:map:map 2 :: l x1
[8] __primitive.pushr 7 4 :: l x1
[9] return [8]

___ tests.f25b (1 -> 1) ___
[1] var :: ?l x1
[2] jump tests.f25b:map 1 :: l x1
[3] return [2]

___ tests.f25b:map (1 -> 1) rec row ___
[1] changing var :: ?l x1
[2] __primitive.ap 1 -> 3 :: l? x2
[3] __primitive.dep 2 :: l x2
[4] __primitive.seq 5 &3 :: l x1
[5] tests.f25b:map:filter 3 :: l x1
[6] jump tests.f25b:map 2 :: l x1
[7] __primitive.pushr 6 4 :: l x1
[8] return [7]

___ tests.f25b:map:filter (1 -> 1) rec row ___
[1] changing var :: ?l x1
[2] tests.f25b:map:filter:next_match 1 -> 3 :: l x2
[3] __primitive.dep 2 :: i x1
[4] jump tests.f25b:map:filter 2 :: l x1
[5] __primitive.pushr 4 3 :: l x1
[6] return [5]

___ tests.f25b:map:filter:next_match (1 -> 2) x2 rec ___
[1] changing var :: ?l x1
[2] __primitive.ap 1 -> 3 :: l? x3
[3] __primitive.dep 2 :: i x2
[4] __primitive.bitand &3 &5 in [0, 1] :: i x1
[5] val 1 :: i x2
[6] __primitive.eq 4 5 :: y x3
[7] __primitive.assert 3 &6 :: i? x1
[8] __primitive.assert &2 &6 :: l? x1
[9] return [8 7] -> 15
[10] __primitive.not 6 :: y x2
[11] __primitive.assert 13 &10 :: i? x1
[12] jump tests.f25b:map:filter:next_match 2 -> 13 :: l x2
[13] __primitive.dep 12 :: i x1
[14] __primitive.assert 12 10 :: l? x1
[15] return [14 11]

___ tests.f26 (2 -> 2) ___
[1] var :: ?l x1
[2] var :: ?l x1
[3] tests.f26:interleave 2 1 4b :: l x2
[4] list.unzip_either:map &3 :: l x1
[5] jump list.unzip_either:map_1 3 :: l x1
[6] return [5 4]

___ tests.f26:interleave (2 -> 1) x2 rec row ___
[1] changing var :: ?l x2
[2] changing var :: ?l x2
[3] __primitive.ap &1 -> 4 :: l? x2
[4] __primitive.dep 3 :: a x2
[5] __primitive.seq 8 &4 3b :: l x1
[6] tests.f26:interleave 2 3 :: l x1
[7] __primitive.pushr 6 5 3b :: l x1
[8] __primitive.quote 4 9 3b :: l x1
[9] val Right :: y x1
[10] return [7] -> 18
[11] __primitive.ap 2 -> 12 :: l? x2
[12] __primitive.dep 11 :: a x2
[13] __primitive.seq 16 &12 4b :: l x1
[14] tests.f26:interleave 11 1 :: l x1
[15] __primitive.pushr 14 13 4b :: l x1
[16] __primitive.quote 12 17 4b :: l x1
[17] val Left :: y x1
[18] return [15]

___ tests.f29l (1 -> 2) ___
[1] var :: ?l x2
[2] tests.f29l:unzip_either:map &1 :: l x1
[3] jump tests.f29l:unzip_either:map_1_1 1 :: l x1
[4] return [3 2]

___ tests.f29l:unzip_either:map (1 -> 1) rec row ___
[1] changing var :: ?l x1
[2] tests.f29l:unzip_either:map:next_match 1 -> 3 :: v x2
[3] __primitive.dep 2 :: l x2
[4] __primitive.seq 6 &3 :: a x1
[5] __primitive.ap 3 -> 6 X :: v? x1
[6] __primitive.dep 5 :: a x1
[7] jump tests.f29l:unzip_either:map 2 :: l x1
[8] __primitive.pushr 7 4 :: l x1
[9] return [8]

___ tests.f29l:unzip_either:map:next_match (1 -> 2) rec ___
[1] changing var :: ?l x1
[2] __primitive.ap 1 -> 3 :: l? x2
[3] __primitive.dep 2 :: a x2
[4] __primitive.seq 6 &3 :: v x1
[5] jump tests.f29l:unzip_either:map:next_match 2 -> 6 :: v x2
[6] __primitive.dep 5 :: v x1
[7] __primitive.seq 5 3 :: v x1
[8] return [7 4]

___ tests.f29l:unzip_either:map_1_1 (1 -> 1) rec row ___
[1] changing var :: ?l x1
[2] tests.f29l:unzip_either:map_1_1:next_match 1 -> 3 :: l x2
[3] __primitive.dep 2 :: l x2
[4] __primitive.seq 6 &3 :: a x1
[5] __primitive.ap 3 -> 6 X :: v? x1
[6] __primitive.dep 5 :: a x1
[7] jump tests.f29l:unzip_either:map_1_1 2 :: l x1
[8] __primitive.pushr 7 4 :: l x1
[9] return [8]

___ tests.f29l:unzip_either:map_1_1:next_match (1 -> 2) ___
[1] var :: ?l x1
[2] __primitive.ap 1 -> 3 :: l? x2
[3] __primitive.dep 2 :: a x3
[4] __primitive.seq 6 &3 :: y x1
[5] __primitive.quote &3 4 4b :: l x1
[6] val Left :: y x1
[7] __primitive.seq 5 3 4b :: l x1
[8] return [2 7]

___ tests.f29r (1 -> 2) ___
[1] var :: ?l x2
[2] tests.f29r:unzip_either:map &1 :: l x1
[3] jump tests.f29r:unzip_either:map_1_1 1 :: l x1
[4] return [3 2]

___ tests.f29r:unzip_either:map (1 -> 1) rec row ___
[1] changing var :: ?l x1
[2] tests.f29r:unzip_either:map:next_match 1 -> 3 :: l x2
[3] __primitive.dep 2 :: l x2
[4] __primitive.seq 6 &3 :: a x1
[5] __primitive.ap 3 -> 6 X :: v? x1
[6] __primitive.dep 5 :: a x1
[7] jump tests.f29r:unzip_either:map 2 :: l x1
[8] __primitive.pushr 7 4 :: l x1
[9] return [8]

___ tests.f29r:unzip_either:map:next_match (1 -> 2) ___
[1] var :: ?a x1
[2] __primitive.ap 1 -> 3 :: l? x2
[3] __primitive.dep 2 :: a x3
[4] __primitive.seq 6 &3 :: y x1
[5] __primitive.quote &3 4 3b :: l x1
[6] val Right :: y x1
[7] __primitive.seq 5 3 3b :: l x1
[8] return [2 7]

___ tests.f29r:unzip_either:map_1_1 (1 -> 1) rec row ___
[1] changing var :: ?l x1
[2] tests.f29r:unzip_either:map_1_1:next_match 1 -> 3 :: v x2
[3] __primitive.dep 2 :: l x2
[4] __primitive.seq 6 &3 :: a x1
[5] __primitive.ap 3 -> 6 X :: v? x1
[6] __primitive.dep 5 :: a x1
[7] jump tests.f29r:unzip_either:map_1_1 2 :: l x1
[8] __primitive.pushr 7 4 :: l x1
[9] return [8]

___ tests.f29r:unzip_either:map_1_1:next_match (1 -> 2) rec ___
[1] changing var :: ?l x1
[2] __primitive.ap 1 -> 3 :: l? x2
[3] __primitive.dep 2 :: a x2
[4] __primitive.seq 6 &3 :: v x1
[5] jump tests.f29r:unzip_either:map_1_1:next_match 2 -> 6 :: v x2
[6] __primitive.dep 5 :: v x1
[7] __primitive.seq 5 3 :: v x1
[8] return [7 4]

___ tests.f30 (2 -> 1) x2 ___
[1] var :: ?i x2
[2] var :: ?a x1
[3] __primitive.div &4 &1 :: i? x1
[4] val 1 :: i x2
[5] __primitive.eq 3 4 :: y x2
[6] __primitive.assert 1 &5 :: i? x1
[7] return [6] -> 10
[8] __primitive.not 5 :: y x1
[9] __primitive.assert 2 8 :: a? x1
[10] return [9]

___ tests.f30b (2 -> 1) x2 ___
[1] var :: ?i x2
[2] var :: ?a x1
[3] __primitive.eq &1 4 :: y x2
[4] val 1 :: i x1
[5] __primitive.assert 1 &3 :: i? x1
[6] return [5] -> 9
[7] __primitive.not 3 :: y x1
[8] __primitive.assert 2 7 :: a? x1
[9] return [8]

___ tests.f31 (3 -> 1) ___
[1] var :: ?l x1
[2] var :: ?l x1
[3] var :: ?i x1
[4] jump tests.f31:map_with 2 1 3 4b :: l x1
[5] return [4]

___ tests.f31:map_with (3 -> 1) x2 rec row ___
[1] changing var :: ?i x2
[2] changing var :: ?l x1
[3] var :: ?l x3
[4] __primitive.ap 2 -> 5 :: l? x3
[5] __primitive.dep 4 :: i x2
[6] __primitive.seq 10 &5 4b :: l x1
[7] __primitive.add 1 5 :: i x2
[8] tests.f31:map_with 3 4 &7 :: l x1
[9] __primitive.pushr 8 6 4b :: l x1
[10] __primitive.quote 7 11 4b :: l x1
[11] val Left :: y x1
[12] return [9] -> 21
[13] __primitive.ap &3 -> 14 :: v? x1
[14] __primitive.dep 13 :: i x2
[15] __primitive.seq 19 &14 3b :: l x1
[16] __primitive.add 1 14 :: i x2
[17] tests.f31:map_with 3 4 &16 :: l x1
[18] __primitive.pushr 17 15 3b :: l x1
[19] __primitive.quote 16 20 3b :: l x1
[20] val Right :: y x1
[21] return [18]

___ tests.f31b (3 -> 1) ___
[1] var :: ?l x1
[2] var :: ?l x1
[3] var :: ?i x1
[4] jump tests.f31b:map_with 2 1 3 :: l x1
[5] return [4]

___ tests.f31b:map_with (3 -> 1) x2 rec row ___
[1] changing var :: ?i x2
[2] changing var :: ?l x1
[3] var :: ?l x3
[4] __primitive.ap 2 -> 5 :: l? x3
[5] __primitive.dep 4 :: i x1
[6] __primitive.add 1 5 :: i x2
[7] jump tests.f31b:map_with 3 4 &6 :: l x1
[8] __primitive.pushr 7 6 :: l x1
[9] return [8] -> 15
[10] __primitive.ap &3 -> 11 :: v? x1
[11] __primitive.dep 10 :: i x1
[12] __primitive.add 1 11 :: i x2
[13] jump tests.f31b:map_with 3 4 &12 :: l x1
[14] __primitive.pushr 13 12 :: l x1
[15] return [14]

___ tests.f31c (3 -> 2) ___
[1] var :: ?l x1
[2] var :: ?l x1
[3] var :: ?i x2
[4] tests.f31c:map_with 1 &3 :: l x1
[5] jump tests.f31c:map_with_1 2 3 :: l x1
[6] return [5 4]

___ tests.f31c:map_with (2 -> 1) rec row ___
[1] changing var :: ?i x1
[2] changing var :: ?l x1
[3] __primitive.ap 2 -> 4 :: l? x2
[4] __primitive.dep 3 :: i x1
[5] __primitive.add 1 4 :: i x2
[6] jump tests.f31c:map_with 3 &5 :: l x1
[7] __primitive.pushr 6 5 :: l x1
[8] return [7]

___ tests.f31c:map_with_1 (2 -> 1) rec row ___
[1] changing var :: ?i x1
[2] changing var :: ?l x1
[3] __primitive.ap 2 -> 4 :: l? x2
[4] __primitive.dep 3 :: i x1
[5] __primitive.add 1 4 :: i x2
[6] jump tests.f31c:map_with_1 3 &5 :: l x1
[7] __primitive.pushr 6 5 :: l x1
[8] return [7]

___ tests.f32 (2 -> 1) ___
[1] var :: ?l x1
[2] var :: ?l x1
[3] jump tests.f32:map 2 1 :: l x1
[4] return [3]

___ tests.f32:map (2 -> 1) x2 rec row ___
[1] changing var :: ?l x1
[2] var :: ?l x2
[3] __primitive.ap 1 -> 4 :: l? x2
[4] __primitive.dep 3 :: i x2
[5] __primitive.seq 6 &4 :: i x1
[6] __primitive.add 4 7 :: i x1
[7] val 1 :: i x2
[8] jump tests.f32:map 2 3 :: l x2
[9] __primitive.pushr 8 5 :: l x1
[10] return [9] -> 16
[11] __primitive.ap 2 -> 12 :: v? x1
[12] __primitive.dep 11 :: i x2
[13] __primitive.add &12 7 :: i x1
[14] __primitive.seq 13 12 :: i x1
[15] __primitive.pushr 8 14 :: l x1
[16] return [15]

___ tests.f6 (3 -> 3) ___
[1] var :: ?a x1
[2] var :: ?a x1
[3] var :: ?a x1
[4] return [2 1 3]

___ tests.f7c (2 -> 1) ___
[1] var :: ?i x1
[2] var :: ?i x1
[3] jump tests.f7c:times:iterate 1 2 :: i x1
[4] return [3]

___ tests.f7c:times:iterate (2 -> 1) x2 rec ___
[1] changing var :: ?i x2
[2] changing var :: ?i x2
[3] __primitive.gt &2 4 :: y x2
[4] val 0 :: i x1
[5] __primitive.not &3 :: y x1
[6] __primitive.assert &1 5 :: i? x1
[7] return [6] -> 13
[8] __primitive.assert 12 3 :: i? x1
[9] __primitive.sub 2 &10 :: i x1
[10] val 1 :: i x2
[11] __primitive.add 1 10 :: i x1
[12] jump tests.f7c:times:iterate 9 11 :: i x1
[13] return [8]

___ tests.f8 (3 -> 1) ___
[1] var :: ?l x1
[2] var :: ?v x0
[3] var :: ?v x0
[4] __primitive.ap 1 -> 5 :: v? x1
[5] __primitive.dep 4 :: a x1
[6] return [5]

___ tests.f9 (2 -> 1) x3 ___
[1] var :: ?a x2
[2] var :: ?a x2
[3] return [2] -> 4
[4] return [1] -> 8
[5] __primitive.unless 7 2 is 3 :: i x1
[6] __primitive.unless 5 1 is 3 :: i x1
[7] val 3 :: i x1
[8] return [6]

___ tests.fact (1 -> 1) x2 rec ___
[1] changing var >= 1 :: ?i x4
[2] __primitive.eq &1 &3 :: y x1
[3] val 1 :: i x4
[4] __primitive.assert &3 2 is 1 :: i? x1
[5] return [4] -> 11
[6] __primitive.gt &1 &3 :: y x1
[7] __primitive.assert 10 6 :: i? x1
[8] __primitive.sub &1 3 >= 0 :: i x1
[9] tests.fact 8 :: i x1
[10] __primitive.mul 1 9 :: i x1
[11] return [7]

___ tests.failthru (3 -> 2) x2 ___
[1] var :: ?l x1
[2] var :: ?a x3
[3] var :: ?a x2
[4] __primitive.ap &3 &2 1 -> 7 6 :: v? x2
[6] __primitive.dep 4 :: a x1
[7] __primitive.dep 4 :: a x1
[8] return [7 6] -> 10
[9] __primitive.unless 3 &2 :: a x1
[10] return [9 2]

___ tests.fib (1 -> 1) x2 rec ___
[1] changing var :: ?i x4
[2] __primitive.lte &1 &3 :: y x1
[3] val 1 :: i x4
[4] __primitive.assert &1 2 :: i? x1
[5] return [4] -> 13
[6] __primitive.gt &1 &3 :: y x1
[7] __primitive.sub 1 &3 :: i x2
[8] __primitive.sub &7 3 :: i x1
[9] tests.fib 8 :: i x1
[10] tests.fib 7 :: i x1
[11] __primitive.add 9 10 :: i x1
[12] __primitive.assert 11 6 :: i? x1
[13] return [12]

___ tests.fibl (1 -> 1) ___
[1] var :: ?i x1
[2] __primitive.sub 1 &3 :: i x1
[3] val 1 :: i x2
[4] val 0 :: i x1
[5] jump tests.fibl:times:iterate 2 3 4 :: i x1
[6] return [5]

___ tests.fibl:times:iterate (3 -> 1) x2 rec ___
[1] changing var :: ?i x1
[2] changing var :: ?i x3
[3] changing var :: ?i x2
[4] __primitive.gt &3 5 :: y x2
[5] val 0 :: i x1
[6] __primitive.not &4 :: y x1
[7] __primitive.assert &2 6 :: i? x1
[8] return [7] -> 14
[9] __primitive.assert 13 4 :: i? x1
[10] __primitive.sub 3 11 :: i x1
[11] val 1 :: i x1
[12] __primitive.add 1 &2 :: i x1
[13] jump tests.fibl:times:iterate 10 12 2 :: i x1
[14] return [9]

___ tests.filter_step (3 -> 2) x2 ___
[1] var :: ?l x1
[2] var :: ?l x2
[3] var :: ?l x1
[4] __primitive.ap 3 -> 5 :: l? x3
[5] __primitive.dep 4 :: a x2
[6] __primitive.ap &5 1 -> 7 :: v? x1
[7] __primitive.dep 6 :: y x2
[8] __primitive.not &7 :: y x1
[9] __primitive.assert &2 8 :: l? x1
[10] return [4 9] -> 13
[11] __primitive.assert 12 7 :: l? x1
[12] __primitive.ap 5 2 :: l x1
[13] return [4 11]

___ tests.fuse_filter_map (1 -> 1) ___
[1] var :: ?l x1
[2] val 0 :: i x1
[3] jump tests.fuse_filter_map:map_with 1 2 :: l x1
[4] return [3]

___ tests.fuse_filter_map:map_with (2 -> 1) rec row ___
[1] changing var :: ?i x1
[2] changing var :: ?l x1
[3] tests.fuse_filter_map:map_with:next_match 2 -> 4 :: l x2
[4] __primitive.dep 3 :: i x1
[5] __primitive.add 1 4 :: i x2
[6] jump tests.fuse_filter_map:map_with 3 &5 :: l x1
[7] __primitive.pushr 6 5 :: l x1
[8] return [7]

___ tests.fuse_filter_map:map_with:next_match (1 -> 2) x2 rec ___
[1] changing var :: ?l x1
[2] __primitive.ap 1 -> 3 :: l? x3
[3] __primitive.dep 2 :: i x2
[4] __primitive.bitand &3 &5 in [0, 1] :: i x1
[5] val 1 :: i x2
[6] __primitive.eq 4 5 :: y x3
[7] __primitive.assert 3 &6 :: i? x1
[8] __primitive.assert &2 &6 :: l? x1
[9] return [8 7] -> 15
[10] __primitive.not 6 :: y x2
[11] __primitive.assert 13 &10 :: i? x1
[12] jump tests.fuse_filter_map:map_with:next_match 2 -> 13 :: l x2
[13] __primitive.dep 12 :: i x1
[14] __primitive.assert 12 10 :: l? x1
[15] return [14 11]

___ tests.fuse_filter_sum (1 -> 1) ___
[1] var :: ?l x1
[2] val 0 :: i x1
[3] jump tests.fuse_filter_sum:sum:foldr:iterate 2 1 :: i x1
[4] return [3]

___ tests.fuse_filter_sum:sum:foldr:iterate (2 -> 1) x2 rec ___
[1] changing var :: ?l x1
[2] changing var :: ?i x2
[3] tests.fuse_filter_sum:sum:foldr:iterate:next_match 1 -> 4 :: l x2
[4] __primitive.dep 3 :: i x3
[5] __primitive.seq 7 &4 :: v x1
[6] __primitive.add 4 2 :: i x1
[7] jump tests.fuse_filter_sum:sum:foldr:iterate 6 3 :: v x1
[8] return [5] -> 10
[9] __primitive.unless 2 4 :: i x1
[10] return [9]

___ tests.fuse_filter_sum:sum:foldr:iterate:next_match (1 -> 2) x2 rec ___
[1] changing var :: ?l x1
[2] __primitive.ap 1 -> 3 :: l? x3
[3] __primitive.dep 2 :: i x2
[4] __primitive.bitand &3 &5 in [0, 1] :: i x1
[5] val 1 :: i x2
[6] __primitive.eq 4 5 :: y x3
[7] __primitive.assert 3 &6 :: i? x1
[8] __primitive.assert &2 &6 :: l? x1
[9] return [8 7] -> 15
[10] __primitive.not 6 :: y x2
[11] __primitive.assert 13 &10 :: i? x1
[12] jump tests.fuse_filter_sum:sum:foldr:iterate:next_match 2 -> 13 :: l x2
[13] __primitive.dep 12 :: i x1
[14] __primitive.assert 12 10 :: l? x1
[15] return [14 11]

___ tests.fuse_filter_tail2 (1 -> 1) x2 ___
[1] var :: ?l x1
[2] __primitive.ap 1 -> 3 :: l? x2
[3] __primitive.dep 2 :: i x1
[4] __primitive.bitand 3 &5 in [0, 1] :: i x1
[5] val 1 :: i x2
[6] __primitive.eq 4 5 :: y x2
[7] __primitive.assert &8 &6 :: l? x1
[8] jump tests.fuse_filter_tail2:filter2 2 :: l x2.
[9] return [7] -> 13
[10] __primitive.not 6 :: y x1
[11] __primitive.assert 12 10 :: l? x1
[12] __primitive.ap 8 -> X :: l? x1
[13] return [11]

___ tests.fuse_filter_tail2:filter2 (1 -> 1) x2 rec row ___
[1] changing var :: ?l x1
[2] __primitive.ap 1 -> 3 :: l? x2
[3] __primitive.dep 2 :: i x2
[4] __primitive.bitand &3 &5 in [0, 1] :: i x1
[5] val 1 :: i x2
[6] __primitive.eq 4 5 :: y x4
[7] __primitive.assert 11 &6 :: l? x1
[8] __primitive.assert 3 &6 :: i? x1
[9] __primitive.assert &10 &6 :: l? x1
[10] jump tests.fuse_filter_tail2:filter2 2 :: l x2.
[11] __primitive.pushr 9 8 :: l x1
[12] return [7] -> 15
[13] __primitive.not 6 :: y x1
[14] __primitive.assert 10 13 :: l? x1
[15] return [14]

___ tests.fuse_map (1 -> 1) ___
[1] var :: ?l x1
[2] jump tests.fuse_map:map 1 :: l x1
[3] return [2]

___ tests.fuse_map:map (1 -> 1) rec row ___
[1] changing var :: ?l x1
[2] __primitive.ap 1 -> 3 :: l? x2
[3] __primitive.dep 2 :: i x2
[4] __primitive.seq 5 &3 :: i x2
[5] __primitive.add 3 &6 :: i x1
[6] val 1 :: i x2
[7] __primitive.seq 8 &4 :: i x1
[8] __primitive.shiftl 4 6 :: i x1
[9] jump tests.fuse_map:map 2 :: l x1
[10] __primitive.pushr 9 7 :: l x1
[11] return [10]

___ tests.fuse_map2 (1 -> 1) ___
[1] var :: ?l x1
[2] jump tests.fuse_map2:map 1 :: l x1
[3] return [2]

___ tests.fuse_map2:map (1 -> 1) rec row ___
[1] changing var :: ?l x1
[2] __primitive.ap 1 -> 3 :: l? x2
[3] __primitive.dep 2 :: i x2
[4] __primitive.seq 7 &3 :: i x1
[5] __primitive.add 3 &6 :: i x1
[6] val 1 :: i x2
[7] __primitive.shiftl 5 6 :: i x1
[8] jump tests.fuse_map2:map 2 :: l x1
[9] __primitive.pushr 8 4 :: l x1
[10] return [9]

___ tests.fuse_map3 (1 -> 2) ___
[1] var :: ?l x1
[2] __primitive.ap 1 -> 3 :: l? x2
[3] __primitive.dep 2 :: i x2
[4] __primitive.seq 5 &3 :: i x1
[5] __primitive.add 3 &6 :: i x1
[6] val 1 :: i x2
[7] __primitive.ap 2 -> 8 :: v? x1
[8] __primitive.dep 7 :: i x2
[9] __primitive.seq 10 &8 :: i x1
[10] __primitive.add 8 6 :: i x1
[11] return [9 4]

___ tests.fuse_map4 (1 -> 1) ___
[1] var :: ?l x1
[2] __primitive.ap 1 -> X :: l? x1
[3] jump tests.fuse_map4:map 2 :: l x1
[4] return [3]

___ tests.fuse_map4:map (1 -> 1) rec row ___
[1] changing var :: ?l x1
[2] __primitive.ap 1 -> 3 :: l? x2
[3] __primitive.dep 2 :: i x2
[4] __primitive.seq 5 &3 :: i x1
[5] __primitive.add 3 6 :: i x1
[6] val 1 :: i x1
[7] jump tests.fuse_map4:map 2 :: l x1
[8] __primitive.pushr 7 4 :: l x1
[9] return [8]

___ tests.fuse_map4b (1 -> 1) ___
[1] var :: ?l x1
[2] __primitive.ap 1 -> X :: l? x1
[3] jump tests.fuse_map4b:map 2 :: l x1
[4] return [3]

___ tests.fuse_map4b:map (1 -> 1) rec row ___
[1] changing var :: ?l x1
[2] __primitive.ap 1 -> 3 :: l? x2
[3] __primitive.dep 2 :: i x2
[4] __primitive.seq 5 &3 :: i x1
[5] __primitive.add 3 6 :: i x1
[6] val 1 :: i x1
[7] jump tests.fuse_map4b:map 2 :: l x1
[8] __primitive.pushr 7 4 :: l x1
[9] return [8]

___ tests.fuse_map5 (1 -> 1) ___
[1] var :: ?l x1
[2] __primitive.ap 1 -> 3 :: l? x2
[3] __primitive.dep 2 :: i x1
[4] jump tests.fuse_map5:map_with 2 3 :: l x1
[5] return [4]

___ tests.fuse_map5:map_with (2 -> 1) rec row ___
[1] changing var :: ?i x1
[2] changing var :: ?l x1
[3] __primitive.ap 2 -> 4 :: l? x2
[4] __primitive.dep 3 :: i x1
[5] __primitive.add 1 4 :: i x2
[6] jump tests.fuse_map5:map_with 3 &5 :: l x1
[7] __primitive.pushr 6 5 :: l x1
[8] return [7]

___ tests.fuse_map5b (1 -> 1) ___
[1] var :: ?l x1
[2] val 0 :: i x1
[3] __primitive.ap 1 -> X :: l? x1
[4] jump tests.fuse_map5b:map_with 3 2 :: l x1
[5] return [4]

___ tests.fuse_map5b:map_with (2 -> 1) rec row ___
[1] changing var :: ?i x1
[2] changing var :: ?l x1
[3] __primitive.ap 2 -> 4 :: l? x2
[4] __primitive.dep 3 :: i x1
[5] __primitive.add 1 4 :: i x2
[6] jump tests.fuse_map5b:map_with 3 &5 :: l x1
[7] __primitive.pushr 6 5 :: l x1
[8] return [7]

___ tests.fuse_map5c (1 -> 1) ___
[1] var :: ?l x1
[2] __primitive.ap 1 -> 3 :: v? x1
[3] __primitive.dep 2 :: i x1
[4] return [3]

___ tests.fuse_map5d (1 -> 1) ___
[1] var :: ?l x1
[2] val 0 :: i x1
[3] jump tests.fuse_map5d:map_with 1 2 :: l x1
[4] return [3]

___ tests.fuse_map5d:map_with (2 -> 1) rec row ___
[1] changing var :: ?i x1
[2] changing var :: ?l x1
[3] __primitive.ap 2 -> 4 :: l? x2
[4] __primitive.dep 3 :: i x2
[5] __primitive.seq 6 &4 :: i x1
[6] __primitive.mul 4 7 :: i x1
[7] val 3 :: i x1
[8] __primitive.add 1 5 :: i x2
[9] jump tests.fuse_map5d:map_with 3 &8 :: l x1
[10] __primitive.pushr 9 8 :: l x1
[11] return [10]

___ tests.fuse_map5e (1 -> 1) ___
[1] var :: ?l x1
[2] __primitive.ap 1 -> 3 :: l? x2
[3] __primitive.dep 2 :: i x1
[4] jump tests.fuse_map5e:map_with 2 3 :: l x1
[5] return [4]

___ tests.fuse_map5e:map_with (2 -> 1) rec row ___
[1] changing var :: ?i x1
[2] changing var :: ?l x1
[3] __primitive.ap 2 -> 4 :: l? x2
[4] __primitive.dep 3 :: i x1
[5] __primitive.add 1 4 :: i x2
[6] jump tests.fuse_map5e:map_with 3 &5 :: l x1
[7] __primitive.pushr 6 5 :: l x1
[8] return [7]

___ tests.fuse_map5f (1 -> 1) ___
[1] var :: ?l x1
[2] val 0 :: i x1
[3] jump tests.fuse_map5f:map 1 2 :: l x1
[4] return [3]

___ tests.fuse_map5f:map (2 -> 1) rec row ___
[1] changing var :: ?i x1
[2] changing var :: ?l x1
[3] __primitive.ap 2 -> 4 :: l? x2
[4] __primitive.dep 3 :: i x1
[5] __primitive.add 1 4 :: i x3
[6] __primitive.seq 7 &5 :: i x1
[7] __primitive.mul &5 8 :: i x1
[8] val 3 :: i x1
[9] jump tests.fuse_map5f:map 3 5 :: l x1
[10] __primitive.pushr 9 6 :: l x1
[11] return [10]

___ tests.fuse_map6 (1 -> 1) ___
[1] var :: ?l x1
[2] val 1 :: i x1
[3] val 0 :: i x1
[4] jump tests.fuse_map6:map_with 1 3 2 :: l x1
[5] return [4]

___ tests.fuse_map6:map_with (3 -> 1) rec row ___
[1] changing var :: ?i x1
[2] changing var :: ?i x1
[3] changing var :: ?l x1
[4] __primitive.ap 3 -> 5 :: l? x2
[5] __primitive.dep 4 :: i x1
[6] __primitive.add 2 5 :: i x2
[7] __primitive.mul 1 &6 :: i x2
[8] jump tests.fuse_map6:map_with 4 6 &7 :: l x1
[9] __primitive.pushr 8 7 :: l x1
[10] return [9]

___ tests.fuse_map7 (1 -> 1) row ___
[1] var :: ?l x1
[2] __primitive.ap 1 -> 3 :: l? x2
[3] __primitive.dep 2 :: a x1
[4] jump tests.fuse_map7:map 2 :: l x1
[5] __primitive.pushr 4 3 :: l x1
[6] return [5]

___ tests.fuse_map7:map (1 -> 1) rec row ___
[1] changing var :: ?l x1
[2] __primitive.ap 1 -> 3 :: l? x2
[3] __primitive.dep 2 :: a x2
[4] jump tests.fuse_map7:map 2 :: l x1
[5] __primitive.pushr 4 &3 3 :: l x1
[6] return [5]

___ tests.fuse_map8 (2 -> 2) ___
[1] var :: ?i x2
[2] var :: ?i x2
[3] __primitive.seq 4 &1 :: i x3
[4] __primitive.shiftl 1 &5 :: i x1
[5] val 1 :: i x2
[6] __primitive.seq 7 &3 :: i x1
[7] __primitive.add &3 &8 :: i x1
[8] val 3 :: i x2
[9] __primitive.seq 10 &2 :: i x1
[10] __primitive.shiftl 2 5 :: i x1
[11] __primitive.add 3 9 :: i x2
[12] __primitive.seq 13 &11 :: i x1
[13] __primitive.add 11 8 :: i x1
[14] return [12 6]

___ tests.fuse_map8b (2 -> 2) ___
[1] var :: ?i x2
[2] var :: ?i x2
[3] __primitive.seq 4 &1 :: i x1
[4] __primitive.shiftl 1 &5 :: i x1
[5] val 1 :: i x3
[6] __primitive.shiftl 3 &5 :: i x2
[7] __primitive.seq 8 &6 :: i x1
[8] __primitive.add 6 &9 :: i x1
[9] val 3 :: i x2
[10] __primitive.seq 11 &2 :: i x1
[11] __primitive.shiftl 2 5 :: i x1
[12] __primitive.shiftl 10 13 :: i x2
[13] val 2 :: i x1
[14] __primitive.seq 15 &12 :: i x1
[15] __primitive.add 12 9 :: i x1
[16] return [14 7]

___ tests.fuse_map8c (3 -> 3) ___
[1] var :: ?i x2
[2] var :: ?i x2
[3] var :: ?i x2
[4] __primitive.seq 5 &1 :: i x1
[5] __primitive.shiftl 1 &6 :: i x1
[6] val 1 :: i x4
[7] __primitive.shiftl 4 &6 :: i x2
[8] __primitive.seq 9 &7 :: i x1
[9] __primitive.add 7 &10 :: i x1
[10] val 3 :: i x4
[11] __primitive.seq 12 &2 :: i x1
[12] __primitive.shiftl 2 &6 :: i x1
[13] __primitive.shiftl 11 14 :: i x2
[14] val 2 :: i x1
[15] __primitive.seq 16 &13 :: i x1
[16] __primitive.add 13 &10 :: i x1
[17] __primitive.seq 18 &3 :: i x1
[18] __primitive.shiftl 3 6 :: i x1
[19] __primitive.shiftl 17 &10 :: i x2
[20] __primitive.seq 21 &19 :: i x1
[21] __primitive.add 19 10 :: i x1
[22] return [20 15 8]

___ tests.fuse_map_filter (1 -> 1) ___
[1] var :: ?l x1
[2] jump tests.fuse_map_filter:filter 1 :: l x1
[3] return [2]

___ tests.fuse_map_filter:filter (1 -> 1) rec row ___
[1] changing var :: ?l x1
[2] tests.fuse_map_filter:filter:next_match 1 -> 3 :: l x2
[3] __primitive.dep 2 :: i x1
[4] jump tests.fuse_map_filter:filter 2 :: l x1
[5] __primitive.pushr 4 3 :: l x1
[6] return [5]

___ tests.fuse_map_filter:filter:next_match (1 -> 2) x2 rec ___
[1] changing var :: ?l x1
[2] __primitive.ap 1 -> 3 :: l? x3
[3] __primitive.dep 2 :: i x3
[4] __primitive.seq &5 &3 :: i x1
[5] __primitive.add &3 &6 :: i x2
[6] val 1 :: i x3
[7] __primitive.bitand 4 &6 in [0, 1] :: i x1
[8] __primitive.eq 7 6 :: y x2
[9] __primitive.assert 10 &8 :: i? x1
[10] __primitive.seq 5 3 :: i x1
[11] return [2 9] -> 17
[12] __primitive.not 8 :: y x2
[13] __primitive.assert 15 &12 :: i? x1
[14] jump tests.fuse_map_filter:filter:next_match 2 -> 15 :: l x2
[15] __primitive.dep 14 :: i x1
[16] __primitive.assert 14 12 :: l? x1
[17] return [16 13]

___ tests.fuse_map_ho (3 -> 1) ___
[1] var :: ?l x1
[2] var :: ?l x1
[3] var :: ?l x1
[4] jump tests.fuse_map_ho:map 3 2 1 :: l x1
[5] return [4]

___ tests.fuse_map_ho:map (3 -> 1) rec row ___
[1] var :: ?l x2
[2] var :: ?l x2
[3] changing var :: ?l x1
[4] __primitive.ap 3 -> 5 :: l? x2
[5] __primitive.dep 4 :: a x2
[6] __primitive.seq 8 &5 :: a x2
[7] __primitive.ap 5 &2 -> 8 :: v? x1
[8] __primitive.dep 7 :: a x1
[9] __primitive.seq 11 &6 :: a x1
[10] __primitive.ap 6 &1 -> 11 :: l? x2
[11] __primitive.dep 10 :: a x1
[12] jump tests.fuse_map_ho:map 4 2 1 :: l x1
[13] __primitive.pushr 14 9 :: l x1
[14] __primitive.compose 12 10 :: l x1
[15] return [13]

___ tests.fuse_map_with_filter (1 -> 1) ___
[1] var :: ?l x1
[2] val 0 :: i x1
[3] jump tests.fuse_map_with_filter:filter 1 2 :: l x1
[4] return [3]

___ tests.fuse_map_with_filter:filter (2 -> 1) rec row ___
[1] changing var :: ?i x1
[2] changing var :: ?l x1
[3] tests.fuse_map_with_filter:filter:next_match 2 1 -> 6 5 :: l x3
[5] __primitive.dep 3 :: i x1
[6] __primitive.dep 3 is 0 :: i x1
[7] jump tests.fuse_map_with_filter:filter 3 6 :: l x1
[8] __primitive.pushr 7 5 :: l x1
[9] return [8]

___ tests.fuse_map_with_filter:filter:next_match (2 -> 3) x2 rec ___
[1] changing var :: ?i x1
[2] changing var :: ?l x1
[3] __primitive.ap 2 -> 4 :: l? x3
[4] __primitive.dep 3 :: i x1
[5] __primitive.add 1 4 :: i x3
[6] __primitive.mul &5 7 :: i x2
[7] val 11 :: i x1
[8] __primitive.bitand &6 &9 in [0, 1] :: i x1
[9] val 1 :: i x2
[10] __primitive.eq 8 9 :: y x4
[11] __primitive.assert 6 &10 :: i? x1
[12] __primitive.assert &5 &10 :: i? x1
[13] __primitive.assert &3 &10 :: l? x1
[14] return [13 12 11] -> 24
[16] __primitive.not 10 :: y x3
[17] __primitive.assert 20 &16 :: i? x1
[18] jump tests.fuse_map_with_filter:filter:next_match 3 5 -> 22 20 :: l x3
[20] __primitive.dep 18 :: i x1
[21] __primitive.assert 22 &16 :: i? x1
[22] __primitive.dep 18 :: i x1
[23] __primitive.assert 18 16 :: l? x1
[24] return [23 21 17]

___ tests.fuse_map_with_sum (1 -> 1) ___
[1] var :: ?l x1
[2] val 0 :: i x2
[3] jump tests.fuse_map_with_sum:sum:foldr:iterate &2 1 2 :: i x1
[4] return [3]

___ tests.fuse_map_with_sum:sum:foldr:iterate (3 -> 1) x2 rec ___
[1] changing var :: ?i x1
[2] changing var :: ?l x1
[3] changing var :: ?i x2
[4] __primitive.ap 2 -> 5 :: l? x2
[5] __primitive.dep 4 :: i x1
[6] __primitive.add 1 5 :: i x4
[7] __primitive.seq 9 &6 :: v x1
[8] __primitive.add &6 3 :: i x1
[9] jump tests.fuse_map_with_sum:sum:foldr:iterate 8 4 6 :: v x1
[10] return [7] -> 12
[11] __primitive.unless 3 6 :: i x1
[12] return [11]

___ tests.fuse_map_zip_map (2 -> 1) ___
[1] var :: ?l x1
[2] var :: ?l x1
[3] jump tests.fuse_map_zip_map:map 1 2 :: l x1
[4] return [3]

___ tests.fuse_map_zip_map:map (2 -> 1) rec row ___
[1] changing var :: ?l x1
[2] changing var :: ?l x1
[3] __primitive.ap 2 -> 4 :: l? x2
[4] __primitive.dep 3 :: i x2
[5] __primitive.seq 6 &4 :: i x1
[6] __primitive.mul 4 7 :: i x1
[7] val 3 :: i x1
[8] __primitive.ap 1 -> 9 :: l? x2
[9] __primitive.dep 8 :: i x2
[10] __primitive.seq 11 &9 :: i x1
[11] __primitive.mul 9 12 :: i x1
[12] val 5 :: i x1
[13] __primitive.add 5 10 :: i x2
[14] __primitive.seq 15 &13 :: i x1
[15] __primitive.div 13 16 :: i? x1
[16] val 2 :: i x1
[17] jump tests.fuse_map_zip_map:map 3 8 :: l x1
[18] __primitive.pushr 17 14 :: l x1
[19] return [18]

___ tests.fuse_zip_zip (3 -> 1) ___
[1] var :: ?l x1
[2] var :: ?l x1
[3] var :: ?l x1
[4] jump tests.fuse_zip_zip:map 1 2 3 :: l x1
[5] return [4]

___ tests.fuse_zip_zip:map (3 -> 1) rec row ___
[1] changing var :: ?l x1
[2] changing var :: ?l x1
[3] changing var :: ?l x1
[4] __primitive.ap 3 -> 5 :: l? x2
[5] __primitive.dep 4 :: i x2
[6] __primitive.seq 7 &5 :: i x1
[7] __primitive.shiftl 5 &8 :: i x1
[8] val 1 :: i x2
[9] __primitive.ap 2 -> 10 :: l? x2
[10] __primitive.dep 9 :: i x2
[11] __primitive.seq 12 &10 :: i x1
[12] __primitive.mul 10 13 :: i x1
[13] val 3 :: i x1
[14] __primitive.add 6 11 :: i x1
[15] __primitive.ap 1 -> 16 :: l? x2
[16] __primitive.dep 15 :: i x2
[17] __primitive.seq 18 &16 :: i x1
[18] __primitive.mul 16 19 :: i x1
[19] val 5 :: i x1
[20] __primitive.add 14 17 :: i x2
[21] __primitive.seq 22 &20 :: i x1
[22] __primitive.sub 20 8 :: i x1
[23] jump tests.fuse_zip_zip:map 4 9 15 :: l x1
[24] __primitive.pushr 23 21 :: l x1
[25] return [24]

___ tests.hello (1 -> 1) ___
[1] var :: ?y x1
[2] __primitive.open 1 &3 -> 4 :: y x2
[3] val "stream,out:std" :: s x2
[4] __primitive.dep 2 is File :: o x1
[5] __primitive.write 2 4 6 -> 8 :: y x2
[6] val "What's your name? " :: s x1
[8] __primitive.dep 5 is File :: o x1
[9] __primitive.close 5 8 :: y x1
[10] __primitive.open 9 11 -> 12 :: y x2
[11] val "stream,in:std" :: s x1
[12] __primitive.dep 10 is File :: o x1
[13] io.getline_loop 10 12 15 -> 16 20 :: y x3
[15] val "" :: s x1
[16] __primitive.dep 13 is File :: o x1
[17] __primitive.close 13 16 :: y x1
[18] __primitive.open 17 3 -> 19 :: y x2
[19] __primitive.dep 18 is File :: o x1
[20] __primitive.dep 13 :: s x1
[21] __primitive.strcat 22 20 :: s x1
[22] val "Hello " :: s x1
[23] __primitive.strcat 21 24 :: s x1
[24] val "!\n" :: s x1
[25] __primitive.write 18 19 23 -> 26 :: y x2
[26] __primitive.dep 25 is File :: o x1
[27] __primitive.close 25 26 :: y x1
[28] return [27]

___ tests.help (1 -> 1) ___
[1] var :: ?y x1
[2] __primitive.open 1 3 -> 4 :: y x2
[3] val "stream,out:std" :: s x1
[4] __primitive.dep 2 is File :: o x1
[5] __primitive.write 2 4 6 -> 8 :: y x2
[6] val "Type `:help` (with initial colon) for help.\n" :: s x1
[8] __primitive.dep 5 is File :: o x1
[9] __primitive.close 5 8 :: y x1
[10] return [9]

___ tests.id_map (1 -> 1) ___
[1] var :: ?l x1
[2] return [1]

___ tests.id_map2 (1 -> 1) rec row ___
[1] changing var :: ?l x1
[2] __primitive.ap 1 -> 3 :: l? x2
[3] __primitive.dep 2 :: a x1
[4] jump tests.id_map2 2 :: l x1
[5] __primitive.pushr 4 3 :: l x1
[6] return [5]

___ tests.id_quote_compose (1 -> 1) row ___
[1] var :: ?l x1
[2] __primitive.ap 1 -> 3 :: l? x2
[3] __primitive.dep 2 :: a x1
[4] __primitive.pushr 2 3 :: l x1
[5] return [4]

___ tests.imbalanced_assert (2 -> 2) ___
[1] var :: ?y x2
[2] var :: ?y x2
[3] __primitive.assert 4 &2 is 3 :: i? x1
[4] __primitive.assert 5 &1 is 3 :: i? x1
[5] val 3 :: i x1
[6] val 2 :: i x1
[7] __primitive.assert 6 1 is 2 :: i? x1
[8] __primitive.assert 7 2 is 2 :: i? x1
[9] return [8 3]

___ tests.inl_loop (1 -> 1) ___
[1] var :: ?i x1
[2] jump tests.inl_loop:iterate 1 :: i x1
[3] return [2]

___ tests.inl_loop:iterate (1 -> 1) x2 rec ___
[1] changing var :: ?i x3
[2] __primitive.lt &1 3 :: y x2
[3] val 10 :: i x1
[4] __primitive.not &2 :: y x1
[5] __primitive.assert &1 4 :: i? x1
[6] return [5] -> 11
[7] __primitive.assert 10 2 :: i? x1
[8] __primitive.add 1 9 :: i x1
[9] val 3 :: i x1
[10] jump tests.inl_loop:iterate 8 :: i x1
[11] return [7]

___ tests.inl_loop2 (3 -> 1) ___
[1] var :: ?i x1
[2] var :: ?i x1
[3] var :: ?i x1
[4] jump tests.inl_loop2:iterate 3 2 1 :: i x1
[5] return [4]

___ tests.inl_loop2:iterate (3 -> 1) x2 rec ___
[1] var :: ?i x2
[2] var :: ?i x2
[3] changing var :: ?i x3
[4] __primitive.lt &3 &1 :: y x2
[5] __primitive.not &4 :: y x1
[6] __primitive.assert &3 5 :: i? x1
[7] return [6] -> 11
[8] __primitive.assert 10 4 :: i? x1
[9] __primitive.add 3 &2 :: i x1
[10] jump tests.inl_loop2:iterate 9 2 1 :: i x1
[11] return [8]

___ tests.inl_loop3 (1 -> 1) ___
[1] var :: ?i x1
[2] tests.inl_loop3:iterate 1 :: i x1
[3] __primitive.shiftl 2 4 :: i x1
[4] val 3 :: i x1
[5] return [3]

___ tests.inl_loop3:iterate (1 -> 1) x2 rec ___
[1] changing var :: ?i x3
[2] __primitive.lt &1 3 :: y x2
[3] val 10 :: i x1
[4] __primitive.not &2 :: y x1
[5] __primitive.assert &1 4 :: i? x1
[6] return [5] -> 11
[7] __primitive.assert 10 2 :: i? x1
[8] __primitive.add 1 9 :: i x1
[9] val 3 :: i x1
[10] jump tests.inl_loop3:iterate 8 :: i x1
[11] return [7]

___ tests.inl_loop4 (1 -> 1) ___
[1] var :: ?i x1
[2] __primitive.add 1 3 :: i x1
[3] val 4 :: i x1
[4] tests.inl_loop4:iterate 2 :: i x1
[5] __primitive.shiftl 4 6 :: i x1
[6] val 1 :: i x1
[7] return [5]

___ tests.inl_loop4:iterate (1 -> 1) x2 rec ___
[1] changing var :: ?i x3
[2] __primitive.lt &1 3 :: y x2
[3] val 10 :: i x1
[4] __primitive.not &2 :: y x1
[5] __primitive.assert &1 4 :: i? x1
[6] return [5] -> 11
[7] __primitive.assert 10 2 :: i? x1
[8] __primitive.add 1 9 :: i x1
[9] val 3 :: i x1
[10] jump tests.inl_loop4:iterate 8 :: i x1
[11] return [7]

___ tests.input_times (3 -> 1) ___
[1] var :: ?i x1
[2] var :: ?l x1
[3] var :: ?y x1
[4] jump tests.input_times:times:iterate 1 2 3 :: l x1
[5] return [4]

___ tests.input_times:times:iterate (3 -> 1) x2 rec ___
[1] changing var :: ?y x2
[2] changing var :: ?l x2
[3] changing var :: ?i x2
[4] __primitive.gt &3 5 :: y x2
[5] val 0 :: i x1
[6] __primitive.not &4 :: y x3
[7] __primitive.assert &2 &6 :: l? x1
[8] __primitive.assert &1 &6 :: y? x1
[9] __primitive.quote 8 7 :: l x1
[10] __primitive.assert 9 6 :: l? x1
[11] return [10] -> 26
[12] __primitive.assert 25 4 :: l? x1
[13] __primitive.open 1 14 -> 15 :: y x2
[14] val "stream,in:std" :: s x1
[15] __primitive.dep 13 is File :: o x1
[16] __primitive.sub 3 17 :: i x1
[17] val 1 :: i x1
[18] io.getline_loop 13 15 20 -> 21 23 :: y x3
[20] val "" :: s x1
[21] __primitive.dep 18 is File :: o x1
[22] __primitive.close 18 21 :: y x1
[23] __primitive.dep 18 :: s x1
[24] __primitive.ap 23 2 :: l x1
[25] jump tests.input_times:times:iterate 16 24 22 :: l x1
[26] return [12]

___ tests.it10 (1 -> 1) ___
[1] var :: ?i x1
[2] jump tests.it10:iterate 1 :: i x1
[3] return [2]

___ tests.it10:iterate (1 -> 1) x2 rec ___
[1] changing var :: ?i x3
[2] __primitive.lt &1 3 :: y x2
[3] val 10 :: i x1
[4] __primitive.not &2 :: y x1
[5] __primitive.assert &1 4 :: i? x1
[6] return [5] -> 11
[7] __primitive.assert 10 2 :: i? x1
[8] __primitive.add 1 9 :: i x1
[9] val 1 :: i x1
[10] jump tests.it10:iterate 8 :: i x1
[11] return [7]

___ tests.it10b (1 -> 1) ___
[1] var :: ?l x1
[2] jump tests.it10b:iterate 1 :: i x1
[3] return [2]

___ tests.it10b:iterate (1 -> 1) x2 rec ___
[1] changing var :: ?l x1
[2] __primitive.ap 1 -> 3 :: l? x2
[3] __primitive.dep 2 :: i x3
[4] __primitive.lt &3 5 :: y x2
[5] val 10 :: i x1
[6] __primitive.not &4 :: y x1
[7] __primitive.assert &3 6 :: i? x1
[8] return [7] -> 14
[9] __primitive.assert 13 4 :: i? x1
[10] __primitive.add 3 11 :: i x1
[11] val 1 :: i x1
[12] __primitive.pushr 2 10 :: l x1
[13] jump tests.it10b:iterate 12 :: i x1
[14] return [9]

___ tests.ldmult (2 -> 1) ___
[1] var :: ?l x1
[2] var :: ?i x1
[3] list.listdup:times:iterate 2 1 4 :: l x1
[4] [] :: l x1
[5] jump algorithm.sum:foldr:iterate 6 3 :: i x1
[6] val 0 :: i x1
[7] return [5]

___ tests.leak (1 -> 1) ___
[1] var :: ?i x1
[2] val 0 :: i x1
[3] jump tests.leak:iterate 1 2 :: i x1
[4] return [3]

___ tests.leak:iterate (2 -> 1) x2 rec ___
[1] changing var :: ?i x2
[2] var :: ?i x2
[3] __primitive.gt &2 4 :: y x2
[4] val 1 :: i x1
[5] __primitive.not &3 :: y x1
[6] __primitive.assert &1 5 :: i? x1
[7] return [6] -> 12
[8] __primitive.assert 11 3 :: i? x1
[9] __primitive.add 1 10 :: i x1
[10] val 3 :: i x1
[11] jump tests.leak:iterate 2 9 :: i x1
[12] return [8]

___ tests.left_right (1 -> 1) ___
[1] var :: ?l x1
[2] val Left :: y x1
[3] jump tests.left_right:map_with 1 2 :: l x1
[4] return [3]

___ tests.left_right:map_with (2 -> 1) x2 rec row ___
[1] changing var :: ?y x4
[2] changing var :: ?l x1
[3] __primitive.ap 2 -> 4 :: l? x3
[4] __primitive.dep 3 :: a x4
[5] __primitive.seq 12 &4 :: l x1
[6] __primitive.eq_s &1 &7 :: y x1
[7] val Left :: y x2
[8] __primitive.assert &10 6 is Right :: y? x1
[9] tests.left_right:map_with 3 8 :: l x1
[10] val Right :: y x2
[11] __primitive.pushr 9 5 :: l x1
[12] __primitive.quote 4 1 :: l x1
[13] return [11] -> 20
[14] __primitive.eq_s &1 10 :: y x1
[15] __primitive.assert 7 14 is Left :: y? x1
[16] tests.left_right:map_with 3 15 :: l x1
[17] __primitive.pushr 16 19 :: l x1
[18] __primitive.quote &4 1 :: l x1
[19] __primitive.seq 18 4 :: l x1
[20] return [17]

___ tests.map_add1 (1 -> 1) ___
[1] var :: ?l x1
[2] jump tests.map_add1:map 1 :: l x1
[3] return [2]

___ tests.map_add1:map (1 -> 1) rec row ___
[1] changing var :: ?l x1
[2] __primitive.ap 1 -> 3 :: l? x2
[3] __primitive.dep 2 :: i x2
[4] __primitive.seq 5 &3 :: i x1
[5] __primitive.add 3 6 :: i x1
[6] val 1 :: i x1
[7] jump tests.map_add1:map 2 :: l x1
[8] __primitive.pushr 7 4 :: l x1
[9] return [8]

___ tests.map_iteratel (1 -> 1) ___
[1] var :: ?l x1
[2] val 0 :: i x1
[3] jump tests.map_iteratel:map 2 1 :: l x1
[4] return [3]

___ tests.map_iteratel:map (2 -> 1) rec row ___
[1] var :: ?l x2
[2] changing var :: ?i x3
[3] __primitive.seq 5 &2 :: a x1
[4] __primitive.ap &2 &1 -> 5 :: l? x2
[5] __primitive.dep 4 :: a x1
[6] __primitive.add 2 7 :: i x1
[7] val 1 :: i x1
[8] jump tests.map_iteratel:map 6 1 :: l x1
[9] __primitive.pushr 10 3 :: l x1
[10] __primitive.compose 8 4 :: l x1
[11] return [9]

___ tests.mapc (2 -> 1) ___
[1] var :: ?l x1
[2] var :: ?l x1
[3] [] :: l x1
[4] jump tests.mapc:foldr:iterate 3 2 1 :: l x1
[5] return [4]

___ tests.mapc:foldr:iterate (3 -> 1) x2 rec ___
[1] var :: ?l x2
[2] changing var :: ?l x1
[3] changing var :: ?l x2
[4] __primitive.ap 2 -> 5 :: l? x2
[5] __primitive.dep 4 :: a x3
[6] __primitive.seq 9 &5 :: v x1
[7] __primitive.ap 5 &1 :: l x1
[8] __primitive.compose 7 3 :: l x1
[9] jump tests.mapc:foldr:iterate 8 4 1 :: v x1
[10] return [6] -> 12
[11] __primitive.unless 3 5 :: l x1
[12] return [11]

___ tests.mov_ap (3 -> 3) ___
[1] var :: ?l x2
[2] var :: ?l x1
[3] var :: ?l x1
[4] __primitive.ap 3 -> 5 :: l? x2
[5] __primitive.dep 4 :: a x1
[6] __primitive.ap 5 &1 :: l x1
[7] __primitive.compose 6 2 :: l x1
[8] return [4 7 1]

___ tests.mul_lt50 (2 -> 1) ___
[1] var in [1, 10] :: ?i x2
[2] var in [1, 10] :: ?i x2
[3] __primitive.gte &1 &4 :: y x1
[4] val 1 :: i x2
[5] __primitive.assert 1 3 in [1, 10] :: i? x2
[6] __primitive.lte &5 &7 :: y x1
[7] val 10 :: i x2
[8] __primitive.assert 5 6 in [1, 10] :: i? x1
[9] __primitive.gte &2 4 :: y x1
[10] __primitive.assert 2 9 in [1, 10] :: i? x2
[11] __primitive.lte &10 7 :: y x1
[12] __primitive.assert 10 11 in [1, 10] :: i? x1
[13] __primitive.mul 8 12 in [1, 100] :: i x2
[14] __primitive.lt &13 15 :: y x1
[15] val 50 :: i x1
[16] __primitive.assert 13 14 in [1, 49] :: i? x1
[17] return [16]

___ tests.nd_rec (2 -> 1) x2 rec ___
[1] var :: ?l x3
[2] changing var :: ?a x1
[3] __primitive.ap 2 &1 -> 4 7 :: v? x2
[4] __primitive.dep 3 :: a x1
[5] jump tests.nd_rec 4 1 :: v x1
[6] return [5] -> 9
[7] __primitive.dep 3 :: a x1
[8] jump tests.nd_rec 7 1 :: v x1
[9] return [8]

___ tests.not_one_to_ten (1 -> 1) x2 ___
[1] var :: ?i x4
[2] __primitive.lt &1 3 :: y x1
[3] val 1 :: i x1
[4] __primitive.assert &1 2 :: i? x1
[5] return [4] -> 9
[6] __primitive.gt &1 7 :: y x1
[7] val 10 :: i x1
[8] __primitive.assert 1 6 >= 11 :: i? x1
[9] return [8]

___ tests.old_filter (2 -> 1) ___
[1] var :: ?l x1
[2] var :: ?l x1
[3] [] :: l x1
[4] jump tests.old_filter:iterate 3 2 1 :: l x1
[5] return [4]

___ tests.old_filter:iterate (3 -> 1) x3 rec ___
[1] var :: ?l x3
[2] changing var :: ?l x1
[3] changing var :: ?l x3
[4] __primitive.ap 2 -> 5 :: l? x3
[5] __primitive.dep 4 :: a x5
[6] __primitive.seq 11 &5 :: v x1
[7] __primitive.ap &5 &1 -> 8 :: v? x1
[8] __primitive.dep 7 :: y x2
[9] __primitive.not &8 :: y x1
[10] __primitive.assert &3 9 :: l? x1
[11] jump tests.old_filter:iterate 10 4 1 :: v x1
[12] return [6] -> 17
[13] __primitive.seq 16 &5 :: v x1
[14] __primitive.assert 15 8 :: l? x1
[15] __primitive.ap 5 3 :: l x1
[16] jump tests.old_filter:iterate 14 4 1 :: v x1
[17] return [13] -> 19
[18] __primitive.unless 3 5 :: l x1
[19] return [18]

___ tests.old_map (2 -> 1) ___
[1] var :: ?l x1
[2] var :: ?l x1
[3] [] :: l x1
[4] jump tests.old_map:iterate 1 3 2 :: l x1
[5] return [4]

___ tests.old_map:iterate (3 -> 1) x2 rec row ___
[1] changing var :: ?l x1
[2] changing var :: ?l x2
[3] var :: ?l x2
[4] __primitive.ap 1 -> 5 :: l? x2
[5] __primitive.dep 4 :: a x3
[6] __primitive.seq 9 &5 :: v x1
[7] __primitive.ap 5 &3 :: l x1
[8] __primitive.compose 7 2 :: l x1
[9] jump tests.old_map:iterate 3 8 4 :: v x1
[10] return [6] -> 12
[11] __primitive.unless 2 5 :: l x1
[12] return [11]

___ tests.one_to_ten (1 -> 1) ___
[1] var in [1, 10] :: ?i x2
[2] __primitive.gte &1 3 :: y x1
[3] val 1 :: i x1
[4] __primitive.assert 1 2 in [1, 10] :: i? x2
[5] __primitive.lte &4 6 :: y x1
[6] val 10 :: i x1
[7] __primitive.assert 4 5 in [1, 10] :: i? x1
[8] return [7]

___ tests.one_to_ten2 (1 -> 1) x2 ___
[1] var in [1, 10] :: ?i x3
[2] __primitive.gte &1 3 :: y x2
[3] val 1 :: i x1
[4] __primitive.assert &1 &2 in [1, 10] :: i? x2
[5] __primitive.lte &4 6 :: y x2
[6] val 10 :: i x1
[7] __primitive.assert 4 &5 in [1, 4] :: i? x2
[8] __primitive.lt &7 &9 :: y x1
[9] val 5 :: i x2
[10] __primitive.assert 7 8 in [1, 4] :: i? x1
[11] return [10] -> 16
[12] __primitive.assert 1 2 in [5, 10] :: i? x1
[13] __primitive.assert 12 5 in [5, 10] :: i? x2
[14] __primitive.gte &13 9 :: y x1
[15] __primitive.assert 13 14 in [5, 10] :: i? x1
[16] return [15]

___ tests.oseq (2 -> 1) ___
[1] var :: ?a x1
[2] var :: ?a x1
[3] __primitive.seq 2 1 :: a x1
[4] return [3]

___ tests.ow_assert (1 -> 1) ___
[1] var :: ?a x1
[2] __primitive.unless 3 1 is True :: y x1
[3] val True :: y x1
[4] return [2]

___ tests.ow_assert2 (2 -> 1) ___
[1] var :: ?a x1
[2] var is True :: ?y x1
[3] __primitive.unless 2 1 is True :: y x1
[4] return [3]

___ tests.ow_assert3 (2 -> 1) ___
[1] var :: ?a x1
[2] var is True :: ?y x1
[3] __primitive.unless 2 1 is True :: y x1
[4] return [3]

___ tests.ow_not (1 -> 1) ___
[1] var :: ?a x1
[2] __primitive.unless 3 1 is True :: y x1
[3] val True :: y x1
[4] return [2]

___ tests.parallel_map_zip (2 -> 1) ___
[1] var :: ?l x1
[2] var :: ?l x1
[3] jump tests.parallel_map_zip:zip 2 1 :: l x1
[4] return [3]

___ tests.parallel_map_zip:zip (2 -> 1) rec row ___
[1] changing var :: ?l x1
[2] changing var :: ?l x1
[3] __primitive.ap 2 -> 4 :: l? x2
[4] __primitive.dep 3 :: i x2
[5] __primitive.seq 6 &4 :: i x3
[6] __primitive.add 4 7 :: i x1
[7] val 1 :: i x1
[8] __primitive.ap 1 -> 9 :: l? x2
[9] __primitive.dep 8 :: i x2
[10] __primitive.seq 11 &9 :: i x3
[11] __primitive.mul 9 12 :: i x1
[12] val 3 :: i x1
[13] __primitive.seq 14 &5 :: l x1
[14] __primitive.seq 19 &10 :: l x1
[15] __primitive.add &5 &10 :: i x1
[16] __primitive.seq 17 5 :: l x1
[17] __primitive.seq 18 10 :: l x1
[18] jump tests.parallel_map_zip:zip 3 8 :: l x1
[19] __primitive.pushr 16 15 :: l x1
[20] return [13]

___ tests.parallel_map_zip2 (2 -> 1) ___
[1] var :: ?l x1
[2] var :: ?l x1
[3] jump tests.parallel_map_zip2:zip 2 1 :: l x1
[4] return [3]

___ tests.parallel_map_zip2:zip (2 -> 1) rec row ___
[1] changing var :: ?l x1
[2] changing var :: ?l x1
[3] __primitive.ap 2 -> 4 :: l? x2
[4] __primitive.dep 3 :: i x2
[5] __primitive.seq 6 &4 :: i x3
[6] __primitive.add 4 7 :: i x1
[7] val 1 :: i x1
[8] __primitive.ap 1 -> 9 :: l? x2
[9] __primitive.dep 8 :: i x2
[10] __primitive.seq 11 &9 :: i x3
[11] __primitive.mul 9 12 :: i x1
[12] val 3 :: i x1
[13] __primitive.seq 14 &5 :: l x1
[14] __primitive.seq 19 &10 :: l x1
[15] __primitive.add &5 &10 :: i x1
[16] __primitive.seq 17 5 :: l x1
[17] __primitive.seq 18 10 :: l x1
[18] jump tests.parallel_map_zip2:zip 3 8 :: l x1
[19] __primitive.pushr 16 15 :: l x1
[20] return [13]

___ tests.parallel_map_zip3 (2 -> 1) ___
[1] var :: ?l x1
[2] var :: ?l x1
[3] jump tests.parallel_map_zip3:zip 2 1 :: l x1
[4] return [3]

___ tests.parallel_map_zip3:zip (2 -> 1) rec row ___
[1] changing var :: ?l x1
[2] changing var :: ?l x1
[3] __primitive.ap 2 -> 4 :: l? x2
[4] __primitive.dep 3 :: i x2
[5] __primitive.seq 6 &4 :: i x3
[6] __primitive.add 4 7 :: i x1
[7] val 1 :: i x1
[8] __primitive.ap 1 -> 9 :: l? x2
[9] __primitive.dep 8 :: i x2
[10] __primitive.seq 11 &9 :: i x3
[11] __primitive.mul 9 12 :: i x1
[12] val 3 :: i x1
[13] __primitive.seq 14 &5 :: l x1
[14] __primitive.seq 19 &10 :: l x1
[15] __primitive.add &5 &10 :: i x1
[16] __primitive.seq 17 5 :: l x1
[17] __primitive.seq 18 10 :: l x1
[18] jump tests.parallel_map_zip3:zip 3 8 :: l x1
[19] __primitive.pushr 16 15 :: l x1
[20] return [13]

___ tests.pct (2 -> 1) ___
[1] var :: ?i x1
[2] var :: ?d x1
[3] __primitive.to_float 1 :: d x1
[4] __primitive.div_float 3 5 :: d? x1
[5] val 100 :: d x1
[6] __primitive.add_float 4 7 :: d x1
[7] val 1 :: d x1
[8] __primitive.mul_float 2 6 :: d x1
[9] return [8]

___ tests.pop_min_test (2 -> 1) x4 ___
[1] var :: ?y x3
[2] var :: ?a x4
[3] __primitive.assert &2 &1 :: a? x1
[4] return [3] -> 6
[5] __primitive.assert &2 &1 :: a? x1
[6] return [5] -> 9
[7] __primitive.not 1 :: y x2
[8] __primitive.assert &2 &7 :: a? x1
[9] return [8] -> 11
[10] __primitive.assert 2 7 :: a? x1
[11] return [10]

___ tests.popr_quote_compose (1 -> 1) row ___
[1] var :: ?l x1
[2] __primitive.ap 1 -> 3 :: l? x2
[3] __primitive.dep 2 :: l x1
[4] __primitive.ap 3 -> 5 :: l? x2
[5] __primitive.dep 4 :: a x1
[6] __primitive.pushr 7 5 :: l x1
[7] __primitive.compose 2 4 :: l x1
[8] return [6]

___ tests.push_input (2 -> 2) ___
[1] var :: ?l x1
[2] var :: ?y x1
[3] __primitive.open 2 4 -> 5 :: y x2
[4] val "stream,in:std" :: s x1
[5] __primitive.dep 3 is File :: o x1
[6] io.getline_loop 3 5 8 -> 9 11 :: y x3
[8] val "" :: s x1
[9] __primitive.dep 6 is File :: o x1
[10] __primitive.close 6 9 :: y x1
[11] __primitive.dep 6 :: s x1
[12] __primitive.ap 11 1 :: l x1
[13] return [10 12]

___ tests.pushl2 (3 -> 1) ___
[1] var :: ?l x1
[2] var :: ?a x1
[3] var :: ?a x1
[4] __primitive.ap 3 2 1 :: l x1
[5] return [4]

___ tests.pushl_assert (2 -> 1) ___
[1] var :: ?a x1
[2] var :: ?y x2
[3] __primitive.assert 1 &2 :: a? x1
[4] __primitive.quote 3 :: l x1
[5] __primitive.assert 4 2 :: l? x1
[6] return [5]

___ tests.pushl_swap_assert (3 -> 1) ___
[1] var :: ?l x1
[2] var :: ?a x1
[3] var :: ?y x1
[4] __primitive.assert 5 3 :: l? x1
[5] __primitive.ap 2 1 :: l x1
[6] return [4]

___ tests.qdec (1 -> 1) x2 rec ___
[1] changing var :: ?l x2
[2] __primitive.ap &1 -> 3 :: l? x2
[3] __primitive.dep 2 :: i x3
[4] __primitive.lte &3 &5 :: y x1
[5] val 5 :: i x2
[6] __primitive.assert 1 4 :: l? x1
[7] return [6] -> 14
[8] __primitive.gt &3 5 :: y x1
[9] __primitive.assert 13 8 :: l? x1
[10] __primitive.sub 3 11 :: i x1
[11] val 1 :: i x1
[12] __primitive.pushr 2 10 :: l x1
[13] jump tests.qdec 12 :: l x1
[14] return [9]

___ tests.quadratic (3 -> 1) x2 ___
[1] var :: ?a x3
[2] var :: ?a x3
[3] var :: ?a x3
[4] __primitive.quote &3 &2 &1 :: l x1
[5] list.dropl:iterate 6 4 :: l x2
[6] val 1 :: i x1
[7] __primitive.quote &3 &2 &1 :: l x1
[8] list.dropl:iterate 9 7 :: l x1
[9] val 0 :: i x1
[10] __primitive.quote 3 2 1 :: l x1
[11] list.dropl:iterate 12 10 :: l x2
[12] val 2 :: i x1
[13] __primitive.ap &5 -> 14 :: v? x1
[14] __primitive.dep 13 :: d x1
[15] __primitive.mul_float 14 &16 :: d x2
[16] val -1 :: d x2
[17] __primitive.ap 5 -> 18 :: v? x1
[18] __primitive.dep 17 :: d x2
[19] __primitive.mul_float &18 18 :: d x1
[20] __primitive.ap 8 -> 21 :: v? x1
[21] __primitive.dep 20 :: d x1
[22] __primitive.ap &11 -> 23 :: v? x1
[23] __primitive.dep 22 :: d x1
[24] __primitive.mul_float 21 23 :: d x1
[25] __primitive.mul_float 24 26 :: d x1
[26] val 4 :: d x1
[27] __primitive.sub_float 19 25 :: d x1
[28] __primitive.sqrt 27 :: d x2
[29] __primitive.add_float &15 &28 :: d x1
[30] __primitive.ap 11 -> 31 :: v? x1
[31] __primitive.dep 30 :: d x1
[32] __primitive.mul_float 31 33 :: d x2
[33] val 2 :: d x1
[34] __primitive.div_float 29 &32 :: d? x1
[35] return [34] -> 39
[36] __primitive.mul_float 28 16 :: d x1
[37] __primitive.add_float 15 36 :: d x1
[38] __primitive.div_float 37 32 :: d? x1
[39] return [38]

___ tests.quote_str (1 -> 1) ___
[1] var :: ?s x1
[2] __primitive.strcat &3 1 :: s x1
[3] val "'" :: s x2
[4] __primitive.strcat 2 3 :: s x1
[5] return [4]

___ tests.range_add10 (2 -> 1) ___
[1] var :: ?i x1
[2] var :: ?i x1
[3] __primitive.add 2 1 :: i x2
[4] __primitive.gte &3 5 :: y x1
[5] val 1 :: i x1
[6] __primitive.assert 3 4 in [1, 10] :: i? x2
[7] __primitive.lte &6 8 :: y x1
[8] val 10 :: i x1
[9] __primitive.assert 6 7 in [1, 10] :: i? x1
[10] return [9]

___ tests.reader0 (1 -> 1) ___
[1] var :: ?l x1
[2] [] :: l x1
[3] jump tests.reader0:foldr:iterate 2 1 :: l x1
[4] return [3]

___ tests.reader0:foldr:iterate (2 -> 1) x2 rec row ___
[1] changing var :: ?l x1
[2] changing var :: ?l x2
[3] __primitive.ap 1 -> 4 :: l? x2
[4] __primitive.dep 3 :: l x3
[5] __primitive.seq 9 &4 :: v x1
[6] __primitive.ap 7 4 1b :: l x1
[7] val 0 :: i x1
[8] __primitive.compose 6 2 1b :: l x1
[9] jump tests.reader0:foldr:iterate 8 3 :: v x1
[10] return [5] -> 12
[11] __primitive.unless 2 4 :: l x1
[12] return [11]

___ tests.repeat_int (1 -> 1) rec row ___
[1] var :: ?i x2
[2] jump tests.repeat_int &1 :: l x1
[3] __primitive.pushr 2 1 :: l x1
[4] return [3]

___ tests.reverse_reverse (1 -> 1) ___
[1] var :: ?l x1
[2] list.reverse:foldr:iterate &3 1 :: l x1
[3] [] :: l x2
[4] jump list.reverse:foldr:iterate 3 2 :: l x1
[5] return [4]

___ tests.rpr (2 -> 1) ___
[1] var :: ?l x1
[2] var :: ?a x1
[3] list.reverse:foldr:iterate &4 1 :: l x1
[4] [] :: l x2
[5] __primitive.ap 2 3 :: l x1
[6] jump list.reverse:foldr:iterate 4 5 :: l x1
[7] return [6]

___ tests.say (2 -> 1) ___
[1] var :: ?s x1
[2] var :: ?y x1
[3] __primitive.open 2 4 -> 5 :: y x2
[4] val "stream,out:std" :: s x1
[5] __primitive.dep 3 is File :: o x1
[6] __primitive.strcat 1 7 :: s x1
[7] val "\n" :: s x1
[8] __primitive.write 3 5 6 -> 9 :: y x2
[9] __primitive.dep 8 is File :: o x1
[10] __primitive.close 8 9 :: y x1
[11] return [10]

___ tests.sc3b2 (2 -> 1) ___
[1] var :: ?i x1
[2] var :: ?i x1
[3] __primitive.add 2 1 :: i x1
[4] return [3]

___ tests.spaces (1 -> 1) x2 ___
[1] var :: ?s x1
[2] tests.spaces:iterate 1 :: s x1
[3] __primitive.eq_str 2 4 :: y x2
[4] val "" :: s x1
[5] __primitive.assert 6 &3 is True :: y? x1
[6] val True :: y x1
[7] return [5] -> 12
[8] val Something :: y x1
[9] __primitive.assert 8 3 is True :: y? x1
[10] __primitive.unless 11 9 is False :: y x1
[11] val False :: y x1
[12] return [10]

___ tests.spaces:iterate (1 -> 1) x2 rec ___
[1] changing var :: ?s x3
[2] __primitive.eq_str &1 &3 :: y x1
[3] val "" :: s x2
[4] __primitive.not 2 :: y x2
[5] __primitive.not &4 :: y x1
[6] __primitive.assert &1 5 :: s? x1
[7] return [6] -> 15
[8] __primitive.assert 14 4 :: s? x1
[9] __primitive.strsplit 1 10 -> 13 :: s? x2
[10] val " " :: s x1
[11] __primitive.eq_str 9 3 :: y x1
[12] __primitive.assert 13 11 :: s? x1
[13] __primitive.dep 9 :: s x1
[14] jump tests.spaces:iterate 12 :: s x1
[15] return [8]

___ tests.spilling (1 -> 2) ___
[1] var :: ?y x1
[2] __primitive.not 1 :: y x2
[3] __primitive.not &2 :: y x1
[4] __primitive.quote 3 :: l x1
[5] return [2 4]

___ tests.spilling2 (1 -> 2) ___
[1] var :: ?y x1
[2] __primitive.not 1 :: y x2
[3] __primitive.not &2 :: y x1
[4] __primitive.quote 2 :: l x1
[5] __primitive.quote 3 :: l x1
[6] return [5 4]

___ tests.spilling3 (1 -> 3) ___
[1] var :: ?y x1
[2] __primitive.not 1 :: y x1
[3] __primitive.not 2 :: y x3
[4] __primitive.quote &3 :: l x1
[5] __primitive.quote &3 :: l x1
[6] __primitive.quote 3 :: l x1
[7] return [6 5 4]

___ tests.stream (1 -> 2) rec ___
[1] var :: ?a x2
[2] tests.stream &1 -> 3 :: v x2
[3] __primitive.dep 2 :: v x1
[4] __primitive.quote 2 3 :: l x1
[5] return [4 1]

___ tests.stream_combine (2 -> 1) x2 rec row ___
[1] changing var :: ?l x1
[2] changing var :: ?l x1
[3] __primitive.ap 2 -> 4 :: l? x2
[4] __primitive.dep 3 :: a x2
[5] __primitive.ap 1 -> 10 :: l? x2
[6] jump tests.stream_combine 3 5 :: l x2
[7] __primitive.pushr 6 4 :: l x1
[8] return [7] -> 12
[9] __primitive.unless 10 4 :: a x1
[10] __primitive.dep 5 :: a x1
[11] __primitive.pushr 6 9 :: l x1
[12] return [11]

___ tests.sum3 (3 -> 1) ___
[1] var :: ?a x1
[2] var :: ?a x1
[3] var :: ?a x1
[4] __primitive.quote 3 2 1 :: l x1
[5] jump algorithm.sum:foldr:iterate 6 4 :: i x1
[6] val 0 :: i x1
[7] return [5]

___ tests.sum3l (3 -> 1) x4 ___
[1] var :: ?i x5
[2] var :: ?i x3
[3] var :: ?i x2
[4] __primitive.add 3 2 :: i x1
[5] __primitive.add 4 1 :: i x1
[6] return [5] -> 11
[7] __primitive.seq 8 &1 :: i x1
[8] __primitive.seq 9 &2 :: i x1
[9] __primitive.unless 10 3 :: i x1
[10] __primitive.add 2 1 :: i x1
[11] return [7] -> 12
[12] return [1] -> 15
[13] __primitive.unless 14 1 is 0 :: i x1
[14] val 0 :: i x1
[15] return [13]

___ tests.sum_diff_map (1 -> 1) ___
[1] var :: ?l x1
[2] jump tests.sum_diff_map:map 1 :: l x1
[3] return [2]

___ tests.sum_diff_map:map (1 -> 1) rec row ___
[1] changing var :: ?l x1
[2] __primitive.ap 1 -> 3 :: l? x2
[3] __primitive.dep 2 :: l x2
[4] __primitive.seq 12 &3 :: l x1
[5] tests.sum_diff_map:map 2 :: l x1
[6] __primitive.pushr 5 4 :: l x1
[7] __primitive.ap 3 -> 8 9 :: v? x2
[8] __primitive.dep 7 :: i x2
[9] __primitive.dep 7 :: i x2
[10] __primitive.sub &8 &9 :: i x1
[11] __primitive.add 8 9 :: i x1
[12] __primitive.quote 11 10 :: l x1
[13] return [6]

___ tests.sum_times2 (2 -> 1) ___
[1] var :: ?i x1
[2] var :: ?y x1
[3] val 0 :: i x1
[4] jump tests.sum_times2:times:iterate 1 3 2 :: i x1
[5] return [4]

___ tests.sum_times2:times:iterate (3 -> 1) x2 rec ___
[1] changing var :: ?y x1
[2] changing var :: ?i x2
[3] changing var :: ?i x2
[4] __primitive.gt &3 5 :: y x2
[5] val 0 :: i x1
[6] __primitive.not &4 :: y x1
[7] __primitive.assert &2 6 :: i? x1
[8] return [7] -> 24
[9] __primitive.assert 23 4 :: i? x1
[10] __primitive.open 1 11 -> 12 :: y x2
[11] val "stream,in:std" :: s x1
[12] __primitive.dep 10 is File :: o x1
[13] __primitive.sub 3 14 :: i x1
[14] val 1 :: i x1
[15] io.getline_loop 10 12 17 -> 21 18 :: y x3
[17] val "" :: s x1
[18] __primitive.dep 15 :: s x1
[19] __primitive.from_string 18 :: i? x1
[20] __primitive.add 19 2 :: i x1
[21] __primitive.dep 15 is File :: o x1
[22] __primitive.close 15 21 :: y x1
[23] jump tests.sum_times2:times:iterate 13 20 22 :: i x1
[24] return [9]

___ tests.sum_times2v (2 -> 1) ___
[1] var :: ?i x1
[2] var :: ?y x1
[3] val 0 :: i x1
[4] jump tests.sum_times2v:times:iterate 1 3 2 :: i x1
[5] return [4]

___ tests.sum_times2v:times:iterate (3 -> 1) x2 rec ___
[1] changing var :: ?y x1
[2] changing var :: ?i x2
[3] changing var :: ?i x2
[4] __primitive.gt &3 5 :: y x2
[5] val 0 :: i x1
[6] __primitive.not &4 :: y x1
[7] __primitive.assert &2 6 :: i? x1
[8] return [7] -> 33
[9] __primitive.assert 32 4 :: i? x1
[10] __primitive.open 1 11 -> 12 :: y x2
[11] val "stream,in:std" :: s x1
[12] __primitive.dep 10 is File :: o x1
[13] __primitive.sub 3 14 :: i x1
[14] val 1 :: i x1
[15] io.getline_loop 10 12 17 -> 21 18 :: y x3
[17] val "" :: s x1
[18] __primitive.dep 15 :: s x2
[19] __primitive.from_string &18 :: i? x1
[20] __primitive.add 19 2 :: i x1
[21] __primitive.dep 15 is File :: o x1
[22] __primitive.close 15 21 :: y x1
[23] __primitive.open 22 24 -> 25 :: y x2
[24] val "stream,out:std" :: s x1
[25] __primitive.dep 23 is File :: o x1
[26] __primitive.strcat &27 18 :: s x1
[27] val "'" :: s x2
[28] __primitive.strcat 26 27 :: s x1
[29] __primitive.write 23 25 28 -> 30 :: y x2
[30] __primitive.dep 29 is File :: o x1
[31] __primitive.close 29 30 :: y x1
[32] jump tests.sum_times2v:times:iterate 13 20 31 :: i x1
[33] return [9]

___ tests.tag (2 -> 2) ___
[1] var :: ?a x1
[2] var :: ?a x2
[3] __primitive.quote &2 1 :: l x1
[4] return [2 3]

___ tests.test_ap11 (2 -> 1) ___
[1] var :: ?l x1
[2] var :: ?a x1
[3] __primitive.ap 2 1 -> 4 :: v? x1
[4] __primitive.dep 3 :: a x1
[5] return [4]

___ tests.test_ap12 (2 -> 2) ___
[1] var :: ?l x1
[2] var :: ?a x1
[3] __primitive.ap 2 1 -> 5 4 :: v? x2
[4] __primitive.dep 3 :: a x1
[5] __primitive.dep 3 :: a x1
[6] return [5 4]

___ tests.test_ap21 (3 -> 1) ___
[1] var :: ?l x1
[2] var :: ?a x1
[3] var :: ?a x1
[4] __primitive.ap 3 2 1 -> 5 :: v? x1
[5] __primitive.dep 4 :: a x1
[6] return [5]

___ tests.three_reads (4 -> 4) ___
[1] var :: ?i x1
[2] var :: ?i x1
[3] var :: ?i x1
[4] var is Array :: ?o x1
[5] __primitive.read_array 4 3 -> 10 is Array :: o x2
[6] __primitive.read_array 5 2 -> 9 is Array :: o x2
[7] __primitive.read_array 6 1 -> 8 is Array :: o x2
[8] __primitive.dep 7 :: i x1
[9] __primitive.dep 6 :: i x1
[10] __primitive.dep 5 :: i x1
[11] return [7 10 9 8]

___ tests.three_writes (7 -> 1) ___
[1] var :: ?i x1
[2] var :: ?i x1
[3] var :: ?i x1
[4] var :: ?i x1
[5] var :: ?i x1
[6] var :: ?i x1
[7] var is Array :: ?o x1
[8] __primitive.write_array 7 6 5 is Array :: o x1
[9] __primitive.write_array 8 4 3 is Array :: o x1
[10] __primitive.write_array 9 2 1 is Array :: o x1
[11] return [10]

___ tests.two_to_twenty (1 -> 1) ___
[1] var in [2, 20] :: ?i x1
[2] __primitive.div 1 3 in [1, 10] :: i? x2
[3] val 2 :: i x1
[4] __primitive.gte &2 5 :: y x1
[5] val 1 :: i x1
[6] __primitive.assert 2 4 in [1, 10] :: i? x2
[7] __primitive.lte &6 8 :: y x1
[8] val 10 :: i x1
[9] __primitive.assert 6 7 in [1, 10] :: i? x1
[10] return [9]

___ tests.vifte_collatz (1 -> 1) x4 rec ___
[1] changing var >= 1 :: ?i x5
[2] __primitive.bitand &1 &3 in [0, 1] :: i x2
[3] val 1 :: i x5
[4] __primitive.eq &2 &3 :: y x2
[5] __primitive.assert &8 &4 >= 4 :: i? x2
[6] __primitive.mul &1 7 >= 3 :: i x1.
[7] val 3 :: i x1
[8] __primitive.add 6 &3 >= 4 :: i x2.
[9] __primitive.gt &5 &3 :: y x2
[10] __primitive.assert 5 &9 >= 4 :: i? x4
[11] __primitive.seq 12 &10 :: v x1
[12] jump tests.vifte_collatz 10 :: v x1
[13] return [11] -> 25
[14] __primitive.eq 2 15 :: y x2
[15] val 0 :: i x1
[16] __primitive.assert &17 &14 >= 2 :: i? x2
[17] __primitive.div &1 18 >= 2 :: i? x2
[18] val 2 :: i x1
[19] __primitive.gt &16 3 :: y x2
[20] __primitive.assert 16 &19 >= 2 :: i? x4
[21] __primitive.assert 8 4 >= 4 :: i? x1
[22] __primitive.assert 21 9 >= 4 :: i? x2
[23] __primitive.seq 24 &20 :: i x1
[24] jump tests.vifte_collatz 20 :: i x1
[25] return [23] -> 32
[26] __primitive.unless &1 &10 >= 1 :: i x1
[27] __primitive.unless 26 &22 >= 1 :: i x1
[28] __primitive.unless 27 &20 >= 1 :: i x1
[29] __primitive.assert 17 14 >= 2 :: i? x1
[30] __primitive.assert 29 19 >= 2 :: i? x2
[31] __primitive.unless 28 30 >= 1 :: i x1
[32] return [31] -> 37
[33] __primitive.unless 1 10 >= 4 :: i x1
[34] __primitive.unless 33 22 >= 4 :: i x1
[35] __primitive.unless 34 20 >= 4 :: i x1
[36] __primitive.unless 35 30 >= 4 :: i x1
[37] return [36]

___ tests.vifte_collatz_step (1 -> 1) x2 ___
[1] var >= 1 :: ?i x3
[2] __primitive.bitand &1 &3 in [0, 1] :: i x2
[3] val 1 :: i x5
[4] __primitive.eq &2 &3 :: y x1
[5] __primitive.assert 8 4 >= 4 :: i? x2
[6] __primitive.mul &1 7 >= 3 :: i x1
[7] val 3 :: i x1
[8] __primitive.add 6 &3 >= 4 :: i x1
[9] __primitive.gt &5 &3 :: y x1
[10] __primitive.assert 5 9 >= 4 :: i? x1
[11] return [10] -> 19
[12] __primitive.eq 2 13 :: y x1
[13] val 0 :: i x1
[14] __primitive.assert 15 12 >= 2 :: i? x2
[15] __primitive.div 1 16 >= 2 :: i? x1
[16] val 2 :: i x1
[17] __primitive.gt &14 3 :: y x1
[18] __primitive.assert 14 17 >= 2 :: i? x1
[19] return [18]

___ tests.vifte_quote (1 -> 1) x2 ___
[1] var :: ?i x2
[2] __primitive.add 1 3 :: i x1
[3] val 1 :: i x1
[4] return [2] -> 7
[5] __primitive.unless 6 1 is 0 :: i x1
[6] val 0 :: i x1
[7] return [5]

___ tests.zip_add (2 -> 1) ___
[1] var :: ?l x1
[2] var :: ?l x1
[3] jump tests.zip_add:zip 2 1 :: l x1
[4] return [3]

___ tests.zip_add:zip (2 -> 1) rec row ___
[1] changing var :: ?l x1
[2] changing var :: ?l x1
[3] __primitive.ap 2 -> 4 :: l? x2
[4] __primitive.dep 3 :: i x3
[5] __primitive.ap 1 -> 6 :: l? x2
[6] __primitive.dep 5 :: i x3
[7] __primitive.seq 8 &4 :: l x1
[8] __primitive.seq 13 &6 :: l x1
[9] __primitive.add &4 &6 :: i x1
[10] __primitive.seq 11 4 :: l x1
[11] __primitive.seq 12 6 :: l x1
[12] jump tests.zip_add:zip 3 5 :: l x1
[13] __primitive.pushr 10 9 :: l x1
[14] return [7]

