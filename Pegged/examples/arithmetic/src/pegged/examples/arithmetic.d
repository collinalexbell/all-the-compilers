/**
This module contains a example of a reusable arithmetic expression grammar and
a recursive ParseTree parser that returns the evaluation of the arithmetic expression
*/
module pegged.examples.arithmetic;

import std.conv: to;

import pegged.grammar;

mixin(grammar(`
# Arithmetic grammar with variable terminal
Arithmetic:
    Term     < Factor (Add / Sub)*
    Add      < "+" Factor
    Sub      < "-" Factor
    Factor   < Primary (Mul / Div)*
    Mul      < "*" Primary
    Div      < "/" Primary
    Primary  < Parens / Neg / Number / Variable
    Parens   < :"(" Term :")"
    Neg      < "-" Primary
    Number   < ~([0-9]+)
    Variable <- identifier
`));

mixin(grammar(`
# Arithmetic grammar without variable terminal
ArithmeticNoVar:
    Term     < Factor (Add / Sub)*
    Add      < "+" Factor
    Sub      < "-" Factor
    Factor   < Primary (Mul / Div)*
    Mul      < "*" Primary
    Div      < "/" Primary
    Primary  < Parens / Neg / Number
    Parens   < :"(" Term :")"
    Neg      < "-" Primary
    Number   < ~([0-9]+)
`));

/**
 * Parses a ParseTree as a arithmetic expression
 * @param T arithmetic type. By default is float.
 * @param grammarName Name of the arithmetic grammar. Must be "ArithmeticNoVar" or "Arithmetic". By default is "ArithmeticNoVar"
 * @param ParseTree p ParseTree generated by ArithmeticNoVar
 * @param variable Associative array with variable values
 * @return The result of the arithmetic expresion. If the ParseTree is invalid
 *  or contains unexpected nodes, then will return NaN if T is a float or 0
 *  if T is a integral
 */
T parseArithmetic(T = float, string grammarName = "ArithmeticNoVar")(ParseTree p,
    const ref T[string] variables)
if (__traits(isArithmetic, T) && (grammarName == "ArithmeticNoVar" || grammarName == "Arithmetic"))
{
    switch (p.name)
    {
        case grammarName:
            return parseArithmetic!(T, grammarName)(p.children[0], variables);
        case grammarName ~ ".Term":
            T val;
            static if (__traits(isFloating, T)) {
                val = 0.0; // float init is NaN
            }
            foreach(child; p.children) {
                val += parseArithmetic!(T, grammarName)(child, variables);
            }
            return val;
        case grammarName ~ ".Add":
            return parseArithmetic!(T, grammarName)(p.children[0], variables);
        case grammarName ~ ".Sub":
            return -parseArithmetic!(T, grammarName)(p.children[0], variables);
        case grammarName ~ ".Factor":
            import std.string : lastIndexOf;
            T val = to!T(1.0);
            foreach(child; p.children) {
                const childName = child.name[lastIndexOf(child.name, '.') + 1..$];
                if (childName == "Div") {
                    val /= parseArithmetic!(T, grammarName)(child, variables);
                } else { // Process Primary and Mul nodes
                    val *= parseArithmetic!(T, grammarName)(child, variables);
                }
            }
            return val;
        case grammarName ~ ".Mul":
            return parseArithmetic!(T, grammarName)(p.children[0], variables);
        case grammarName ~ ".Div":
            return parseArithmetic!(T, grammarName)(p.children[0], variables);
        case grammarName ~ ".Primary":
            return parseArithmetic!(T, grammarName)(p.children[0], variables);
        case grammarName ~ ".Parens":
            return parseArithmetic!(T, grammarName)(p.children[0], variables);
        case grammarName ~ ".Neg":
            return -parseArithmetic!(T, grammarName)(p.children[0], variables);
        case grammarName ~ ".Number":
            return to!T(p.matches[0]);
        case grammarName ~ ".Variable":
            return variables[p.matches[0]];
        default:
            return T.init;
    }
}

/**
 * Parses a ParseTree as a arithmetic expression
 * @param T arithmetic type. By default is float.
 * @param grammarName Name of the arithmetic grammar. Must be "ArithmeticNoVar" or "Arithmetic". By default is "ArithmeticNoVar"
 * @param ParseTree p ParseTree generated by ArithmeticNoVar
 * @return The result of the arithmetic expresion. If the ParseTree is invalid
 *  or contains unexpected nodes, then will return NaN if T is a float or 0
 *  if T is a integral
 */
T parseArithmetic(T = float, string grammarName = "ArithmeticNoVar")(ParseTree p)
{
    // TODO If someone know how declare a empty T[string] as default paramater value, replace this!
    T[string] emptyDic;
    return parseArithmetic!(T, grammarName)(p, emptyDic);
}

unittest
{   // Testing parsing arithmetic expression without variables
    import std.stdio : writeln;

    string testExpression = "1 + 2 * (3 + 10 / 4)";
    auto pNoVar = ArithmeticNoVar(testExpression);

    //writeln(pNoVar);
    writeln(pNoVar.matches);

    assert(pNoVar.successful);

    // Parsing as a float
    const f = parseArithmetic(pNoVar);
    assert(f == 12.0f);

    // Parsing as integer
    const i = parseArithmetic!int(pNoVar);
    assert(i == 11);
}

unittest
{
    // Testing parsing arithmetic expression witht variables
    import std.stdio : writeln;

    string testExpressionWithVar = "1 + 2 * (3 + 10 / 4) + fooBar";
    auto p = Arithmetic(testExpressionWithVar);

    //writeln(p);
    writeln(p.matches);

    assert(p.successful);

    // Parsing as a float
    const float[string] fVars = ["fooBar": 10.25f];
    const fWithVar = parseArithmetic!(float, "Arithmetic")(p, fVars );

    assert(fWithVar == 22.25f);

    // Parsing as integer
    const iVars = ["fooBar": 10];
    const iWithVar = parseArithmetic!(int, "Arithmetic")(p, iVars);

    assert(iWithVar == 21);
}


unittest
{
    // Some additional test borrowed from simple_arithmetic
    float interpreter(string expr)
    {
        auto p = ArithmeticNoVar(expr);
        return parseArithmetic(p);
    }

    assert(interpreter("1") == 1.0);
    assert(interpreter("-1") == -1.0);
    assert(interpreter("1+1") == 2.0);
    assert(interpreter("1-1") == 0.0);

    assert(interpreter("1+1+1") == 3.0);
    assert(interpreter("1-1-1") == -1.0);
    assert(interpreter("1+1-1") == 1.0);
    assert(interpreter("1-1+1") == 1.0);
    assert(interpreter("-1+1+1") == 1.0);

    assert(interpreter("(-1+1)+1") == 1.0);
    assert(interpreter("-1+(1+1)") == 1.0);
    assert(interpreter("(-1+1+1)") == 1.0);
    assert(interpreter("1-(1-1)") == 1.0);

    assert(interpreter("1*1") == 1.0);
    assert(interpreter("1/1") == 1.0);
    assert(interpreter("-1*1") == -1.0);
    assert(interpreter("-1/1") == -1.0);

    assert(interpreter("1+2*3") == 7.0);
    assert(interpreter("1-2*3") == -5.0);
    assert(interpreter("-1-2*-3") == 5.0);
    assert(interpreter("-1+2*-3") == -7.0);

    assert(interpreter("1/2/(1/2)") == 1.0);
    assert(interpreter("1/2/1/2") == .25);
    assert(interpreter("1 - 2*3 - 2*3") == -11.0);

    assert(interpreter("2*3*3 - 3*3 + 3*4") == 21.0);
    assert(interpreter("2 * 3 * 3 - 3 * (3 + 3 * 4)") == -27.0);
}
