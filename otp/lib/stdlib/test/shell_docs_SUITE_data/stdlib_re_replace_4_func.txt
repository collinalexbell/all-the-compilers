
  [;1m-spec replace(Subject, RE, Replacement, Options) ->[0m
  [;1m                 iodata() | unicode:charlist()[0m
  [;1m                 when[0m
  [;1m                     Subject :: iodata() | unicode:charlist(),[0m
  [;1m                     RE :: mp() | iodata() | unicode:charlist(),[0m
  [;1m                     Replacement :: iodata() | unicode:charlist(),[0m
  [;1m                     Options :: [Option],[0m
  [;1m                     Option ::[0m
  [;1m                         anchored | global | notbol | noteol |[0m
  [;1m                         notempty | notempty_atstart |[0m
  [;1m                         {offset, non_neg_integer()} |[0m
  [;1m                         {newline, NLSpec} |[0m
  [;1m                         bsr_anycrlf |[0m
  [;1m                         {match_limit, non_neg_integer()} |[0m
  [;1m                         {match_limit_recursion, non_neg_integer()} |[0m
  [;1m                         bsr_unicode |[0m
  [;1m                         {return, ReturnType} |[0m
  [;1m                         CompileOpt,[0m
  [;1m                     ReturnType :: iodata | list | binary,[0m
  [;1m                     CompileOpt :: compile_option(),[0m
  [;1m                     NLSpec :: cr | crlf | lf | anycrlf | any.[0m

  Replaces the matched part of the [;;4mSubject[0m string with the
  contents of [;;4mReplacement[0m.

  The permissible options are the same as for [;;4mrun/3[0m, except that
  option[;;4m capture[0m is not allowed. Instead a [;;4m{return, ReturnType}[0m
  is present. The default return type is [;;4miodata[0m, constructed in a
  way to minimize copying. The [;;4miodata[0m result can be used directly
  in many I/O operations. If a flat [;;4mlist()[0m is desired, specify [;;4m[0m
  [;;4m{return, list}[0m. If a binary is desired, specify [;;4m{return, binary}[0m.

  As in function [;;4mrun/3[0m, an [;;4mmp()[0m compiled with option [;;4municode[0m
  requires [;;4mSubject[0m to be a Unicode [;;4mcharlist()[0m. If compilation is
  done implicitly and the [;;4municode[0m compilation option is specified
  to this function, both the regular expression and [;;4mSubject[0m are to
  specified as valid Unicode [;;4mcharlist()[0ms.

  The replacement string can contain the special character [;;4m&[0m,
  which inserts the whole matching expression in the result, and the
  special sequence [;;4m\[0mN (where N is an integer > 0), [;;4m\g[0mN, or [;;4m\g{[0m
  N[;;4m}[0m, resulting in the subexpression number N, is inserted in the
  result. If no subexpression with that number is generated by the
  regular expression, nothing is inserted.

  To insert an & or a \ in the result, precede it with a \. Notice
  that Erlang already gives a special meaning to \ in literal
  strings, so a single \ must be written as [;;4m"\\"[0m and therefore a
  double \ as [;;4m"\\\\"[0m.

  Example:

    re:replace("abcd","c","[&]",[{return,list}]).

  gives

    "ab[c]d"

  while

    re:replace("abcd","c","[\\&]",[{return,list}]).

  gives

    "ab[&]d"

  As with [;;4mrun/3[0m, compilation errors raise the [;;4mbadarg[0m exception. [;;4m[0m
  [;;4mcompile/2[0m can be used to get more information about the error.
