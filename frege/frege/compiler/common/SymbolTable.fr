--- Handling of the symbol table.
--- There are only two operations: 'enter' and 'changeSym'
module frege.compiler.common.SymbolTable where 
        -- generated by Splitter
import  frege.Prelude  hiding(error, print, println, break, <+>)
import  frege.data.TreeMap as TM(TreeMap, lookup, each, insert, union, including, contains, keys, values, fromKeys)
import  frege.lib.PP(fill, break, pretty, text, nest, msgdoc, <+>, <>, DOCUMENT)
import  frege.compiler.enums.Flags
import  frege.compiler.enums.SymState
import  frege.compiler.enums.Visibility
import  frege.compiler.types.Positions
import  frege.compiler.types.Packs
import  frege.compiler.types.QNames
import  frege.compiler.types.Types
import  frege.compiler.types.Symbols
import  frege.compiler.types.Global  as  G
import  frege.compiler.classes.Nice(Nice)
import  frege.compiler.common.Annotate(lit)
import  frege.compiler.common.Errors  as  E()
import  frege.compiler.instances.Nicer

private insertGlobal p n s = enterWith insertSym p n s


private updateGlobal p n s = enterWith updateSym p n s


private enterWith insupd p n s = do
        g <- getST        -- give me the state
        case g.packages.lookup p of
            Just tab -> do
                    ntab <- insupd tab n s
                    changeST Global.{packages <- insert p ntab}
            Nothing  -> do
                    let sp = g.unpack p
                    E.error (Symbol.pos s) (fill ([text "module", text "`" <> text sp <> text "`"]
                                                 ++  break "does not exist."))


{-- insert symbol, but make sure it does not exist yet -}
private insertSym :: Symtab -> String -> Symbol -> StG Symtab
private insertSym tab key value = case tab.lookupS key of
    Nothing -> stio (tab.insertS key value)
    Just old  -> do
        g <- getST
        let on = Symbol.nice old g
            qn = Symbol.nice value g
        case value of
            SymV {pos} -> E.error pos (msgdoc("duplicate function or pattern binding for `"
                            ++ value.name.nice g ++ "`, already bound on line "
                            ++ show old.pos))
            _          -> E.error value.pos (msgdoc("redefinition of " ++ on ++ " with " ++ qn
                                    ++ " introduced on line " ++ show old.pos))
        stio (tab.insertS key value)


{-- update symbol, but make sure it does already exist -}
private updateSym :: Symtab -> String -> Symbol -> StG Symtab
private updateSym tab key value = case tab.lookupS key of
    Just _   -> stio (tab.insert key value)
    Nothing  -> do
        g <- getST
        let qn = Symbol.nice value g
        E.error value.pos (fill (break ("cannot update " ++ qn ++ "  " ++ show (keys tab))))
        stio (tab.insert key value)


{--
 * Enter symbol into appropriate symbol table.

 * It is an error if prerequisites like packages or namespaces are not there.

 * It is an error if the symbol is already there, except in the following cases:

 - a symbol hides a symbolic link that points in another package
 - a non native variable finds that an annotation is already there
 - an annotation finds that a non native variable is already there
 -}
enter :: Symbol -> StG ()
enter sym
    | sym.{alias?}  = do
            g <- getST
            let asy = g.find sym.alias
            case asy of
                Nothing | g.our sym.alias -> do
                    let sa  = sym.nicer g
                        -- st  = sym.alias.nice g
                    E.fatal sym.pos (fill (break ("can't enter " ++ sa ++ " for unknown target")))
                sonst -> enterOrUpdate
    | otherwise    = enterOrUpdate
    where
        enterOrUpdate
            | Local{uid} <- sym.name = do
                g <- getST
                uid <- if uid > 0 then return uid else uniqid
                case g.find sym.name of
                    Nothing
                        | uid == sym.sid  -> do
                            E.logmsg TRACE3 sym.pos (text("enterLocal: " ++
                                show sym.sid ++
                                " " ++ sym.nice g ++ " :: " ++ sym.typ.nice g ++
                                ", " ++ show sym.state))
                            changeST Global.{locals <- TreeMap.insertkvI uid sym}
                        | otherwise = E.fatal sym.pos (text ("enterLocal: uid=" ++
                            show uid ++ ", sid=" ++ show sym.sid ++ " for " ++ show sym.name))
                    Just that -> E.error sym.pos (text ("already entered: " ++ nice sym g ++ " with uid " ++ show uid))
            | otherwise = do
                g <- getST
                case g.find sym.name of
                    Nothing -> enterByName sym
                    Just that
                        | SymL{} <- that, SymL{} <- sym, that.alias == sym.alias = pure ()  -- do nothing
                        | SymL {alias} <- that, alias.getpack != sym.name.getpack = do
                                E.warn sym.pos (fill (break("hiding previously (line " ++ show that.pos
                                    ++ ") imported "
                                    ++ that.nice g ++ " through " ++ sym.nice g)))
                                changeSym sym
                        | otherwise = enterByName sym   -- error message follows


changeSym :: Symbol ->  StG ()
changeSym sym | sym.sid == 0 = do
        u <- uniqid
        changeSym sym.{sid=u}
changeSym sym = do
        g <- getST
        E.logmsg TRACE3 sym.pos (fill [text "changeSym", lit sym.sid,  text (sym.nice g ++ " :: " ++
            (if sym.{typ?}   then sym.typ.nice g else "") ++ ", " ++
            (if sym.{state?} then show sym.state else ""))])
        case sym.name of
            TName p b -> updateGlobal p sym.name.key sym
            VName p b -> updateGlobal p sym.name.key sym
            MName t b -> do
                g <- getST
                let tsy = g.findit t
                case tsy of
                    Nothing -> do
                        let qn =  t.nice g
                        E.error sym.pos (fill ([text "namespace", text "`" <> text qn <> text "`"] ++ break "does not exist"))
                    Just typ | typ.{env?} = do
                                env <- updateSym typ.env sym.name.key sym
                                updateGlobal t.pack t.key typ.{env}
                             | otherwise = E.fatal sym.pos (text "no environment:" <+> text (t.nice g))
            Local uid s -> do
                --  g <- getST
                when (sym.sid != uid) do
                    E.fatal sym.pos (text("changeSym: name =" ++ show sym.name
                        ++ ", sid=" ++ show sym.sid))
                changeST Global.{locals <- TreeMap.updatekvI uid sym}


private enterByName :: Symbol -> StG ()
private enterByName sym | sym.sid == 0 = do
        u <- uniqid
        enterByName sym.{sid=u}
private enterByName sym = do
    g <- getST
    E.logmsg TRACE3 sym.pos (fill (break ("enterByName " ++ sym.nice g ++ " " ++ show sym.sid ++ " "
        ++ (if sym.{expr?} && not (isPSigma sym.typ)
                then " :: " ++ sym.typ.nicer g else ""))))
    case sym.name of
        TName p b -> insertGlobal p sym.name.key sym
        VName p b -> insertGlobal p sym.name.key sym
        MName t b -> do
            g <- getST
            let tsy = g.findit t
            case tsy of
                Nothing -> do
                    let qn = t.nice g
                    E.error sym.pos (msgdoc("namespace `" ++ qn ++ "` does not exist"))
                Just typ | typ.{env?} = do
                            env <- insertSym typ.env sym.name.key sym
                            updateGlobal t.pack (t.key) typ.{env}
                         | otherwise = E.fatal sym.pos (msgdoc ("no environment: " ++ t.nice g))
        Local {} -> do
            g <- getST
            E.fatal sym.pos (text ("local passed to enterbyname " ++ nice sym g))


{-- create a symbolic link to given qname -}
linkq :: QName -> Symbol -> StG ()
linkq from sym = linkqv from sym sym.vis


--- create a symbolic link to a given 'Symbol' with a given 'Visibility'
linkqv :: QName -> Symbol -> Visibility -> StG ()
linkqv from sym vis = do
    g <- getST
    E.logmsg TRACE3 sym.pos (text ("`" ++ from.nice g ++ "` link to " ++ sym.nice g))
    enter (SymL {sid=0, pos=sym.pos, vis, -- doc=Nothing,
                    name=from, alias=sym.name})


-- create a symbolic link to a given 'Symbol' with a given 'Visibility' and 'Position'
linkqvp :: QName -> Symbol -> Visibility -> Position -> StG ()
linkqvp from sym vis pos = do
    g <- getST
    E.logmsg TRACE3 pos (text ("`" ++ from.nice g ++ "` link to " ++ sym.nice g))
    enter (SymL {sid=0, pos=pos, vis, -- doc=Nothing,
                    name=from, alias=sym.name})

