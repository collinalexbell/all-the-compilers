#|
@module list

Concept macro for a doubly-linked list. Apart from the `List` macro
and concept macro, the documentation in this module is for a generated
list instance of type `T`.

All of the functions that take `Iterator` arguments are defined for
`ReverseIterator`s as well, notwithstanding that there is no
documentation for those instances.

The `List` type implements the following concepts:

  * `FrontInsertionSequence`;
  * `BackInsertionSequence`; and
  * `ReversibleContainer`.

Its iterators implement `OutputIterator` and `BidirectionalIterator`.

|#
(module list (attr cto))

(import cstdio)
(import macros)
(import cstdlib)
(import math)
(import concepts)
(import algorithms)
(import utility)

#|
@macro List

Expands to the concrete type name of the `List` generated by way of
the concept macro.

@param T    The type node.
|#
(def List
  (macro extern (T)
    (let ((typename (array-of 250 char)))
      (and (not (make-type-string mc "list" T typename))
           (return T))
      (def n (var auto (p DNode) (std.macros.mnfv mc typename)))
      (return n))))

(using-namespace std.macros
(using-namespace std.concepts

#|
@concept-macro List

Expands to a `List` definition over the relevant type.

@param T    The type node.
@param-type Type
|#
(def-concept-macro List extern ((T Type))
  (prefer-ref-bindings (uq T) 1)
  (let ((typename     (array-of 250 char))
        (nodetypename (array-of 250 char))
        (etypename    (array-of 250 char)))

    ; Generate the type names and nodes, and register the main 'list'
    ; type name.
    (and (not (make-type-string mc "list" T typename))
         (return (nullptr DNode)))
    (and (not (make-type-string mc "listnode" T nodetypename))
         (return (nullptr DNode)))
    (and (not (make-type-display-string mc "List" T etypename))
         (return (nullptr DNode)))

    (def typenode     (var auto (p DNode) (mnfv mc typename)))
    (def nodetypenode (var auto (p DNode) (mnfv mc nodetypename)))

    (register-type mc typename etypename)

    (def copy-functions (var auto (p DNode)
      (if copy-disabled-1
          (qq do (def setf-copy-disabled (fn extern bool ((dst (List (uq T)))))))
          (qq do (def setf-copy-init (fn extern bool ((dst (p (List (uq T))))
                                               (src (p (List (uq T)))))
                   (init (@ dst))
                   (let ((b1 \ (begin (@ src)))
                         (e1 \ (end   (@ src)))
                         (b2 \ (begin (@ dst)))
                         (e2 \ (end   (@ dst))))
                     (for true (!= b1 e1) (do (setv b1 (successor b1))
                                              (setv b2 (successor b2)))
                       (sink b2 (@ (source b1)))))
                   true))
                 (def setf-copy-assign (fn extern bool ((dst (p (List (uq T))))
                                                        (src (p (List (uq T)))))
                   (clear (@ dst))
                   (setf-copy-init dst src)))))))

    (def is-equality-comparable
      (var auto bool (not (has-errors mc
                                      (qq std.concepts.implements
                                          (uq T) EqualityComparable)))))
    (def is-less-than-comparable
      (var auto bool (not (has-errors mc
                                      (qq std.concepts.implements
                                          (uq T) LessThanComparable)))))

    (def equality-comparable-forms (var auto (p DNode)
        (if is-equality-comparable
            (qq do (mfor F (= !=) (instantiate F (List (uq T))))
                   (implement EqualityComparable (List (uq T))))
            (qq no-op))))
    (def less-than-comparable-forms (var auto (p DNode)
        (if is-less-than-comparable
            (qq do (mfor F (< <= > >=) (instantiate F (List (uq T))))
                   (implement LessThanComparable (List (uq T))))
            (qq no-op))))

    (qq do

    (using-namespace std.macros
    (using-namespace std.concepts

    (import derivations)

    (def (uq nodetypenode)
      (struct extern
          ((element (uq T))
           (next    (p (uq nodetypenode)))
           (prev    (p (uq nodetypenode))))))

    #|
    @struct (List T)

    The core list structure type.

    @linkage extern
    |#
    (def (uq typenode)
      (struct extern
          ((first (p (uq nodetypenode)))
           (last  (p (uq nodetypenode))))))

    #|
    @fn init

    Initialise a list.

    @param lst      A list reference.
    |#
    (def init
      (fn extern bool ((lst (ref (List (uq T)))))
        (setf (:@ lst first) (nullptr (uq nodetypenode)))
        (setf (:@ lst last)  (nullptr (uq nodetypenode)))
        true))

    #|
    @fn empty

    Determine whether the list is empty.

    @param lst      A list reference.
    |#
    (def empty
      (fn extern bool ((lst (ref (const (List (uq T))))))
        (null (@:@ lst first))))

    #|
    @fn size

    Returns the number of elements in the list.

    @param lst      A list reference.
    |#
    (def size
      (fn extern size ((lst (ref (const (List (uq T))))))
        (let ((n     size 0)
              (first \ (cast (@:@ lst first) (p (uq nodetypenode)))))
          (while (not (null first))
            (setv n (+ n (cast 1 size)))
            (setv first (@:@ first next)))
          n)))

    #|
    @fn max-size

    Returns the number of elements that can be accommodated by the
    list.

    @param lst      A list reference.
    |#
    (def max-size
      (fn extern size ((lst (ref (const (List (uq T))))))
        (- (cast 0 size) (cast 1 size))))

    #|
    @macro value-type

    Expands to the underlying value type (i.e. `T`) of the list. This
    only uses the type node for dispatch purposes, so it's safe to
    call this with e.g. `(nullptr (List T))` as the argument.

    @param lst      A type node.
    |#
    (def value-type
      (macro extern ((lst (p (List (uq T)))))
        (qq do (uq T))))

    #|
    @macro size-type

    Expands to the underlying size type of the list.

    @param lst      A type node.
    |#
    (def size-type
      (macro extern ((lst (p (List (uq T)))))
        (qq do size)))

    #|
    @macro difference-type

    Expands to the underlying iterator difference type of the list.

    @param lst      A type node.
    |#
    (def difference-type
      (macro extern ((lst (p (List (uq T)))))
        (qq do ptrdiff)))

    #|
    @fn front

    Returns a pointer to the value of the first element in the list.

    @param lst      A list reference.
    |#
    (def front
      (fn extern (p (uq T)) ((lst (ref (const (List (uq T))))))
        (:@ (@:@ lst first) element)))

    #|
    @fn back

    Returns a pointer to the value of the last element in the list.

    @param lst      A list reference.
    |#
    (def back
      (fn extern (p (uq T)) ((lst (ref (const (List (uq T))))))
        (:@ (@:@ lst last) element)))

    #|
    @fn push-back

    Adds an element to the end of the list.

    @param lst      A list reference.
    @param value    The value to add to the list.
    |#
    (def push-back
      (fn extern bool ((lst (ref (List (uq T))))
                       (value ((uq tpw-1) (uq T))))
        (let ((new-node \ (malloc' 1 (uq nodetypenode))))
          (setf (:@ new-node element) ((uq tvw-1) value))
          (setf (:@ new-node next) (nullptr (uq nodetypenode)))
          (setf (:@ new-node prev) (nullptr (uq nodetypenode)))
          (and (null (@:@ lst first))
               (do (setf (:@ lst first) new-node)
                   (setf (:@ lst last)  new-node)
                   (return true)))
          (let ((last-node \ (@:@ lst last)))
            (setf (:@ last-node next) new-node)
            (setf (:@ new-node  prev) last-node)
            (setf (:@ lst last) new-node)))
        true))

    #|
    @fn pop-back

    Removes an element from the end of the list.

    @param lst      A list reference.
    |#
    (def pop-back
      (fn extern void ((lst (ref (List (uq T)))))
        (and (empty (@ lst)) (return))
        (let ((last-node        \ (@:@ lst last))
              (second-last-node \ (@:@ last-node prev))
              (size             \ (size (@ lst))))
          (if (null second-last-node)
              (do (setf (:@ lst first) (nullptr (uq nodetypenode)))
                  (setf (:@ lst last)  (nullptr (uq nodetypenode))))
              (do (setf (:@ second-last-node next)
                        (nullptr (uq nodetypenode)))
                  (setf (:@ lst last) second-last-node)))
          (let ((value \ (:@ last-node element)))
            (destroy (@ value)))
            (free' last-node))
        (return)))

    #|
    @fn push-front

    Adds an element to the beginning of the list.

    @param lst      A list reference.
    @param value    The value to add to the list.
    |#
    (def push-front
      (fn extern bool ((lst (ref (List (uq T))))
                       (value ((uq tpw-1) (uq T))))
        (let ((new-node \ (malloc' 1 (uq nodetypenode))))
          (setf (:@ new-node element) ((uq tvw-1) value))
          (setf (:@ new-node next) (nullptr (uq nodetypenode)))
          (setf (:@ new-node prev) (nullptr (uq nodetypenode)))
          (and (null (@:@ lst first))
               (do (setf (:@ lst first) new-node)
                   (setf (:@ lst last)  new-node)
                   (return true)))
          (let ((first-node \ (@:@ lst first)))
            (setf (:@ first-node prev) new-node)
            (setf (:@ new-node  next) first-node)
            (setf (:@ lst first) new-node)))
        true))

    #|
    @fn pop-front

    Removes an element from the beginning of the list.

    @param lst      A list reference.
    |#
    (def pop-front
      (fn extern void ((lst (ref (List (uq T)))))
        (and (empty (@ lst)) (return))
        (let ((first-node  \ (@:@ lst first))
              (second-node \ (@:@ first-node next))
              (size        \ (size (@ lst))))
          (if (null second-node)
              (do (setf (:@ lst first) (nullptr (uq nodetypenode)))
                  (setf (:@ lst last)  (nullptr (uq nodetypenode))))
              (do (setf (:@ second-node prev)
                        (nullptr (uq nodetypenode)))
                  (setf (:@ lst first) second-node)))
          (let ((value \ (:@ first-node element)))
            (destroy (@ value)))
            (free' first-node))
        (return)))

    #|
    @struct (Iterator (List T))

    @linkage extern
    |#
    (def (Iterator (List (uq T)))
      (struct extern ((node (p (uq nodetypenode))))))

    #|
    @fn begin

    Returns the iterator for the first list element.

    @param lst      A list reference.
    |#
    (def begin
      (fn extern (Iterator (List (uq T))) ((lst (ref (List (uq T)))))
        ((Iterator (List (uq T))) ((node (@:@ lst first))))))

    #|
    @fn end

    Returns the iterator representing the end of the list (sentinel).

    @param lst      A list reference.
    |#
    (def end
      (fn extern (Iterator (List (uq T))) ((lst (ref (List (uq T)))))
        ((Iterator (List (uq T))) ((node (nullptr (uq nodetypenode)))))))

    #|
    @macro value-type

    Expands to the underlying value type (i.e. `T`) of the iterator.

    @param iter     A type node.
    |#
    (def value-type
      (macro extern ((iter (p (Iterator (List (uq T))))))
        (qq do (uq T))))

    #|
    @macro distance-type

    Expands to the underlying distance type of the iterator.

    @param iter     A type node.
    |#
    (def distance-type
      (macro extern ((iter (p (Iterator (List (uq T))))))
        (qq do size)))

    #|
    @fn source

    Returns a pointer to the iterator's value.

    @param iter     An iterator.
    |#
    (def source
      (fn extern (p (uq T)) ((iter (Iterator (List (uq T)))))
        (:@ (@: iter node) element)))

    #|
    @fn sink

    Set the given value at the specified position in the list.

    @param iter     An iterator.
    @param v        The new value.
    |#
    (def sink
      (fn extern bool ((iter (Iterator (List (uq T))))
                       (v ((uq tpw-1) (uq T))))
        (setf (:@ (@: iter node) element) ((uq tvw-1) v))))

    #|
    @fn successor

    Returns the iterator for the position that follows the argument
    iterator.

    @param iter     An iterator.
    |#
    (def successor
      (fn extern (Iterator (List (uq T))) ((iter (Iterator (List (uq T)))))
        ((Iterator (List (uq T))) ((node (@:@ (@: iter node) next))))))

    #|
    @fn predecessor

    Returns the iterator for the position just before the argument
    iterator.

    @param iter     An iterator.
    |#
    (def predecessor
      (fn extern (Iterator (List (uq T))) ((iter (Iterator (List (uq T)))))
        ((Iterator (List (uq T))) ((node (@:@ (@: iter node) prev))))))

    #|
    @fn =

    @param iter1    The first iterator.
    @param iter2    The second iterator.
    |#
    (def =
      (fn extern bool ((iter1 (Iterator (List (uq T))))
                       (iter2 (Iterator (List (uq T)))))
        (p= (@: iter1 node)
            (@: iter2 node))))

    (implement Type (Iterator (List (uq T))))
    (instantiate != (Iterator (List (uq T))))

    #|
    @struct (ReverseIterator (List T))

    @linkage extern
    |#
    (def (ReverseIterator (List (uq T)))
      (struct extern ((node (p (uq nodetypenode))))))

    #|
    @fn rbegin

    Returns the iterator for the last list element.

    @param lst      A list reference.
    |#
    (def rbegin
      (fn extern (ReverseIterator (List (uq T))) ((lst (ref (List (uq T)))))
        ((ReverseIterator (List (uq T)))
         ((node (@:@ lst last))))))

    #|
    @fn rend

    Returns the iterator representing the beginning of the list (sentinel).

    @param lst      A list reference.
    |#
    (def rend
      (fn extern (ReverseIterator (List (uq T))) ((lst (ref (List (uq T)))))
        ((ReverseIterator (List (uq T)))
         ((node (nullptr (uq nodetypenode)))))))

    (def value-type
      (macro extern ((lstiter (p (ReverseIterator (List (uq T))))))
        (qq do (uq T))))

    (def distance-type
      (macro extern ((veciter (p (ReverseIterator (List (uq T))))))
        (qq do size)))

    (def source
      (fn extern (p (uq T)) ((iter (ReverseIterator (List (uq T)))))
        (:@ (@: iter node) element)))

    (def sink
      (fn extern bool ((iter (ReverseIterator (List (uq T))))
                       (sinker ((uq tpw-1) (uq T))))
        (setf (:@ (@: iter node) element) ((uq tvw-1) sinker))
        true))

    (def successor
      (fn extern (ReverseIterator (List (uq T)))
                    ((iter (ReverseIterator (List (uq T)))))
        ((ReverseIterator (List (uq T)))
          ((node (@:@ (@: iter node) prev))))))

    (def predecessor
      (fn extern (ReverseIterator (List (uq T)))
                    ((iter (ReverseIterator (List (uq T)))))
        ((ReverseIterator (List (uq T)))
          ((node (@:@ (@: iter node) next))))))

    (def =
      (fn extern bool ((iter1 (ReverseIterator (List (uq T))))
                       (iter2 (ReverseIterator (List (uq T)))))
        (p= (@: iter1 node)
            (@: iter2 node))))

    (implement Type (ReverseIterator (List (uq T))))
    (instantiate != (ReverseIterator (List (uq T))))

    #|
    @fn insert

    Inserts a new element into the list before the specified position,
    and returns the iterator for the new element.

    @param lst      The list reference.
    @param iter     The iterator for the position.
    @param value    The new value.
    |#
    (def insert
      (fn extern (Iterator (List (uq T)))
                    ((lst   (ref (List (uq T))))
                     (iter  (Iterator (List (uq T))))
                     (value ((uq tpw-1) (uq T))))
        (and (empty (@ lst))
             (do (push-back (@ lst) ((uq tvw-1) value))
                 (return (begin (@ lst)))))
        (let ((new-node \ (malloc' 1 (uq nodetypenode)))
              (prev-node \ (if (null (@: iter node))
                               (:@ lst last)
                               (:@ (@: iter node) prev))))
          (setf (:@ new-node element) ((uq tvw-1) value))
          (setf (:@ new-node next) (@: iter node))
          (setf (:@ new-node prev) (@ prev-node))
          (setf (:@ (@ prev-node) next) new-node)
          (setf prev-node new-node)
          (return iter))))

    #|
    @fn erase

    Remove the element at the specified position from the list.

    @param lst      The list reference.
    @param iter     The iterator for the position.
    |#
    (def erase
      (fn extern (Iterator (List (uq T)))
                    ((lst   (ref (List (uq T))))
                     (iter  (Iterator (List (uq T)))))
        (and (empty (@ lst))
             (return iter))
        (let ((node      \ (@: iter node))
              (prev-node \ (@:@ node prev))
              (next-node \ (@:@ node next)))
          (if (not (null prev-node))
              (setf (:@ prev-node next) next-node)
              (setf (:@ lst first) next-node))
          (if (not (null next-node))
              (setf (:@ next-node prev) prev-node)
              (setf (:@ lst last) prev-node))
          (let ((value \ (:@ node element)))
            (destroy (@ value)))
            (free' node))
        iter))

    #|
    @fn clear

    Remove all of the elements from the list.

    @param lst      The list reference.
    |#
    (def clear
      (fn extern bool ((lst (ref (List (uq T)))))
        (while (not (empty (@ lst)))
          (pop-front (@ lst)))
        true))

    #|
    @fn swap

    @param lst1     The first list reference.
    @param lst2     The second list reference.
    |#
    (def swap
      (fn extern void ((lst1 (ref (List (uq T))))
                       (lst2 (ref (List (uq T)))))
        (let ((first-1 \ (@:@ lst1 first))
              (last-1  \ (@:@ lst1 last))
              (first-2 \ (@:@ lst2 first))
              (last-2  \ (@:@ lst2 last)))
          (setf (:@ lst1 first) first-2)
          (setf (:@ lst1 last)  last-2)
          (setf (:@ lst2 first) first-2)
          (setf (:@ lst2 last)  last-2)
          (return))))

    (def setf-move-init (fn extern bool ((dst (p (List (uq T))))
                                         (src (rv-ref (List (uq T)))))
      (init (@ dst))
      (let ((b1 \ (begin (@ src)))
            (e1 \ (end   (@ src)))
            (b2 \ (begin (@ dst)))
            (e2 \ (end   (@ dst))))
        (for true (!= b1 e1) (do (setv b1 (successor b1))
                                 (setv b2 (successor b2)))
          (sink b2 (move (@ (source b1))))))
      true))

    (def setf-move-assign (fn extern bool ((dst (p (List (uq T))))
                                           (src (rv-ref (List (uq T)))))
      (clear (@ dst))
      (setf-move-init dst (move (@ src)))))

    (uq copy-functions)

    (implement Swappable (List (uq T)))
    (implement Container (List (uq T)))
    (implement Type (List (uq T)))
    (uq equality-comparable-forms)
    (uq less-than-comparable-forms)

    (def destroy
      (fn extern void ((lstp (ref (List (uq T)))))
        (clear (@ lstp))
        (return)))

    (instantiate swap (Iterator (List (uq T))))
    (instantiate swap (ReverseIterator (List (uq T))))
    (implement OutputIterator (Iterator (List (uq T))))
    (implement OutputIterator (ReverseIterator (List (uq T))))
    (implement BidirectionalIterator (Iterator (List (uq T))))
    (implement BidirectionalIterator (ReverseIterator (List (uq T))))
    (implement FrontInsertionSequence (List (uq T)))
    (implement BackInsertionSequence (List (uq T)))
    (implement ReversibleContainer (List (uq T)))))
)))))
