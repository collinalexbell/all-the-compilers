#|
@module map

Concept macro for a map. Apart from the `Map` macro and concept macro,
the documentation in this module is for a generated set instance
mapping from type `Tk` to type `Tv`.

All of the functions that take `Iterator` arguments are defined for
`ReverseIterator`s as well, notwithstanding that there is no
documentation for those instances.

The `Map` type implements the following concepts:

  * `PairAssociativeContainer`;
  * `SortedAssociativeContainer`; and
  * `UniqueAssociativeContainer`.

Its iterators implement `ForwardIterator`.

|#
(module map (attr cto))

(import cstdio)
(import macros)
(import assert)
(import utility)
(import concepts)
(import derivations)
(import set)
(import algorithms)

#|
@macro Map

Expands to the concrete type name of the `Map` generated by way of
the concept macro.

@param Tk     The key type node.
@param Tv     The value type node.
|#
(def Map
  (macro extern (Tk Tv)
    (let ((typename (array-of 250 char)))
      (and (not (make-type-string mc "map" Tk Tv typename))
           (return (nullptr DNode)))
      (def n (var auto (p DNode) (std.macros.mnfv mc typename)))
      (return n))))

(using-namespace std.macros
(using-namespace std.concepts

#|
@concept-macro Map

Expands to a `Set` definition over the relevant type. Note that `Tk`
must also implement `LessThanComparable`.

@param Tk     The key type node.
@param Tv     The value type node.
|#
(def-concept-macro Map extern ((Tk EqualityComparable) (Tv Type))
  (if (has-errors mc
                  (qq std.concepts.implements (uq Tk) LessThanComparable))
      (return (qq std.concepts.implements (uq Tk) LessThanComparable))
      0)
  (prefer-ref-bindings (uq Tk) 1)
  (prefer-ref-bindings (uq Tv) 2)

  (let ((typename         (array-of 250 char))
        (etypename        (array-of 250 char))
        (pairtypename     (array-of 250 char)))
    ; Generate the type names and nodes, and register the main 'map'
    ; type.
    (and (not (make-type-string mc "map" Tk Tv typename))
         (return (nullptr DNode)))
    (and (not (make-type-string mc "mapnode" Tk Tv pairtypename))
         (return (nullptr DNode)))
    (and (not (make-type-display-string mc "Map" Tk Tv etypename))
         (return (nullptr DNode)))

    (register-type mc typename etypename)

    (def typenode     (var auto (p DNode)
                                (std.macros.mnfv mc typename)))
    (def pairtypenode (var auto (p DNode)
                                (std.macros.mnfv mc pairtypename)))

    (def pair-prefer-refs (var auto bool
      (or (not (has-errors mc (qq std.concepts.implements (uq Tk) PreferRefs)))
          (not (has-errors mc (qq std.concepts.implements (uq Tv) PreferRefs))))))

    (def pair-copy-disabled (var auto bool
      (or (not (is-copy-permitted mc (qq do (uq Tk)) false))
          (not (is-copy-permitted mc (qq do (uq Tv)) false)))))

    (prefer-ref-bindings (if pair-prefer-refs true false)
                         (if pair-copy-disabled true false) 3)

    (def pair-prefer-refs-concept (var auto (p DNode)
      (if pair-prefer-refs
          (qq implement PreferRefs (uq pairtypenode))
          (qq no-op))))

    (def equality-functions (var auto (p DNode)
      (if pair-prefer-refs
          (qq do
            (def = (fn extern bool ((p1 (ref (const (uq pairtypenode))))
                                    (p2 (ref (const (uq pairtypenode)))))
              (= (@:@ p1 first)
                 (@:@ p2 first))))

            (def both-= (fn extern bool ((p1 (ref (const (uq pairtypenode))))
                                         (p2 (ref (const (uq pairtypenode)))))
              (and (= (@:@ p1 first)
                      (@:@ p2 first))
                   (= (@:@ p1 second)
                      (@:@ p2 second))))))
          (qq do
            (def = (fn extern bool ((p1 (uq pairtypenode))
                                    (p2 (uq pairtypenode)))
              (= (@: p1 first)
                 (@: p2 first))))

            (def both-= (fn extern bool ((p1 (uq pairtypenode))
                                         (p2 (uq pairtypenode)))
              (and (= (@: p1 first)
                      (@: p2 first))
                   (= (@: p1 second)
                      (@: p2 second)))))))))

    (def less-than-function (var auto (p DNode)
      (if pair-prefer-refs
          (qq do
            (def < (fn extern bool ((p1 (ref (const (uq pairtypenode))))
                                    (p2 (ref (const (uq pairtypenode)))))
              (< (@:@ p1 first)
                 (@:@ p2 first)))))
          (qq do
            (def < (fn extern bool ((p1 (uq pairtypenode))
                                    (p2 (uq pairtypenode)))
              (< (@: p1 first)
                 (@: p2 first))))))))

    (def copy-functions (var auto (p DNode)
      (if copy-disabled-3
          (qq do (def setf-copy-disabled (fn extern bool ((dst (Map (uq Tk) (uq Tv)))))))
          (qq do
            (def setf-copy-init (fn extern bool ((dst (p (Map (uq Tk) (uq Tv))))
                                                 (src (p (Map (uq Tk) (uq Tv)))))
              (init (@ (:@ dst set)))
              (let ((b \ (begin (@ (:@ src set))))
                    (e \ (end   (@ (:@ src set)))))
                (for true (!= b e) (setv b (successor b))
                  (insert (@ (:@ dst set)) (@ (source b)))))
              true))
        
            (def setf-copy-assign (fn extern bool ((dst (p (Map (uq Tk) (uq Tv))))
                                                   (src (p (Map (uq Tk) (uq Tv)))))
              (clear (@ (:@ dst set)))
              (setf-copy-init dst src)))))))

    (qq do

    (using-namespace std.macros
    (using-namespace std.concepts

    ; Has to be instantiated, because there is a wrapper around the
    ; insert function that accepts a 'standard' pair, instead of the
    ; pair constructed for use in the set.
    (instantiate Pair (uq Tk) (uq Tv))

    ; Define the pair value type. Implement the operations required by
    ; EqualityComparable and LessThanComparable, and instantiate a set
    ; for the pair.
 
    (def (uq pairtypenode)
      (struct extern ((first  (uq Tk))
                      (second (uq Tv)))))

    (def setf-move-init
      (fn extern bool ((dst (p (uq pairtypenode)))
                       (src (rv-ref (uq pairtypenode))))
        (setf (:@ dst first)  (move (@:@ src first)))
        (setf (:@ dst second) (move (@:@ src second)))))

    (def setf-move-assign
      (fn extern bool ((dst (p (uq pairtypenode)))
                       (src (rv-ref (uq pairtypenode))))
        (setf-move-init dst (move (@ src)))))

    (uq equality-functions)

    (implement Type (uq pairtypenode))
    (uq pair-prefer-refs-concept)
    (instantiate swap (uq pairtypenode))
    (implement Swappable (uq pairtypenode))
    (instantiate != (uq pairtypenode))

    (uq less-than-function)

    (mfor F (<= > >=)
      (instantiate F (uq pairtypenode)))

    (implement EqualityComparable (uq pairtypenode))
    (implement LessThanComparable (uq pairtypenode))

    (instantiate Set (uq pairtypenode))

    #|
    @struct (Map Tk Tv)

    The core map structure type.

    @linkage extern
    |#
    (def (uq typenode)
      (struct extern ((set (Set (uq pairtypenode))))))

    #|
    @fn init

    Initialise a map.

    @param lst      A map reference.
    |#
    (def init (fn extern bool ((mapp (ref (Map (uq Tk) (uq Tv)))))
      (init (@ (:@ mapp set)))))

    #|
    @fn size

    Return the number of elements in the map.

    @param mapp     A map reference.
    |#
 
    (def size (fn extern size ((mapp (ref (Map (uq Tk) (uq Tv)))))
      (size (@ (:@ mapp set)))))

    #|
    @fn max-size

    Returns the number of elements that can be accommodated by the
    map.

    @param mapp     A map reference.
    |#
    (def max-size (fn extern size ((mapp (ref (const (Map (uq Tk) (uq Tv))))))
      (max-size (@ (:@ mapp set)))))

    #|
    @fn empty

    Determine whether the map is empty.

    @param lst      A map reference.
    |#
    (def empty (fn extern bool ((mapp (ref (const (Map (uq Tk) (uq Tv))))))
      (empty (@ (:@ mapp set)))))

    #|
    @macro key-type

    Expands to the underlying key type of the map (i.e. `Tk`). This
    only uses the type node for dispatch purposes, so it's safe to
    call this with e.g. `(nullptr (Map Tk Tv))` as the argument.

    @param lst      A type node.
    |#
    (def key-type
      (macro extern ((mapp (p (Map (uq Tk) (uq Tv)))))
        (qq do (uq Tk))))

    #|
    @macro data-type

    Expands to the underlying data type (i.e. `Tv`) of the map.

    @param lst      A type node.
    |#
    (def data-type
      (macro extern ((mapp (p (Map (uq Tk) (uq Tv)))))
        (qq do (uq Tv))))

    #|
    @macro value-type

    Expands to the underlying value type of the set. Note that for
    maps, the value type is a specially-constructed pair type that is
    not otherwise accessible. However, it is guaranteed to be a struct
    that has the members `first` and `second`, with those members
    mapping to `Tk` and `Tv` respectively.

    @param lst      A type node.
    |#
    (def value-type
      (macro extern ((mapp (p (Map (uq Tk) (uq Tv)))))
        (qq do (uq pairtypenode))))

    #|
    @macro size-type

    Expands to the underlying size type of the map.

    @param lst      A type node.
    |#
    (def size-type
      (macro extern ((mapp (p (Map (uq Tk) (uq Tv)))))
        (qq do size)))

    #|
    @macro difference-type

    Expands to the underlying iterator difference type of the map.

    @param lst      A type node.
    |#
    (def difference-type
      (macro extern ((mapp (p (Map (uq Tk) (uq Tv)))))
        (qq do ptrdiff)))

    #|
    @struct (Iterator (Map Tk) (Map Tv))

    @linkage extern
    |#
    (def (Iterator (Map (uq Tk) (uq Tv)))
      (struct extern ((mapp (p (Map (uq Tk) (uq Tv))))
                      (setiter (Iterator (Set (uq pairtypenode)))))))

    #|
    @macro value-type

    Expands to the underlying value type of the iterator. This is the
    same as that of `value-type` for the container.

    @param iter     A type node.
    |#
    (def value-type
      (macro extern ((mapiter (p (Iterator (Map (uq Tk) (uq Tv))))))
        (qq do (uq pairtypenode))))

    #|
    @fn end

    Returns the iterator representing the end of the map (sentinel).

    @param lst      A map reference.
    |#
    (def end (fn extern (Iterator (Map (uq Tk) (uq Tv))) 
                            ((mapp (ref (Map (uq Tk) (uq Tv)))))
      (let ((iter (Iterator (Map (uq Tk) (uq Tv)))))
        (setf (: iter mapp)     mapp)
        (setf (: iter setiter)  (end (@ (:@ mapp set))))
        iter)))

    #|
    @fn begin

    Returns the iterator for the first map element.

    @param lst      A map reference.
    |#
    (def begin (fn extern (Iterator (Map (uq Tk) (uq Tv))) 
                            ((mapp (ref (Map (uq Tk) (uq Tv)))))
      ((Iterator (Map (uq Tk) (uq Tv))) 
        ((mapp    mapp)
         (setiter (begin (@ (:@ mapp set))))))))

    #|
    @fn source

    Returns a pointer to the iterator's value.

    @param iter     An iterator.
    |#
    (def source (fn extern (p (value-type (nullptr (Map (uq Tk) (uq Tv)))))
                           ((iter (Iterator (Map (uq Tk) (uq Tv)))))
      (source (@: iter setiter))))

    #|
    @fn successor

    Returns the iterator for the position that follows the argument
    iterator.

    @param iter     An iterator.
    |#
    (def successor (fn extern (Iterator (Map (uq Tk) (uq Tv)))
                              ((iter (Iterator (Map (uq Tk) (uq Tv)))))
      ((Iterator (Map (uq Tk) (uq Tv))) 
        ((mapp    (@: iter mapp))
         (setiter (successor (@: iter setiter)))))))

    #|
    @fn =

    @param iter1    The first iterator.
    @param iter2    The second iterator.
    |#
    (def = (fn extern bool ((a (Iterator (Map (uq Tk) (uq Tv))))
                            (b (Iterator (Map (uq Tk) (uq Tv)))))
      (and (p= (@: a mapp)    (@: b mapp))
           (=  (@: a setiter) (@: b setiter)))))

    (implement Type (Iterator (Map (uq Tk) (uq Tv))))
    (instantiate != (Iterator (Map (uq Tk) (uq Tv))))
    (instantiate swap (Iterator (Map (uq Tk) (uq Tv))))

    #|
    @fn <

    @param iter1    The first iterator.
    @param iter2    The second iterator.
    |#
    (def < (fn extern bool ((a (Iterator (Map (uq Tk) (uq Tv))))
                            (b (Iterator (Map (uq Tk) (uq Tv)))))
      (and (p= (@: a mapp)    (@: b mapp))
           (<  (@: a setiter) (@: b setiter)))))

    (mfor F (<= > >=)
      (instantiate F (Iterator (Map (uq Tk) (uq Tv)))))
    (implement LessThanComparable (Iterator (Map (uq Tk) (uq Tv))))

    #|
    @struct (ReverseIterator (Map Tk Tv))

    @linkage extern
    |#
    (def (ReverseIterator (Map (uq Tk) (uq Tv)))
      (struct extern ((mapp (p (Map (uq Tk) (uq Tv))))
                      (setiter (ReverseIterator (Set (value-type (nullptr (Map (uq Tk) (uq Tv))))))))))

    #|
    @fn rend

    Returns the iterator representing the beginning of the map (sentinel).

    @param lst      A map reference.
    |#
    (def rend (fn extern (ReverseIterator (Map (uq Tk) (uq Tv))) 
                            ((mapp (ref (Map (uq Tk) (uq Tv)))))
      ((ReverseIterator (Map (uq Tk) (uq Tv))) ((mapp mapp)
                           (setiter (rend (@ (:@ mapp set))))))))

    #|
    @fn rbegin

    Returns the iterator for the last map element.

    @param lst      A map reference.
    |#
    (def rbegin (fn extern (ReverseIterator (Map (uq Tk) (uq Tv))) 
                            ((mapp (ref (Map (uq Tk) (uq Tv)))))
      ((ReverseIterator (Map (uq Tk) (uq Tv))) ((mapp mapp)
                           (setiter (rbegin (@ (:@ mapp set))))))))

    (def value-type
      (macro extern ((mapiter (p (ReverseIterator (Map (uq Tk) (uq Tv))))))
        (qq do (uq pairtypenode))))

    (def source (fn extern (p (value-type (nullptr (Map (uq Tk) (uq Tv)))))
                           ((iter (ReverseIterator (Map (uq Tk) (uq Tv)))))
      (source (@: iter setiter))))

    (def successor (fn extern (ReverseIterator (Map (uq Tk) (uq Tv)))
                              ((iter (ReverseIterator 
                                            (Map (uq Tk) (uq Tv)))))
      ((ReverseIterator (Map (uq Tk) (uq Tv))) 
        ((mapp    (@: iter mapp))
         (setiter (successor (@: iter setiter)))))))

    (def = (fn extern bool ((a (ReverseIterator (Map (uq Tk) (uq Tv))))
                            (b (ReverseIterator (Map (uq Tk) (uq Tv)))))
      (and (p= (@: a mapp)    (@: b mapp))
           (=  (@: a setiter) (@: b setiter)))))

    (implement Type (ReverseIterator (Map (uq Tk) (uq Tv))))
    (instantiate != (ReverseIterator (Map (uq Tk) (uq Tv))))
    (instantiate swap (ReverseIterator (Map (uq Tk) (uq Tv))))

    (def < (fn extern bool ((a (ReverseIterator (Map (uq Tk) (uq Tv))))
                            (b (ReverseIterator (Map (uq Tk) (uq Tv)))))
      (and (p= (@: a mapp)    (@: b mapp))
           (>= (@: a setiter) (@: b setiter)))))

    (mfor F (<= > >=)
      (instantiate F (ReverseIterator (Map (uq Tk) (uq Tv)))))
    (implement LessThanComparable (ReverseIterator (Map (uq Tk) (uq Tv))))

    #|
    @fn clear

    Remove all of the elements from the map.

    @param setp     The map reference.
    |#
    (def clear (fn extern void ((mapp (ref (Map (uq Tk) (uq Tv)))))
      (clear (@ (:@ mapp set)))))

    #|
    @fn insert

    Insert a new element into the map.

    @param setp     A map reference.
    @param val      The value to insert into the map.
    |#
    (def insert (fn extern bool ((mapp (ref (Map (uq Tk) (uq Tv))))
                                 (valt ((uq tpw-3) (value-type (nullptr (Map (uq Tk) (uq Tv)))))))
      (insert (@ (:@ mapp set)) ((uq tvw-3) valt))))

    #|
    @fn insert

    Insert a new element into the map.

    @param setp     A map reference.
    @param key      The key for the new map element.
    @param value    The value for the new map element.
    |#
    (def insert (fn extern bool ((mapp  (ref (Map (uq Tk) (uq Tv))))
                                 (key   ((uq tpw-1) (uq Tk)))
                                 (value ((uq tpw-2) (uq Tv))))
      (let ((np (value-type (nullptr (Map (uq Tk) (uq Tv))))))
        (setf (: np first) ((uq tvw-1) key))
        (setf (: np second) ((uq tvw-2) value))
        (insert (@ mapp) (move np)))))

    #|
    @fn find

    Find an element within the map, and return the iterator for its
    position.

    @param setp     A map reference.
    @param val      The value to find in the set.
    |#
    (def find (fn extern (Iterator (Map (uq Tk) (uq Tv))) 
                              ((mapp (ref (Map (uq Tk) (uq Tv))))
                               (key  ((uq tpw-1) (uq Tk))))
      (let ((temp (value-type (nullptr (Map (uq Tk) (uq Tv))))))
        (setf (: temp first) ((uq tvw-1) key))
        (let ((myiter \ (find (@ (:@ mapp set)) (move temp)))
              (itn    (Iterator (Map (uq Tk) (uq Tv)))))
          (setf (: itn mapp) mapp)
          (setf (: itn setiter) myiter)
          itn))))

    #|
    @fn erase

    Erase an element from the map, by specifying the iterator for its
    position.

    @param iter     The iterator.
    |#
    (def erase (fn extern bool ((iter (Iterator (Map (uq Tk) (uq Tv)))))
      (erase (@: iter setiter))))

    #|
    @fn erase

    Erase an element from the map by value.

    @param setp     A map reference.
    @param val      The value to remove from the set.
    |#
    (def erase (fn extern bool ((mapp (ref (Map (uq Tk) (uq Tv))))
                                (key ((uq tpw-1) (uq Tk))))
      (erase (@: (find (@ mapp) ((uq tvw-1) key)) setiter))))

    #|
    @fn count

    Return the number of times that the value appears in the map. For
    a `UniqueAssociativeContainer` such as `Map`, this can only return
    1 or 0, depending on whether the element is present in the set.

    @param setp     A map reference.
    @param val      The value for which the count should be determined.
    |#
    (def count (fn extern size ((mapp (ref (Map (uq Tk) (uq Tv))))
                                (key ((uq tpw-1) (uq Tk))))
      (let ((f \ (find (@ mapp) ((uq tvw-1) key))))
        (cast (if (= f (end (@ mapp))) 0 1) size))))

    #|
    @fn lower-bound

    Find the lower bound for a given value.

    @param setp     A map reference.
    @param val      The value for which the lower bound should be found.
    |#
    (def lower-bound (fn extern (Iterator (Map (uq Tk) (uq Tv)))
                                  ((mapp (ref (Map (uq Tk) (uq Tv))))
                                   (key ((uq tpw-1) (uq Tk))))
      (let ((temp (value-type (nullptr (Map (uq Tk) (uq Tv))))))
        (setf (: temp first) ((uq tvw-1) key))
        (let ((lb \ (lower-bound (@ (:@ mapp set)) (move temp))))
          ((Iterator (Map (uq Tk) (uq Tv))) ((mapp mapp)
                              (setiter lb)))))))

    #|
    @fn upper-bound

    Find the upper bound for a given value.

    @param setp     A map reference.
    @param val      The value for which the upper bound should be found.
    |#
    (def upper-bound (fn extern (Iterator (Map (uq Tk) (uq Tv)))
                                  ((mapp (ref (Map (uq Tk) (uq Tv))))
                                   (key  ((uq tpw-1) (uq Tk))))
      (let ((temp (value-type (nullptr (Map (uq Tk) (uq Tv))))))
        (setf (: temp first) ((uq tvw-1) key))
        (let ((lb \ (upper-bound (@ (:@ mapp set)) (move temp))))
          ((Iterator (Map (uq Tk) (uq Tv))) ((mapp mapp)
                              (setiter lb)))))))

    (def setf-move-init (fn extern bool ((dst (p (Map (uq Tk) (uq Tv))))
                                         (src (rv-ref (Map (uq Tk) (uq Tv)))))
      (init (@ (:@ dst set)))
      (let ((b \ (begin (@ (:@ src set))))
            (e \ (end   (@ (:@ src set)))))
        (for true (!= b e) (setv b (successor b))
          (insert (@ (:@ dst set)) (move (@ (source b))))))
      true))

    (def setf-move-assign (fn extern bool ((dst (p (Map (uq Tk) (uq Tv))))
                                           (src (rv-ref (Map (uq Tk) (uq Tv)))))
      (clear (@ (:@ dst set)))
      (setf-move-init dst (move (@ src)))))

    (uq copy-functions)

    (implement Type (Map (uq Tk) (uq Tv)))
    (instantiate swap (Map (uq Tk) (uq Tv)))

    (def = (fn extern bool ((map1 (ref (Map (uq Tk) (uq Tv))))
                            (map2 (ref (Map (uq Tk) (uq Tv)))))
      (let ((b1 \ (begin (@ (:@ map1 set))))
            (b2 \ (begin (@ (:@ map2 set))))
            (e1 \ (end   (@ (:@ map1 set))))
            (e2 \ (end   (@ (:@ map2 set)))))
        (for true (and (!= b1 e1)
                       (!= b2 e2))
                  (do (setv b1 (successor b1))
                      (setv b2 (successor b2)))
          (and (not (both-= (@ (source b1)) (@ (source b2))))
               (return false)))
        (and (= b1 e1) (= b2 e2)))))

    (def < (fn extern bool ((map1 (ref (Map (uq Tk) (uq Tv))))
                            (map2 (ref (Map (uq Tk) (uq Tv)))))
      (< (@:@ map1 set) (@:@ map2 set))))

    (implement Type (Map (uq Tk) (uq Tv)))
    (mfor F (!= <= > >=)
      (instantiate F (Map (uq Tk) (uq Tv))))

    (def destroy
      (fn extern void ((mapp (ref (Map (uq Tk) (uq Tv)))))
        (clear (@ mapp))
        (return)))

    (implement EqualityComparable (Map (uq Tk) (uq Tv)))
    (implement LessThanComparable (Map (uq Tk) (uq Tv)))
    (implement ForwardIterator (Iterator (Map (uq Tk) (uq Tv))))
    (implement ForwardIterator (ReverseIterator (Map (uq Tk) (uq Tv))))
    (implement SortedAssociativeContainer (Map (uq Tk) (uq Tv)))
    (implement UniqueAssociativeContainer (Map (uq Tk) (uq Tv)))
    (implement PairAssociativeContainer (Map (uq Tk) (uq Tv)))
    ))
)))))
