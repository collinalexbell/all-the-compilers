#|
@module set

Concept macro for a set. Apart from the `Set` macro and concept macro,
the documentation in this module is for a generated set instance of
type `T`.

All of the functions that take `Iterator` arguments are defined for
`ReverseIterator`s as well, notwithstanding that there is no
documentation for those instances.

The `Set` type implements the following concepts:

  * `SimpleAssociativeContainer`;
  * `SortedAssociativeContainer`; and
  * `UniqueAssociativeContainer`.

Its iterators implement `ForwardIterator`.

|#
(module set (attr cto))

(import cstdio)
(import macros)
(import cstdlib)
(import math)
(import concepts)
(import algorithms)
(import utility)
(import introspection)

#|
@macro Set

Expands to the concrete type name of the `Set` generated by way of
the concept macro.

@param T    The type node.
|#
(def Set
  (macro extern (T)
    (let ((typename (array-of 250 char)))
      (and (not (make-type-string mc "set" T typename))
           (return T))
      (def n (var auto (p DNode) (std.macros.mnfv mc typename)))
      (return n))))

(using-namespace std.macros
(using-namespace std.concepts

#|
@concept-macro Set

Expands to a `Set` definition over the relevant type. Note that `T`
must also implement `LessThanComparable`.

@param T    The type node.
|#
(std.concepts.def-concept-macro Set extern ((T EqualityComparable))
  (if (has-errors mc
                  (qq std.concepts.implements (uq T) LessThanComparable))
      (return (qq std.concepts.implements (uq T) LessThanComparable))
      0)
  (prefer-ref-bindings (uq T) 1)

  (let ((typename      (array-of 250 char))
        (etypename     (array-of 250 char))
        (nodetypename  (array-of 250 char)))
    ; Generate the type names and nodes, and register the main 'set'
    ; type.
    (and (not (make-type-string mc "set" T typename))
         (return (nullptr DNode)))
    (and (not (make-type-string mc "setnode" T nodetypename))
         (return (nullptr DNode)))
    (and (not (make-type-display-string mc "Set" T etypename))
         (return (nullptr DNode)))

    (def typenode     (var auto (p DNode) (std.macros.mnfv mc typename)))
    (def nodetypenode (var auto (p DNode) (std.macros.mnfv mc nodetypename)))
    (register-type mc typename etypename)

    (def copy-functions (var auto (p DNode)
      (if copy-disabled-1
          (qq do (def setf-copy-disabled (fn extern bool ((dst (Set (uq T)))))))
	  (qq do
            (def setf-copy-init (fn extern bool ((dst (p (Set (uq T))))
                                                 (src (p (Set (uq T)))))
              (init (@ dst))
              (let ((b \ (begin (@ src)))
                    (e \ (end   (@ src))))
                (for true (!= b e) (setv b (successor b))
                  (insert (@ dst) (@ (source b)))))
              true))

            (def setf-copy-assign (fn extern bool ((dst (p (Set (uq T))))
                                                   (src (p (Set (uq T)))))
              (clear (@ dst))
              (setf-copy-init dst src)))))))

    (qq do

    (import derivations)
    (import algorithms)
    (using-namespace std.macros
    (using-namespace std.concepts

    (instantiate max int)

    (def (uq nodetypenode)
      (struct extern
              ((value  (uq T))
               (height int)
               (up     (p (uq nodetypenode)))
               (left   (p (uq nodetypenode)))
               (right  (p (uq nodetypenode))))))

    #|
    @struct (Set T)

    The core set structure type.

    @linkage extern
    |#
    (def (uq typenode)
      (struct extern
              ((begin-node (p (p (uq nodetypenode)))))))

    #|
    @fn init

    Initialise a set.

    @param setp     A set reference.
    |#
    (def init
      (fn extern bool ((setp (ref (uq typenode))))
        (let ((bn  \ (malloc' 1 (uq nodetypenode)))
              (bnp \ (malloc' 1 (p (uq nodetypenode)))))
          (setf (:@ bn up)     bn)
          (setf (:@ bn height) 1)
          (setf (:@ bn left)   (nullptr (uq nodetypenode)))
          (setf (:@ bn right)  (nullptr (uq nodetypenode)))
          (setf bnp bn)
          (setf (:@ setp begin-node) bnp)
          (return true))))

    (def get-root-node
      (fn intern (p (uq nodetypenode)) ((setp (ref (Set (uq T)))))
        (@ (@:@ setp begin-node))))

    #|
    @fn empty

    Determine whether the set is empty.

    @param setp     A set reference.
    |#
    (def empty
      (fn extern bool ((setp (ref (const (Set (uq T))))))
        (let ((bn \ (get-root-node (@ setp))))
          (p= (@:@ bn up) bn))))

    #|
    @fn max-size

    Returns the number of elements that can be accommodated by the
    set.

    @param setp     A set reference.
    |#
    (def max-size
      (fn extern size ((setp (ref (const (Set (uq T))))))
        (- (cast 0 size) (cast 1 size))))

    #|
    @macro value-type

    Expands to the underlying value type (i.e. `T`) of the set. This
    only uses the type node for dispatch purposes, so it's safe to
    call this with e.g. `(nullptr (Set T))` as the argument.

    @param setp     A type node.
    |#
    (def value-type
      (macro extern ((setp (p (Set (uq T)))))
        (qq do (uq T))))

    #|
    @macro key-type

    Expands to the underlying key type of the set. Since `Set` is a
    `SimpleAssociativeContainer`, this returns the same type as
    `value-type`.

    @param setp     A type node.
    |#
    (def key-type
      (macro extern ((setp (p (Set (uq T)))))
        (qq do (uq T))))

    #|
    @macro size-type

    Expands to the underlying size type of the set.

    @param setp     A type node.
    |#
    (def size-type
      (macro extern ((setp (p (Set (uq T)))))
        (qq do size)))

    #|
    @macro difference-type

    Expands to the underlying iterator difference type of the set.

    @param setp     A type node.
    |#
    (def difference-type
      (macro extern ((setp (p (Set (uq T)))))
        (qq do ptrdiff)))

    #|
    @struct (Iterator (Set T))

    @linkage extern
    |#
    (def (Iterator (Set (uq T)))
      (struct extern ((setp    (p (Set (uq T))))
                      (element (p (uq nodetypenode))))))

    #|
    @fn end

    Returns the iterator representing the end of the set (sentinel).

    @param setp     A set reference.
    |#
    (def end
      (fn extern (Iterator (Set (uq T))) ((setp (ref (Set (uq T)))))
        (let ((thing (Iterator (Set (uq T)))))
          (setf (: thing element) (nullptr (uq nodetypenode)))
          (setf (: thing setp)    setp)
          (return thing))))

    #|
    @fn begin

    Returns the iterator for the first set element.

    @param setp     A set reference.
    |#
    (def begin
      (fn extern (Iterator (Set (uq T))) ((setp (ref (Set (uq T)))))
        (let ((thing (Iterator (Set (uq T)))
                        ((element (get-root-node (@ setp)))
                         (setp    setp))))
          (if (empty (@ setp))
              (do (return (end (@ setp))))
              0)
          (if (null (@: thing element))
              (do (return thing))
              0)
          (while (not (null (@:@ (@: thing element) left)))
              (setf (: thing element)
                    (@:@ (@: thing element) left)))
          (return thing))))

    #|
    @macro value-type

    Expands to the underlying value type (i.e. `T`) of the iterator.

    @param iter     A type node.
    @param-type     (p (Iterator (Set T)))
    @linkage        extern
    |#
    (def value-type
      (macro extern ((setiter (p (Iterator (Set (uq T))))))
        (qq do (uq T))))

    #|
    @fn source

    Returns a pointer to the iterator's value.

    @param iter     An iterator.
    @param-type     (Iterator (Set T))
    @linkage        extern
    @return-type    (p T)
    |#
    (def source
      (fn extern (p (uq T)) ((iter (Iterator (Set (uq T)))))
        (:@ (@: iter element) value)))

    #|
    @fn successor

    Returns the iterator for the position that follows the argument
    iterator.

    @param iter     An iterator.
    @param-type     (Iterator (Set T))
    @linkage        extern
    @return-type    (Iterator (Set T))
    |#
    (def successor
      (fn extern (Iterator (Set (uq T))) ((iter (Iterator (Set (uq T)))))
        (if (and (not (null (@:@ (@: iter element) up)))
                 (null (@:@ (@: iter element) right)))
            (do
              (while (< (@:@ (@:@ (@: iter element) up) value)
                        (@:@ (@: iter element) value))
                (setf (: iter element) (@:@ (@: iter element) up))
                (and (null (@:@ (@: iter element) up))
                     (break)))

              (if (null (@:@ (@: iter element) up))
                  (do (setf (: iter element) (nullptr (uq nodetypenode)))
                      (return iter))
                  (do (setf (: iter element) (@:@ (@: iter element) up))
                      (return iter))))
            (if (null (@:@ (@: iter element) right))
                (do (setf (: iter element) (nullptr  (uq nodetypenode)))
                    (return iter))
                (do
                  (let ((rn \ (@:@ (@: iter element) right)))
                    (while (not (null (@:@ rn left)))
                      (setv rn (@:@ rn left)))
                    (setf (: iter element) rn)
                    (return iter)))))))

    #|
    @fn =

    @param iter1    The first iterator.
    @param-type     (Iterator (Set T))
    @param iter2    The second iterator.
    @param-type     (Iterator (Set T))
    @linkage        extern
    @return-type    bool
    |#
    (def =
      (fn extern bool ((iter1 (Iterator (Set (uq T))))
                       (iter2 (Iterator (Set (uq T)))))
        (let ((i1isend bool (null (@: iter1 element)))
              (i2isend bool (null (@: iter2 element))))
          (if (and i1isend i2isend)
              true
          (if i1isend
              false
          (if i2isend
              false
          (= (@:@ (@: iter1 element) value)
             (@:@ (@: iter2 element) value))))))))

    (implement Type (Iterator (Set (uq T))))
    (instantiate != (Iterator (Set (uq T))))

    #|
    @fn <

    @param iter1    The first iterator.
    @param-type     (Iterator (Set T))
    @param iter2    The second iterator.
    @param-type     (Iterator (Set T))
    @linkage        extern
    @return-type    bool
    |#
    (def <
      (fn extern bool ((iter1 (Iterator (Set (uq T))))
                       (iter2 (Iterator (Set (uq T)))))
        (let ((i1isend bool (= (@ (cast (# iter1) (p int))) 0))
              (i2isend bool (= (@ (cast (# iter2) (p int))) 0)))
          (if (and i1isend i2isend)
              false
          (if i1isend
              false
          (if i2isend
              true
          (< (@:@ (@: iter1 element) value)
             (@:@ (@: iter2 element) value))))))))

    (mfor F (<= > >=)
      (instantiate F (Iterator (Set (uq T)))))
    (implement LessThanComparable (Iterator (Set (uq T))))

    #|
    @struct (ReverseIterator (Set T))

    @linkage extern
    |#
    (def (ReverseIterator (Set (uq T)))
      (struct extern ((element (p (uq nodetypenode)))
                      (setp    (p (Set (uq T)))))))

    #|
    @fn rend

    Returns the iterator representing the beginning of the set (sentinel).

    @param setp     A set reference.
    |#
    (def rend
      (fn extern (ReverseIterator (Set (uq T))) ((setp (ref (Set (uq T)))))
        (let ((thing (ReverseIterator (Set (uq T)))))
          (setf (: thing element) (nullptr (uq nodetypenode)))
          (setf (: thing setp)    setp)
          (return thing))))

    #|
    @fn rbegin

    Returns the iterator for the last set element.

    @param setp     A set reference.
    |#
    (def rbegin
      (fn extern (ReverseIterator (Set (uq T))) ((setp (ref (Set (uq T)))))
        (let ((thing (ReverseIterator (Set (uq T)))
                        ((element (get-root-node (@ setp)))
                         (setp    setp))))
          (if (null (@: thing element))
              (return thing)
              0)
          (while (not (null (@:@ (@: thing element) left)))
              (setf (: thing element)
                    (@:@ (@: thing element) left)))
          (return thing))))

    (def value-type
      (macro extern ((setiter (p (ReverseIterator (Set (uq T))))))
        (qq do (uq T))))

    (def source
      (fn extern (p (uq T)) ((iter (ReverseIterator (Set (uq T)))))
        (:@ (@: iter element) value)))

    (def successor
      (fn extern (ReverseIterator (Set (uq T)))
                        ((iter (ReverseIterator (Set (uq T)))))
        (if (and (not (null (@:@ (@: iter element) up)))
                 (null (@:@ (@: iter element) left)))
            (do
              (while (< (@:@ (@:@ (@: iter element) up) value)
                        (@:@ (@: iter element) value))
                (setf (: iter element) (@:@ (@: iter element) up))
                (and (null (@:@ (@: iter element) up))
                     (break)))

              (if (null (@:@ (@: iter element) up))
                  (do (setf (: iter element) (nullptr (uq nodetypenode)))
                      (return iter))
                  (do (setf (: iter element) (@:@ (@: iter element) up))
                      (return iter))))
            (if (null (@:@ (@: iter element) left))
                (do (setf (: iter element) (nullptr  (uq nodetypenode)))
                    (return iter))
                (do
                  (let ((rn \ (@:@ (@: iter element) left)))
                    (while (not (null (@:@ rn right)))
                      (setv rn (@:@ rn right)))
                    (setf (: iter element) rn)
                    (return iter)))))))

    (def =
      (fn extern bool ((iter1 (ReverseIterator (Set (uq T))))
                       (iter2 (ReverseIterator (Set (uq T)))))
        (let ((i1isend bool (= (@ (cast (# iter1) (p int))) 0))
              (i2isend bool (= (@ (cast (# iter2) (p int))) 0)))
          (if (and i1isend i2isend)
              true
          (if i1isend
              false
          (if i2isend
              false
          (= (@:@ (@: iter1 element) value)
             (@:@ (@: iter2 element) value))))))))

    (implement Type (ReverseIterator (Set (uq T))))
    (instantiate != (ReverseIterator (Set (uq T))))

    (def <
      (fn extern bool ((iter1 (ReverseIterator (Set (uq T))))
                       (iter2 (ReverseIterator (Set (uq T)))))
        (let ((i1isend bool (= (@ (cast (# iter1) (p int))) 0))
              (i2isend bool (= (@ (cast (# iter2) (p int))) 0)))
          (if (and i1isend i2isend)
              false
          (if i1isend
              false
          (if i2isend
              true
          (< (@:@ (@: iter1 element) value)
             (@:@ (@: iter2 element) value))))))))

    (mfor F (<= > >=)
      (instantiate F (ReverseIterator (Set (uq T)))))
    (implement LessThanComparable (ReverseIterator (Set (uq T))))

    (def is-leaf-node
      (fn intern bool ((node (p (uq nodetypenode))))
        (and (null (@:@ node left))
             (null (@:@ node right)))))

    (def height
      (fn intern int ((node (p (uq nodetypenode))))
        (and (null node) (return 0))
        (@:@ node height)))

    (def calculated-height
      (fn intern int ((node (p (uq nodetypenode))))
        (and (null node) (return 0))
        (and (is-leaf-node node) (return 1))
        (let ((left  \ (calculated-height (@:@ node left)))
              (right \ (calculated-height (@:@ node right))))
          (+ 1 (max left right)))))

    (def is-avl-balanced
      (fn intern bool ((node (p (uq nodetypenode))))
        (and (is-leaf-node node) (return true))
        (let ((left   \ (height (@:@ node left)))
              (right  \ (height (@:@ node right)))
              (diff   \ (abs (- left right))))
          (<= diff 1))))

    (def is-avl-balanced
      (fn intern bool ((setp (ref (const (Set (uq T))))))
        (let ((b \ (begin (@ setp)))
              (e \ (end   (@ setp))))
          (for true (!= b e) (setv b (successor b))
            (and (not (is-avl-balanced (@: b element)))
                 (return false))))
        (return true)))

    (def calculated-is-avl-balanced
      (fn intern bool ((node (p (uq nodetypenode))))
        (and (is-leaf-node node) (return true))
        (let ((left   \ (calculated-height (@:@ node left)))
              (right  \ (calculated-height (@:@ node right)))
              (diff   \ (abs (- left right))))
          (<= diff 1))))

    (def calculated-is-avl-balanced
      (fn intern bool ((setp (ref (const (Set (uq T))))))
        (let ((b \ (begin (@ setp)))
              (e \ (end   (@ setp))))
          (for true (!= b e) (setv b (successor b))
            (and (not (calculated-is-avl-balanced (@: b element)))
                 (return false))))
        (return true)))

    (def adjust-heights
      (fn intern void ((node (p (uq nodetypenode))))
        (while (not (null node))
          (let ((node-height   \ (@:@ node height))
                (left-height   \ (height (@:@ node left)))
                (right-height  \ (height (@:@ node right)))
                (new-height    \ (+ 1 (max left-height right-height))))
            (and (= new-height node-height)
                 (break))
            (setf (:@ node height) new-height)
            (and (p= node (@:@ node up))
                 (break))
            (setv node (@:@ node up))))
        (return)))

    (def is-left-of
      (fn intern bool ((up (p (uq nodetypenode)))
                       (left (p (uq nodetypenode))))
        (and (not (null up))
             (p= (@:@ up left) left))))

    (def is-right-of
      (fn intern bool ((up (p (uq nodetypenode)))
                       (right (p (uq nodetypenode))))
        (and (not (null up))
             (p= (@:@ up right) right))))

    (def set-left-of
      (fn intern void ((up (p (uq nodetypenode)))
                       (left (p (uq nodetypenode))))
        (and (not (null up))
             (setf (:@ up left) left))
        (and (not (null left))
             (setf (:@ left up) up))
        (return)))

    (def set-right-of
      (fn intern void ((up (p (uq nodetypenode)))
                       (right (p (uq nodetypenode))))
        (and (not (null up))
             (setf (:@ up right) right))
        (and (not (null right))
             (setf (:@ right up) up))
        (return)))

    (def rotate-left
      (fn intern (p (uq nodetypenode)) ((setp (p (Set (uq T))))
                                        (node (p (uq nodetypenode))))
        (let ((right    \ (@:@ node right))
              (up       \ (@:@ node up))
              (is-left  \ (is-left-of  up node))
              (is-right \ (is-right-of up node)))
          (set-right-of node (@:@ right left))
          (set-left-of  right node)
          (if is-left
              (do (set-left-of up right) true)
              (do (set-right-of up right) true))
          (and (null up)
               (setf (@:@ setp begin-node) right))
          (adjust-heights node)
          (adjust-heights right)
          (adjust-heights up)
          (return right))))

    (def rotate-right
      (fn intern (p (uq nodetypenode)) ((setp (p (Set (uq T))))
                                        (node (p (uq nodetypenode))))
        (let ((left     \ (@:@ node left))
              (up       \ (@:@ node up))
              (is-right \ (is-right-of up node))
              (is-left  \ (is-left-of  up node)))
          (set-left-of node (@:@ left right))
          (set-right-of  left node)
          (if is-right
              (do (set-right-of up left) true)
              (do (set-left-of up left) true))
          (and (null up)
               (setf (@:@ setp begin-node) left))
          (adjust-heights node)
          (adjust-heights left)
          (adjust-heights up)
          (return left))))

    (def left-of
      (fn intern (p (uq nodetypenode)) ((node (p (uq nodetypenode))))
        (@:@ node left)))

    (def right-of
      (fn intern (p (uq nodetypenode)) ((node (p (uq nodetypenode))))
        (@:@ node right)))

    (def up-of
      (fn intern (p (uq nodetypenode)) ((node (p (uq nodetypenode))))
        (@:@ node up)))

    (def rebalance
      (fn intern void ((setp (p (Set (uq T))))
                       (node (p (uq nodetypenode)))
                       (upwards bool))
        (and (null node)
             (return))
        (and (p= (up-of node) node)
             (return))
        (and (is-avl-balanced node)
             (return (rebalance setp (up-of node) upwards)))
        (def higher     (var auto \ node))
        (def new-parent (var auto \ node))
        (let ((left-height   \ (height (left-of node)))
              (right-height  \ (height (right-of node)))
              (higher        \ (if (> left-height right-height)
                                   (left-of node)
                                   (right-of node)))
              (subleft-height  \ (height (left-of higher)))
              (subright-height \ (height (right-of higher)))
              (subhigher       \ (if (> subleft-height subright-height)
                                     (left-of higher)
                                     (right-of higher))))
            (if (p= higher (left-of node))
                (if (p= subhigher (left-of higher))
                    (do (setv new-parent (rotate-right setp node))
                        (and upwards
                             (do (rebalance setp node true)
                                 true))
                        true)
                    (do (rotate-left setp higher)
                        (setv new-parent (rotate-right setp node))
                        (and upwards
                            (do (rebalance setp higher true)
                                (rebalance setp node true)
                                true))
                        true))
                (if (p= subhigher (right-of higher))
                    (do (setv new-parent (rotate-left setp node))
                        (and upwards
                             (do (rebalance setp node true)
                                 true))
                        true)
                    (do (rotate-right setp higher)
                        (setv new-parent (rotate-left setp node))
                        (and upwards
                             (do (rebalance setp higher true)
                                 (rebalance setp node true)
                                 true))
                        true))))
        (return)))

    #|
    @fn insert

    Insert a new element into the set.

    @param setp     A set reference.
    @param val      The value to insert into the set.
    |#
    (def insert
      (fn extern bool ((setp   (ref (Set (uq T))))
                       (newval ((uq tpw-1) (uq T))))
        (if (empty (@ setp))
            (do (setf (:@ (@ (@:@ setp begin-node)) value)
                      ((uq tvw-1) newval))
                (setf (:@ (@ (@:@ setp begin-node)) up)
                      (nullptr (uq nodetypenode)))
                (return true))
            (let ((newnodep \ (malloc' 1 (uq nodetypenode))))
              (setf (:@ newnodep value) ((uq tvw-1) newval))
              (setf (:@ newnodep up)    (nullptr (uq nodetypenode)))
              (setf (:@ newnodep left)  (nullptr (uq nodetypenode)))
              (setf (:@ newnodep right) (nullptr (uq nodetypenode)))
              (let ((cn    \ (get-root-node (@ setp)))
                    (newnp \ (nullptr (p (uq nodetypenode)))))
                (while (!= (@:@ newnodep value) (@:@ cn value))
                  (if (< (@:@ newnodep value) (@:@ cn value))
                      (do (if (null (@:@ cn left))
                              (do (setv newnp (:@ cn left))
                                  (break))
                              (setv cn (@:@ cn left))))
                      (do (if (null (@:@ cn right))
                              (do (setv newnp (:@ cn right))
                                  (break))
                              (setv cn (@:@ cn right))))))
                (if (not (null newnp))
                    (do (setf newnp newnodep)
                        (setf (:@ newnodep up) cn)
                        (setf (:@ newnodep height) 1)
                        (adjust-heights cn)
                        (rebalance setp cn false)
                        0)
                    (do (setf (:@ cn value) (move (@:@ newnodep value)))
                        (free' newnodep)))
                (return true))))))

    #|
    @fn find

    Find an element within the set, and return the iterator for its
    position.

    @param setp     A set reference.
    @param val      The value to find in the set.
    |#
    (def find
      (fn extern (Iterator (Set (uq T)))
                          ((setp   (ref (Set (uq T))))
                           (value  ((uq tpw-1) (uq T))))
        (and (empty (@ setp))
          (return (end (@ setp))))
        (let ((cn \ (get-root-node (@ setp))))
            (while (!= ((uq tvw-1) value) (@:@ cn value))
              (if (< ((uq tvw-1) value) (@:@ cn value))
                  (do (if (null (@:@ cn left))
                          (return (end (@ setp)))
                          (setv cn (@:@ cn left))))
                  (do (if (null (@:@ cn right))
                          (return (end (@ setp)))
                          (setv cn (@:@ cn right))))))
            (and (null cn)
                 (return (end (@ setp))))
            (return ((Iterator (Set (uq T))) ((element cn)
                                        (setp setp)))))))

    (def node-to-pointer-to-node
      (fn intern (p (p (uq nodetypenode))) ((node (p (uq nodetypenode))))
        (let ((up \ (@:@ node up)))
          (if (null up)
              (nullptr (p (uq nodetypenode)))
              (if (p= node (@:@ up left))
                  (:@ up left)
                  (:@ up right))))))

    (def is-root-node
      (fn intern bool ((node (p (uq nodetypenode))))
        (null (@:@ node up))))

    (def is-empty-root-node
      (fn intern bool ((node (p (uq nodetypenode))))
        (p= (@:@ node up) node)))

    (def free-node
      (fn intern void ((node (p (uq nodetypenode))))
        (let ((value \ (:@ node value)))
          (destroy (@ value))
          (free' node)
          (return))))

    #|
    @fn erase

    Erase an element from the set, by specifying the iterator for its
    position.

    @param iter     The iterator.
    @param-type     (Iterator (Set T))
    @linkage        extern
    @return-type    bool
    |#
    (def erase
      (fn extern bool ((iter (Iterator (Set (uq T)))))
        (let ((node    \ (@: iter element))
              (setp    \ (@: iter setp))
              (up      \ (@:@ node up))
              (left    \ (@:@ node left))
              (right   \ (@:@ node right))
              (newn    \ (nullptr (uq nodetypenode)))
              (subn    \ (nullptr (uq nodetypenode)))
              (nullp   \ (nullptr (uq nodetypenode)))
              (ptn     \ (node-to-pointer-to-node node))
              (has-ptn \ (not (null ptn)))
              (is-root \ (is-root-node node))
              (is-leaf \ (is-leaf-node node))
              (right-height int 0)
              (left-height int 0))
          (and (is-empty-root-node node)
               (return false))
          ; If this element has nothing underneath it, then destroy
          ; the element (if required) and null the relevant pointer
          ; in the next-highest node. If it's the root node as well,
          ; then set its up pointer to itself, to indicate that it
          ; is empty.
          (and is-leaf
               (do (setv subn up)
                   (and has-ptn (setf ptn nullp))
                   (and is-root (setf (:@ node up) node))
                   (let ((value \ (:@ node value)))
                     (destroy (@ value))
                     (if (not is-root) (do (free' node) 0) 0)
                     (goto end))))

          (setv right-height (if (null right) 0 (height right)))
          (setv left-height  (if (null left)  0 (height left)))

          ; If the left tree is longer, then bring it up.
          (if (> left-height right-height)
              ; Make the parent link to this node's left node.
              (do (if has-ptn
                      (do (setf ptn left)
                          (setf (:@ left up) up))
                      (setf (:@ left up) nullp))
                  ; Find the rightmost leaf node of the left node.
                  (setv subn left)
                  (while (not (null (@:@ subn right)))
                    (setv subn (@:@ subn right)))
                  ; Make that leaf node point rightwards to this node's
                  ; right node.
                  (and (not (null right))
                       (do (setf (:@ subn right) right)
                           (setf (:@ right up) subn)
                           true))
                  (setv newn left)
                  (free-node node)
                  true)
              ; Make the parent link to this node's right node.
              (do (if has-ptn
                      (do (setf ptn right)
                          (setf (:@ right up) up))
                      (setf (:@ right up) nullp))
                  ; Find the leftmost leaf node of the right node.
                  (setv subn right)
                  (while (not (null (@:@ subn left)))
                    (setv subn (@:@ subn left)))
                  ; Make the leaf node point leftwards to this node's
                  ; left node.
                  (and (not (null left))
                       (do (setf (:@ subn left) left)
                           (setf (:@ left up) subn)
                           true))
                  (setv newn right)
                  (free-node node)
                  true))

          (label end)

          ; If the node being removed was the root node,
          ; update the root node pointer in the set to newn. (If
          ; the root has nothing underneath it, then do not change
          ; the root node pointer: its 'up' pointer will point to
          ; itself so as to indicate that the set is empty.)

            (if (and is-root (not is-leaf))
                (setf (@:@ setp begin-node) newn)
                true)

          ; Finally, work up the tree, adjusting heights and
          ; rebalancing.
            (adjust-heights subn)
            (adjust-heights up)

            (rebalance setp subn true)
          (return true))))

    #|
    @fn erase

    Erase an element from the set, by value.

    @param setp     A set reference.
    @param val      The value to remove from the set.
    |#
    (def erase
      (fn extern bool ((setp (ref (Set (uq T))))
                       (v ((uq tpw-1) (uq T))))
        (let ((iter \ (find (@ setp) ((uq tvw-1) v))))
          (if (= (end (@ setp)) iter)
                 false
                 (erase iter)))))

    #|
    @fn lower-bound

    Find the lower bound for a given value.

    @param setp     A set reference.
    @param val      The value for which the lower bound should be found.
    |#
    (def lower-bound
      (fn extern (Iterator (Set (uq T)))
                        ((setp (ref (Set (uq T))))
                         (value ((uq tpw-1) (uq T))))
        (let ((cn \ (get-root-node (@ setp))))
            (and (null cn)
                 (return (end (@ setp))))
            (while (!= ((uq tvw-1) value) (@:@ cn value))
              (if (< ((uq tvw-1) value) (@:@ cn value))
                  (do (if (null (@:@ cn left))
                          (break)
                          (setv cn (@:@ cn left))))
                  (do (if (null (@:@ cn right))
                          (break)
                          (setv cn (@:@ cn right))))))
            (and (null cn)
                 (return (end (@ setp))))
            (let ((iter \ ((Iterator (Set (uq T)))
                           ((element cn)
                            (setp setp)))))
              (if (not (< (@:@ cn value) ((uq tvw-1) value)))
                  (return iter)
                  (return (successor iter)))))))

    #|
    @fn upper-bound

    Find the upper bound for a given value.

    @param setp     A set reference.
    @param val      The value for which the upper bound should be found.
    |#
    (def upper-bound
      (fn extern (Iterator (Set (uq T)))
                        ((setp (ref (Set (uq T))))
                         (value ((uq tpw-1) (uq T))))
        (let ((lb \ (lower-bound (@ setp) ((uq tvw-1) value))))
          (if (= lb (end (@ setp)))                   lb
          (if (> (@ (source lb)) ((uq tvw-1) value))       lb
          (if (and (!= ((uq tvw-1) value) (@ (source lb)))
                   (= (successor lb) (end (@ setp)))) (end (@ setp))
                                                      (successor lb)))))))

    #|
    @fn count

    Return the number of times that the value appears in the set. For
    a `UniqueAssociativeContainer` such as `Set`, this can only return
    1 or 0, depending on whether the element is present in the set.

    @param setp     A set reference.
    @param val      The value for which the count should be determined.
    |#
    (def count
      (fn extern size ((setp (ref (Set (uq T))))
                       (v ((uq tpw-1) (uq T))))
        (let ((iter \ (find (@ setp) ((uq tvw-1) v))))
          (cast (if (= (end (@ setp)) iter) 0 1) size))))

    #|
    @fn size

    Return the number of elements in the set.

    @param setp     A set reference.
    |#
    (def size
      (fn extern size ((setp (ref (Set (uq T)))))
        (let ((b \ (begin (@ setp)))
              (e \ (end (@ setp)))
              (c size 0))
          (while (!= b e)
            (setv c (+ c (cast 1 size)))
            (setv b (successor b)))
          c)))

    (def clear
      (fn extern void ((setnp (ref (uq nodetypenode))))
        (if (not (null (@:@ setnp left)))
            (do (clear (@ (@:@ setnp left))) 0)
            0)
        (if (not (null (@:@ setnp right)))
            (do (clear (@ (@:@ setnp right))) 0)
            0)
        (let ((value \ (:@ setnp value)))
          (destroy (@ value)))
        (free' setnp)
        (return)))

    #|
    @fn clear

    Remove all of the elements from the set.

    @param setp     The set reference.
    |#
    (def clear
      (fn extern void ((setp (ref (Set (uq T)))))
        (if (not (null (get-root-node (@ setp))))
            (do (clear (@ (get-root-node (@ setp)))) 0)
            0)
        (init (@ setp))
        (return)))

    #|
    @fn swap

    @param set1     The first set reference.
    @param set2     The second set reference.
    |#
    (def swap
      (fn extern void ((set1 (ref (Set (uq T))))
                       (set2 (ref (Set (uq T)))))
        (let ((bn1 \ (@:@ set1 begin-node))
              (bn2 \ (@:@ set2 begin-node)))
          (setf (:@ set1 begin-node) bn2)
          (setf (:@ set2 begin-node) bn1)
          (return))))

    (def setf-move-init (fn extern bool ((dst (p (Set (uq T))))
                                         (src (rv-ref (Set (uq T)))))
      (init (@ dst))
      (let ((b \ (begin (@ src)))
            (e \ (end   (@ src))))
        (for true (!= b e) (setv b (successor b))
          (insert (@ dst) (move (@ (source b))))))
      true))

    (def setf-move-assign (fn extern bool ((dst (p (Set (uq T))))
                                           (src (rv-ref (Set (uq T)))))
      (clear (@ dst))
      (setf-move-init dst (move (@ src)))))

    (uq copy-functions)

    (implement Container (Set (uq T)))
    (implement Type (Set (uq T)))
    (mfor F (= < != <= > >=)
      (instantiate F (Set (uq T))))

    (implement EqualityComparable (Set (uq T)))
    (implement LessThanComparable (Set (uq T)))

    (def destroy
      (fn extern void ((setp (ref (Set (uq T)))))
        (clear (@ setp))
        (return)))

    (implement Type (Iterator (Set (uq T))))
    (implement Type (ReverseIterator (Set (uq T))))
    (instantiate swap (Iterator (Set (uq T))))
    (instantiate swap (ReverseIterator (Set (uq T))))
    (implement ForwardIterator (Iterator (Set (uq T))))
    (implement ForwardIterator (ReverseIterator (Set (uq T))))
    (implement SimpleAssociativeContainer (Set (uq T)))
    (implement SortedAssociativeContainer (Set (uq T)))
    (implement UniqueAssociativeContainer (Set (uq T)))
    ))
)))

))
