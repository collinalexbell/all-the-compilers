<!DOCTYPE html>
<link rel="import" href="../../../../../../packages/polymer/polymer.html">

<polymer-element name="ir-descriptions-v8">
  <template>
    <style type='text/css' scoped>
      div[data-hir], div[data-lir] { display: none; };
    </style>
    <div data-hir="changes-all">
      <p>This instruction has side effects <b>unknown</b> to the compiler. </p>
      <p>It can change hidden classes of objects, kind of array backing stores, etc.</p>
      <p>Such instructions should be avoided inside hot loops because they inhibit optimizations.</p>
    </div>
    <div data-hir="UnknownOSRValue">
      <p>An implementation detail of the <em>On Stack Replacement</em> mechanism</p>
      <p><em>On Stack Replacement</em> (OSR) is a process when an unoptimized code for a running function is replaced by an optimized code while the function is running (is on the stack). OSR is used to optimize functions with long running loops while these loops are still running.</p>
      <p>In this case function is entered through a special block known as an <em>OSR entry point</em> instead of the normal entry (<code>B0</code>). <code>UnknownOSRValue</code> instructions evaluate to the values that were in the corresponding places in the environment (a set of local and parameter values) during execution of the unoptimized code - allowing optimized code to continue from the place where unoptimized code was.</p>
      <p>Block containing these instructions is never executed if the function entered through normal entry.</p>
      <p>OSR entry block inhibits LICM, so if OSR occured in one of the inner loops instead of the outermost one it might negatively impact code quality.</p>
    </div>
    <div data-hir="OsrEntry">
      <p>An implementation detail of the <em>On Stack Replacement</em> mechanism</p>
      <p><em>On Stack Replacement</em> (OSR) is a process when an unoptimized code for a running function is replaced by an optimized code while the function is running (is on the stack). OSR is used to optimize functions with long running loops while these loops are still running.</p>
      <p>In this case function is entered through a special block known as an <em>OSR entry point</em> instead of the normal entry (<code>B0</code>). <code>UnknownOSRValue</code> instructions evaluate to the values that were in the corresponding places in the environment (a set of local and parameter values) during execution of the unoptimized code - allowing optimized code to continue from the place where unoptimized code was.</p>
      <p>Block containing these instructions is never executed if the function entered through normal entry.</p>
      <p>OSR entry block inhibits LICM, so if OSR occured in one of the inner loops instead of the outermost one it might negatively impact code quality.</p>
    </div>
    <div data-hir="CheckMaps" data-lir="check-maps">
      <p>Checks whether value's hidden class matches expected value and deoptimizes if this is not the case.</p>
      <p>Deoptimization at <code>CheckMaps</code> usually indicates that the code is polymorphic.</p>
    </div>
    <div data-hir="Deoptimize" data-lir="deoptimize">
      <p>When executed this instruction always deoptimizes.</p>
      <p>V8 generates them on control flow paths that were never executed before and thus contain no actionable type feedback that could be used to optimize the code.</p>
      <p>For a function with a long running loop it is not uncommon to hit at OSR in the loop and then deoptimize on a <code>Deoptimize</code> emitted after the loop</p>
    </div>
    <div data-lir="lazy-bailout">
      <p>This is a pseudo instruction that follows every call. </p>
      <p>Some assumptions V8's optimizing compiler makes are not explicitly checked in the optimized code itself. Instead they are guarded globally in the runtime system. When a change happens that violates an assumption all optimized code depending on this assumption has to be discarded.</p>
      <p>If dependant code is currently active on the call stack it is marked for <em>lazy deoptimization</em>, i.e. deoptimization that will happen as soon as control returns into it. That's why lazy deoptimization always follows a call.</p>
      <p>Reasons for invalidating currently running optimized code via lazy deoptimization code can be numerous:</p>
      <ul>
        <li>activation of the debugger;</li>
        <li>deoptimization of the same function down the call stack;</li>
        <li>change in the shape of prototype for an object. V8 tries to omit checks that verify each object in the prototype chain and instead guards then in the runtime system;</li>
        <li>representation tracking transition tree deprecation.</li>
      </ul>
    </div>
    <div data-hir="Change">
      <p>This instruction converts value from one internal representation to another.</p>
      <p>It will deoptimize if the value can't be converted</p>
    </div>
    <div data-lir="tagged-to-i">
      <p>Conversion from a tagged representation to a 32-bit signed integer. Can be either truncating or exact (see if hydrogen counterpart is marked with <code>truncating-int32</code>.</p>
      <p>Deoptimizes when source is not representable in this format. Truncating conversions deoptimize when value is too big for an int32 type or not a number or <code>undefined</code>. Exact conversions deoptimize if <code>ToInt32(val) != val</code></p>
    </div>
    <div data-lir="check-smi">
      <p>Checks that value is a tagged smi (<b>sm</b>all <b>i</b>nteger): it is a tagged integer representation used by V8.</p>
      <p>On 32bit platforms smi can contain 31-bit signed integers and on 64bit platforms they are wide enough for 32bit signed integers.</p>
      <p>If numeric value does not fit into a smi it has to be boxed as a <em>heap number</em>.</p>
    </div>
  </template>
  <script type="application/dart" src='descriptions.dart'></script>
</polymer-element>