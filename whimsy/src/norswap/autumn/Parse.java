package norswap.autumn;

import norswap.autumn.actions.ActionContext;
import norswap.autumn.actions.StackAction;
import norswap.autumn.parsers.Bounded;
import norswap.autumn.parsers.Not;
import norswap.autumn.parsers.RightExpression;
import norswap.autumn.parsers.StringMatch;
import norswap.autumn.parsers.TrailingWhitespace;
import norswap.autumn.positions.Span;
import norswap.autumn.visitors.WellFormednessChecker;
import norswap.utils.data.structures.ArrayListLong;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.PrimitiveIterator.OfInt;

/**
 * The context associated with <i>a parse</i>, which is the the invocation of a (root) parser on
 * some input â€” either a String ({@link #string}) or a list ({@link #list}).
 *
 * <p>Instances of this class cannot be created by the user, instead they are generated by one of
 * the {@link Autumn#parse} methods. However, custom {@link Parser} implementations can (and should)
 * access this class.
 *
 * <p>Most fields of this class are public in order to enable advanced parser implementations, but
 * it is often not necessary to touch them at all. See the relevant part of the Autumn manual for
 * more information.
 */
public final class Parse
{
    // ---------------------------------------------------------------------------------------------

    /**
     * Position within the input.
     */
    public int pos = 0;

    // ---------------------------------------------------------------------------------------------

    /**
     * Position of the furthest encountered error, or -1 if no error have been encountered.
     */
    public int error = -1;

    // ---------------------------------------------------------------------------------------------

    /**
     * Start of the last parsed whitespace segment for {@link Span} creation. Must be modified via
     * side effects.
     */
    private int whitespaceStart = 0;

    // ---------------------------------------------------------------------------------------------

    /**
     * End of the last parsed whitespace segment for {@link Span} creation. Must be modified via
     * side effects.
     */
    private int whitespaceEnd = 0;

    // ---------------------------------------------------------------------------------------------

    /**
     * An optional message associated with the furthest error position.
     *
     * <p>Access through {@link #errorMessage()} and {@link #setErrorMessage(String)}
     */
    String errorMessage;

    // ---------------------------------------------------------------------------------------------

    /**
     * Flag used in the implementation of {@link RightExpression}. Do not modify.
     */
    public boolean rightRecursive = false;

    // ---------------------------------------------------------------------------------------------

    /**
     * The position one past the last input position.
     *
     * <p>This can be manipulated by parsers to restrict the extent of the match of one of their
     * sub-parsers (e.g. {@link Bounded}), but should never be set higher than the actual size of
     * the input.
     *
     * <p>This does not affect {@link #inputLength()} and {@link ParseResult#fullMatch}.
     */
    public int endOfInput;

    // ---------------------------------------------------------------------------------------------

    /**
     * One of the two forms of input the parse may have: a string represent as an array of
     * Unicode code points.
     */
    public final int[] string;

    // ---------------------------------------------------------------------------------------------

    /**
     * One of the two forms of input the parse may have: a list of token-like objects.
     */
    public final List<?> list;

    // ---------------------------------------------------------------------------------------------

    /**
     * The parse options used to construct this parse object.
     */
    public final ParseOptions options;

    // ---------------------------------------------------------------------------------------------

    /**
     * The list of side-effects that have been applied during this parse.
     */
    public final Log log = new Log();

    // ---------------------------------------------------------------------------------------------

    /**
     * A stack that can be used to build ASTs.
     */
    public final SideEffectingArrayStack stack = new SideEffectingArrayStack(log);

    // ---------------------------------------------------------------------------------------------

    /**
     * Use this map to store custom parsing state data. If state changes must be undone when
     * backtracking (as is usual), the state data should usually be modified exclusively through a
     * {@link SideEffect}.
     *
     * <p>Always use {@link ParseState} to transparently access this map (which also yield
     * increased performance via caching).
     */
    public final Map<Object, Object> stateData = new HashMap<>();

    // ---------------------------------------------------------------------------------------------

    /**
     * List of {@link ParseState} used during this parse, i.e. parse states whose data
     * are registered in {@link #stateData}.
     */
    ArrayList<ParseState<?>> parseStates = new ArrayList<>();

    // ---------------------------------------------------------------------------------------------

    /**
     * The current parser invocation stack if {@link ParseOptions#recordCallStack} is set,
     * null otherwise.
     *
     * <p>Only access if required (and check if the option is set!). No base parsers use this.
     */
    public ParserCallStack callStack;

    // ---------------------------------------------------------------------------------------------

    /**
     * If {@link ParseOptions#recordCallStack} is set, the stack of parser invocations that lead
     * to the furthest error (at position {@link #error}), or null if there were no parse errors.
     * Otherwise, always null.
     *
     * <p>Only access if required (and check if the option is set!). Only the {@link Not} base
     * parser uses this.
     */
    public ParserCallStack errorCallStack;

    // ---------------------------------------------------------------------------------------------

    /**
     * A stack used to record the execution time of completed parser invocations in tracing mode
     * ({@link ParseOptions#trace}).
     */
    final ArrayListLong traceTimings;

    // ---------------------------------------------------------------------------------------------

    /**
     * Maps parser names to a set of parser metrics.
     *
     * <p>Can be reused accross parses using {@link ParseOptions#metrics}.
     */
    final ParseMetrics parseMetrics;

    // ---------------------------------------------------------------------------------------------

    private Parse (String string, List<?> list, ParseOptions options)
    {
        assert string != null && list == null || string == null && list != null;

        options = options != null ? options : ParseOptions.get();

        this.string = string != null ? string.codePoints().toArray() : null;
        this.list = list;
        this.endOfInput = this.string != null ? this.string.length : list.size();
        this.options = options;
        this.callStack = options.recordCallStack ? new ParserCallStack() : null;
        this.traceTimings = options.trace ? new ArrayListLong(256) : null;
        this.parseMetrics = options.trace ? options.metrics.get() : null;
    }

    // ---------------------------------------------------------------------------------------------

    /**
     * @see Autumn#parse
     */
    static ParseResult run (Parser parser, String string, List<?> list, ParseOptions options)
    {
        if (options.wellFormednessCheck)
        {
            WellFormednessChecker checker = new WellFormednessChecker();

            if (!checker.wellFormed(parser))
            {
                StringBuilder b = new StringBuilder();

                for (Parser p: checker.leftRecursives) {
                    b.append("\n- Left-recursive parser cycle detected, passing through parser: ");

                    try { b.append(p); }
                    catch(StackOverflowError e) {
                        // Rules names weren't used and getting the parser name recurses infinitely.
                        b.append(parser.getClass());
                        b.append(" (infinite recursion in toString)");
                    }
                }

                for (Parser p: checker.nullableRepetitions)
                    b   .append("\n- Nullable repetition detected: ")
                        .append(p);

                throw new MalformedGrammarError(b.toString(), checker);
            }
        }

        Parse parse = new Parse(string, list, options);
        Throwable thrown = null;
        boolean success = false;
        try { success = parser.parse(parse); }
        catch (StackOverflowError e) { throw e; } // (1)
        catch (Throwable t) { thrown = t; }
        finally {
            for (ParseState<?> state: parse.parseStates)
                state.discardCache(parse);
        }

        // (1) wrapped in PotentiallyMalformedGrammarError in Autumn#parse

        boolean fullMatch
            = success && parse.pos == parse.inputLength();

        int matchSize
            = success ? parse.pos : -1;

        int errorPosition
            = fullMatch
                ? -1
                : thrown != null
                    ? parse.pos
                    : parse.error;

        String errorMessage
            = fullMatch
                ? null
                : thrown != null
                    ? thrown.getMessage()
                    : parse.errorMessage;

        ParserCallStack errorCallStack
            = thrown != null
                ? parse.callStack
                : fullMatch
                    ? null
                    : parse.errorCallStack;

        return new ParseResult(
            success,
            fullMatch,
            matchSize,
            thrown,
            parser,
            options,
            errorPosition,
            errorMessage,
            parse.stack,
            parse.stateData,
            errorCallStack,
            parse.parseMetrics);
    }

    // ---------------------------------------------------------------------------------------------

    /**
     * An optional message associated with the furthest error position.
     */
    public String errorMessage() {
        return errorMessage;
    }

    // ---------------------------------------------------------------------------------------------

    /**
     * Set the value for {@link #errorMessage()}.
     *
     * <p>If {@code string == errorMessage()}, a copy of {@code string} will be used instead,
     * to ensure we can detect the change in error message.
     */
    public void setErrorMessage (String string)
    {
        //noinspection StringEquality
        if (string == errorMessage)
            //noinspection StringOperationCanBeSimplified
            errorMessage = new String(string);
        else
            errorMessage = string;
    }

    // ---------------------------------------------------------------------------------------------

    /**
     * A generic method returning the size of the input that abstracts over whether this parse
     * is over a string or a list. Not affected by {@link #endOfInput}.
     */
    public int inputLength()
    {
        return string != null
            ? string.length
            : list.size();
    }

    // ---------------------------------------------------------------------------------------------

    /**
     * Returns the character from {@link #string} at the given index,
     * or 0 if {@code index == string.length}.
     */
    public int charAt (int index)
    {
        assert string != null;
        return index != endOfInput
            ? string[index]
            : 0;
    }

    // ---------------------------------------------------------------------------------------------

    /**
     * Returns the object from {@link #list} at the given index,
     * or null if {@code index == list.size()}.
     */
    public Object objectAt (int index)
    {
        assert list != null;
        return index < list.size()
            ? list.get(index)
            : null;
    }

    // ---------------------------------------------------------------------------------------------

    /**
     * Returns true if the given string candidate appears in the parse's input string at the given
     * index. This function is safe even if the string candidate is longer than the remaining input.
     */
    public boolean match (int index, String candidate)
    {
        OfInt it = Arrays.stream(string, index, string.length).iterator();
        return candidate.codePoints().sequential().allMatch((c) -> it.hasNext() && c == it.next());
    }

    // ---------------------------------------------------------------------------------------------

    /**
     * Returns true if the given string candidate appears in the parse's input string at the given
     * index. This function is safe even if the string candidate is longer than the remaining input.
     */
    public boolean match (int index, int[] candidate)
    {
        assert string != null;

        if(index + candidate.length > string.length)
        	return false;
        for(int i = 0; i < candidate.length; i++)
        	if(string[index + i] != candidate[i])
        		return false;
        
        return true;
    }

    // ---------------------------------------------------------------------------------------------

    /**
     * To call before invoking a parser whose leading whitespace we want to know, returns
     * the position at which that leading whitespace starts.
     *
     * <p>Returns {@link #pos} if whitespace tracking is {@link ParseOptions#trackWhitespace
     * disabled} or if there is no leading whitespace at the parser invocation position.
     *
     * <p>Used to construct an {@link ActionContext} and so used by any parser that consumes
     * instances of {@link StackAction}.
     */
    public int leadingWhitespaceStart()
    {
        return !options.trackWhitespace
            ? pos
            : whitespaceEnd == pos
                ? whitespaceStart
                : pos;
    }

    // ---------------------------------------------------------------------------------------------

    /**
     * To call after invoking a parser whose trailing whitespace we want to know, returns
     * the position at which that trailing whitespace starts.
     *
     * <p>Returns {@link #pos} if whitespace tracking is {@link ParseOptions#trackWhitespace
     * disabled} or if there is no trailing whitespace at the parser invocation position.
     *
     * <p>Used to construct an {@link ActionContext} and so used by any parser that consumes
     * instances of {@link StackAction}.
     *
     * @param pos0 the position at which the parser was invoked.
     */
    public int trailingWhitespaceStart(int pos0)
    {
        return !options.trackWhitespace
            ? pos
            : pos > pos0 && whitespaceEnd == pos
                ? whitespaceStart
                : pos;
    }

    // ---------------------------------------------------------------------------------------------

    /**
     * To call after matching some whitespace, from {@code pos0} to the {@link #pos current position}.
     *
     * <p>Called by built-in parsers {@link TrailingWhitespace} and {@link StringMatch}.
     */
    public void setWhitespaceFrom (int pos0)
    {
        final int whitespaceStart0 = whitespaceStart;
        final int whitespaceEnd0 = whitespaceEnd;
        log.apply(() -> {
            whitespaceStart = pos0;
            whitespaceEnd = pos;
            return () -> {
                whitespaceStart = whitespaceStart0;
                whitespaceEnd = whitespaceEnd0;
            };
        });
    }

    // ---------------------------------------------------------------------------------------------
}
